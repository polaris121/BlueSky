{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\oplog_v2_converter.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mongo/oplog_v2_converter.ts","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\oplog_v2_converter.ts","inputSourceMap":{"version":3,"file":"packages/mongo/oplog_v2_converter.ts","sourceRoot":"","sources":["packages/mongo/oplog_v2_converter.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCG;AAEH,OAAO,EAAE,KAAK,EAAE,MAAM,cAAc,CAAC;AAqBrC,MAAM,qBAAqB,GAAG,eAAe,CAAC;AAE9C;;GAEG;AACH,SAAS,kBAAkB,CAAC,KAAa;IACvC,OAAO,qBAAqB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3C,CAAC;AAED;;;GAGG;AACH,SAAS,eAAe,CAAC,QAAiB;IACxC,OAAO,CACL,QAAQ,KAAK,IAAI;QACjB,OAAO,QAAQ,KAAK,QAAQ;QAC5B,GAAG,IAAI,QAAQ;QACd,QAA0B,CAAC,CAAC,KAAK,IAAI;QACtC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAChD,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,SAAS,IAAI,CAAC,MAAc,EAAE,GAAW;IACvC,OAAO,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;AAC3C,CAAC;AAED;;;;;;;;GAQG;AACH,SAAS,iBAAiB,CACxB,MAA2B,EAC3B,MAAW,EACX,MAAc;IAEd,IACE,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC;QACrB,OAAO,MAAM,KAAK,QAAQ;QAC1B,MAAM,KAAK,IAAI;QACf,MAAM,YAAY,KAAK,CAAC,QAAQ;QAChC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,EAC3B,CAAC;QACD,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;QACxB,OAAO;IACT,CAAC;IAED,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACvC,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;QACnB,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE;YAC/B,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC;QACtD,CAAC,CAAC,CAAC;IACL,CAAC;SAAM,CAAC;QACN,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;IAC1B,CAAC;AACH,CAAC;AAED;;;;;;;;;;GAUG;AACH,SAAS,gBAAgB,CACvB,UAAsB,EACtB,IAAe,EACf,MAAM,GAAG,EAAE;IAEX,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,EAAE;QAChD,IAAI,OAAO,KAAK,GAAG,EAAE,CAAC;YACpB,mBAAmB;YACnB,UAAU,CAAC,MAAM,KAAK,EAAE,CAAC;YACzB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBAC/B,UAAU,CAAC,MAAO,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;YAC/C,CAAC,CAAC,CAAC;QACL,CAAC;aAAM,IAAI,OAAO,KAAK,GAAG,EAAE,CAAC;YAC3B,sCAAsC;YACtC,UAAU,CAAC,IAAI,KAAK,EAAE,CAAC;YACvB,iBAAiB,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;QACpD,CAAC;aAAM,IAAI,OAAO,KAAK,GAAG,EAAE,CAAC;YAC3B,sBAAsB;YACtB,UAAU,CAAC,IAAI,KAAK,EAAE,CAAC;YACvB,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,UAAU,CAAC,EAAE,EAAE;gBAClD,UAAU,CAAC,IAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC;YACnD,CAAC,CAAC,CAAC;QACL,CAAC;aAAM,IAAI,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;YACnC,wDAAwD;YACxD,MAAM,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC7B,IAAI,eAAe,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC3B,iBAAiB;gBACjB,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,EAAE,UAAU,CAAC,EAAE,EAAE;oBACvD,IAAI,QAAQ,KAAK,GAAG;wBAAE,OAAO;oBAE7B,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;oBAChE,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;wBACxB,gBAAgB,CAAC,UAAU,EAAE,UAAU,EAAE,WAAW,CAAC,CAAC;oBACxD,CAAC;yBAAM,IAAI,UAAU,KAAK,IAAI,EAAE,CAAC;wBAC/B,UAAU,CAAC,MAAM,KAAK,EAAE,CAAC;wBACzB,UAAU,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC;oBACxC,CAAC;yBAAM,CAAC;wBACN,UAAU,CAAC,IAAI,KAAK,EAAE,CAAC;wBACvB,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,UAAU,CAAC;oBAC5C,CAAC;gBACH,CAAC,CAAC,CAAC;YACL,CAAC;iBAAM,IAAI,GAAG,EAAE,CAAC;gBACf,gBAAgB;gBAChB,gBAAgB,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC;YACzD,CAAC;QACH,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,kBAAkB,CAAC,UAAsB;IACvD,IAAI,UAAU,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;QAC5C,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,MAAM,mBAAmB,GAAe,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC;IAClD,gBAAgB,CAAC,mBAAmB,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;IACvD,OAAO,mBAAmB,CAAC;AAC7B,CAAC","sourcesContent":["/**\n * Converter module for the new MongoDB Oplog format (>=5.0) to the one that Meteor\n * handles well, i.e., `$set` and `$unset`. The new format is completely new,\n * and looks as follows:\n *\n * ```js\n * { $v: 2, diff: Diff }\n * ```\n *\n * where `Diff` is a recursive structure:\n * ```js\n * {\n *   // Nested updates (sometimes also represented with an s-field).\n *   // Example: `{ $set: { 'foo.bar': 1 } }`.\n *   i: { <key>: <value>, ... },\n *\n *   // Top-level updates.\n *   // Example: `{ $set: { foo: { bar: 1 } } }`.\n *   u: { <key>: <value>, ... },\n *\n *   // Unsets.\n *   // Example: `{ $unset: { foo: '' } }`.\n *   d: { <key>: false, ... },\n *\n *   // Array operations.\n *   // Example: `{ $push: { foo: 'bar' } }`.\n *   s<key>: { a: true, u<index>: <value>, ... },\n *   ...\n *\n *   // Nested operations (sometimes also represented in the `i` field).\n *   // Example: `{ $set: { 'foo.bar': 1 } }`.\n *   s<key>: Diff,\n *   ...\n * }\n * ```\n *\n * (all fields are optional)\n */\n\nimport { EJSON } from 'meteor/ejson';\n\ninterface OplogEntry {\n  $v: number;\n  diff?: OplogDiff;\n  $set?: Record<string, any>;\n  $unset?: Record<string, true>;\n}\n\ninterface OplogDiff {\n  i?: Record<string, any>;\n  u?: Record<string, any>;\n  d?: Record<string, boolean>;\n  [key: `s${string}`]: ArrayOperator | Record<string, any>;\n}\n\ninterface ArrayOperator {\n  a: true;\n  [key: `u${number}`]: any;\n}\n\nconst arrayOperatorKeyRegex = /^(a|[su]\\d+)$/;\n\n/**\n * Checks if a field is an array operator key of form 'a' or 's1' or 'u1' etc\n */\nfunction isArrayOperatorKey(field: string): boolean {\n  return arrayOperatorKeyRegex.test(field);\n}\n\n/**\n * Type guard to check if an operator is a valid array operator.\n * Array operators have 'a: true' and keys that match the arrayOperatorKeyRegex\n */\nfunction isArrayOperator(operator: unknown): operator is ArrayOperator {\n  return (\n    operator !== null &&\n    typeof operator === 'object' &&\n    'a' in operator &&\n    (operator as ArrayOperator).a === true &&\n    Object.keys(operator).every(isArrayOperatorKey)\n  );\n}\n\n/**\n * Joins two parts of a field path with a dot.\n * Returns the key itself if prefix is empty.\n */\nfunction join(prefix: string, key: string): string {\n  return prefix ? `${prefix}.${key}` : key;\n}\n\n/**\n * Recursively flattens an object into a target object with dot notation paths.\n * Handles special cases:\n * - Arrays are assigned directly\n * - Custom EJSON types are preserved\n * - Mongo.ObjectIDs are preserved\n * - Plain objects are recursively flattened\n * - Empty objects are assigned directly\n */\nfunction flattenObjectInto(\n  target: Record<string, any>,\n  source: any,\n  prefix: string\n): void {\n  if (\n    Array.isArray(source) ||\n    typeof source !== 'object' ||\n    source === null ||\n    source instanceof Mongo.ObjectID ||\n    EJSON._isCustomType(source)\n  ) {\n    target[prefix] = source;\n    return;\n  }\n\n  const entries = Object.entries(source);\n  if (entries.length) {\n    entries.forEach(([key, value]) => {\n      flattenObjectInto(target, value, join(prefix, key));\n    });\n  } else {\n    target[prefix] = source;\n  }\n}\n\n/**\n * Converts an oplog diff to a series of $set and $unset operations.\n * Handles several types of operations:\n * - Direct unsets via 'd' field\n * - Nested sets via 'i' field\n * - Top-level sets via 'u' field\n * - Array operations and nested objects via 's' prefixed fields\n *\n * Preserves the structure of EJSON custom types and ObjectIDs while\n * flattening paths into dot notation for MongoDB updates.\n */\nfunction convertOplogDiff(\n  oplogEntry: OplogEntry,\n  diff: OplogDiff,\n  prefix = ''\n): void {\n  Object.entries(diff).forEach(([diffKey, value]) => {\n    if (diffKey === 'd') {\n      // Handle `$unset`s\n      oplogEntry.$unset ??= {};\n      Object.keys(value).forEach(key => {\n        oplogEntry.$unset![join(prefix, key)] = true;\n      });\n    } else if (diffKey === 'i') {\n      // Handle (potentially) nested `$set`s\n      oplogEntry.$set ??= {};\n      flattenObjectInto(oplogEntry.$set, value, prefix);\n    } else if (diffKey === 'u') {\n      // Handle flat `$set`s\n      oplogEntry.$set ??= {};\n      Object.entries(value).forEach(([key, fieldValue]) => {\n        oplogEntry.$set![join(prefix, key)] = fieldValue;\n      });\n    } else if (diffKey.startsWith('s')) {\n      // Handle s-fields (array operations and nested objects)\n      const key = diffKey.slice(1);\n      if (isArrayOperator(value)) {\n        // Array operator\n        Object.entries(value).forEach(([position, fieldValue]) => {\n          if (position === 'a') return;\n\n          const positionKey = join(prefix, `${key}.${position.slice(1)}`);\n          if (position[0] === 's') {\n            convertOplogDiff(oplogEntry, fieldValue, positionKey);\n          } else if (fieldValue === null) {\n            oplogEntry.$unset ??= {};\n            oplogEntry.$unset[positionKey] = true;\n          } else {\n            oplogEntry.$set ??= {};\n            oplogEntry.$set[positionKey] = fieldValue;\n          }\n        });\n      } else if (key) {\n        // Nested object\n        convertOplogDiff(oplogEntry, value, join(prefix, key));\n      }\n    }\n  });\n}\n\n/**\n * Converts a MongoDB v2 oplog entry to v1 format.\n * Returns the original entry unchanged if it's not a v2 oplog entry\n * or doesn't contain a diff field.\n *\n * The converted entry will contain $set and $unset operations that are\n * equivalent to the v2 diff format, with paths flattened to dot notation\n * and special handling for EJSON custom types and ObjectIDs.\n */\nexport function oplogV2V1Converter(oplogEntry: OplogEntry): OplogEntry {\n  if (oplogEntry.$v !== 2 || !oplogEntry.diff) {\n    return oplogEntry;\n  }\n\n  const convertedOplogEntry: OplogEntry = { $v: 2 };\n  convertOplogDiff(convertedOplogEntry, oplogEntry.diff);\n  return convertedOplogEntry;\n}"]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"production","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\oplog_v2_converter.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/oplog_v2_converter.ts","inputSourceMap":{"version":3,"file":"packages/mongo/oplog_v2_converter.ts","sourceRoot":"","sources":["packages/mongo/oplog_v2_converter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Converter module for the new MongoDB Oplog format (>=5.0) to the one that Meteor\n * handles well, i.e., `$set` and `$unset`. The new format is completely new,\n * and looks as follows:\n *\n * ```js\n * { $v: 2, diff: Diff }\n * ```\n *\n * where `Diff` is a recursive structure:\n * ```js\n * {\n *   // Nested updates (sometimes also represented with an s-field).\n *   // Example: `{ $set: { 'foo.bar': 1 } }`.\n *   i: { <key>: <value>, ... },\n *\n *   // Top-level updates.\n *   // Example: `{ $set: { foo: { bar: 1 } } }`.\n *   u: { <key>: <value>, ... },\n *\n *   // Unsets.\n *   // Example: `{ $unset: { foo: '' } }`.\n *   d: { <key>: false, ... },\n *\n *   // Array operations.\n *   // Example: `{ $push: { foo: 'bar' } }`.\n *   s<key>: { a: true, u<index>: <value>, ... },\n *   ...\n *\n *   // Nested operations (sometimes also represented in the `i` field).\n *   // Example: `{ $set: { 'foo.bar': 1 } }`.\n *   s<key>: Diff,\n *   ...\n * }\n * ```\n *\n * (all fields are optional)\n */\n\nimport { EJSON } from 'meteor/ejson';\n\ninterface OplogEntry {\n  $v: number;\n  diff?: OplogDiff;\n  $set?: Record<string, any>;\n  $unset?: Record<string, true>;\n}\n\ninterface OplogDiff {\n  i?: Record<string, any>;\n  u?: Record<string, any>;\n  d?: Record<string, boolean>;\n  [key: `s${string}`]: ArrayOperator | Record<string, any>;\n}\n\ninterface ArrayOperator {\n  a: true;\n  [key: `u${number}`]: any;\n}\n\nconst arrayOperatorKeyRegex = /^(a|[su]\\d+)$/;\n\n/**\n * Checks if a field is an array operator key of form 'a' or 's1' or 'u1' etc\n */\nfunction isArrayOperatorKey(field: string): boolean {\n  return arrayOperatorKeyRegex.test(field);\n}\n\n/**\n * Type guard to check if an operator is a valid array operator.\n * Array operators have 'a: true' and keys that match the arrayOperatorKeyRegex\n */\nfunction isArrayOperator(operator: unknown): operator is ArrayOperator {\n  return (\n    operator !== null &&\n    typeof operator === 'object' &&\n    'a' in operator &&\n    (operator as ArrayOperator).a === true &&\n    Object.keys(operator).every(isArrayOperatorKey)\n  );\n}\n\n/**\n * Joins two parts of a field path with a dot.\n * Returns the key itself if prefix is empty.\n */\nfunction join(prefix: string, key: string): string {\n  return prefix ? `${prefix}.${key}` : key;\n}\n\n/**\n * Recursively flattens an object into a target object with dot notation paths.\n * Handles special cases:\n * - Arrays are assigned directly\n * - Custom EJSON types are preserved\n * - Mongo.ObjectIDs are preserved\n * - Plain objects are recursively flattened\n * - Empty objects are assigned directly\n */\nfunction flattenObjectInto(\n  target: Record<string, any>,\n  source: any,\n  prefix: string\n): void {\n  if (\n    Array.isArray(source) ||\n    typeof source !== 'object' ||\n    source === null ||\n    source instanceof Mongo.ObjectID ||\n    EJSON._isCustomType(source)\n  ) {\n    target[prefix] = source;\n    return;\n  }\n\n  const entries = Object.entries(source);\n  if (entries.length) {\n    entries.forEach(([key, value]) => {\n      flattenObjectInto(target, value, join(prefix, key));\n    });\n  } else {\n    target[prefix] = source;\n  }\n}\n\n/**\n * Converts an oplog diff to a series of $set and $unset operations.\n * Handles several types of operations:\n * - Direct unsets via 'd' field\n * - Nested sets via 'i' field\n * - Top-level sets via 'u' field\n * - Array operations and nested objects via 's' prefixed fields\n *\n * Preserves the structure of EJSON custom types and ObjectIDs while\n * flattening paths into dot notation for MongoDB updates.\n */\nfunction convertOplogDiff(\n  oplogEntry: OplogEntry,\n  diff: OplogDiff,\n  prefix = ''\n): void {\n  Object.entries(diff).forEach(([diffKey, value]) => {\n    if (diffKey === 'd') {\n      // Handle `$unset`s\n      oplogEntry.$unset ??= {};\n      Object.keys(value).forEach(key => {\n        oplogEntry.$unset![join(prefix, key)] = true;\n      });\n    } else if (diffKey === 'i') {\n      // Handle (potentially) nested `$set`s\n      oplogEntry.$set ??= {};\n      flattenObjectInto(oplogEntry.$set, value, prefix);\n    } else if (diffKey === 'u') {\n      // Handle flat `$set`s\n      oplogEntry.$set ??= {};\n      Object.entries(value).forEach(([key, fieldValue]) => {\n        oplogEntry.$set![join(prefix, key)] = fieldValue;\n      });\n    } else if (diffKey.startsWith('s')) {\n      // Handle s-fields (array operations and nested objects)\n      const key = diffKey.slice(1);\n      if (isArrayOperator(value)) {\n        // Array operator\n        Object.entries(value).forEach(([position, fieldValue]) => {\n          if (position === 'a') return;\n\n          const positionKey = join(prefix, `${key}.${position.slice(1)}`);\n          if (position[0] === 's') {\n            convertOplogDiff(oplogEntry, fieldValue, positionKey);\n          } else if (fieldValue === null) {\n            oplogEntry.$unset ??= {};\n            oplogEntry.$unset[positionKey] = true;\n          } else {\n            oplogEntry.$set ??= {};\n            oplogEntry.$set[positionKey] = fieldValue;\n          }\n        });\n      } else if (key) {\n        // Nested object\n        convertOplogDiff(oplogEntry, value, join(prefix, key));\n      }\n    }\n  });\n}\n\n/**\n * Converts a MongoDB v2 oplog entry to v1 format.\n * Returns the original entry unchanged if it's not a v2 oplog entry\n * or doesn't contain a diff field.\n *\n * The converted entry will contain $set and $unset operations that are\n * equivalent to the v2 diff format, with paths flattened to dot notation\n * and special handling for EJSON custom types and ObjectIDs.\n */\nexport function oplogV2V1Converter(oplogEntry: OplogEntry): OplogEntry {\n  if (oplogEntry.$v !== 2 || !oplogEntry.diff) {\n    return oplogEntry;\n  }\n\n  const convertedOplogEntry: OplogEntry = { $v: 2 };\n  convertOplogDiff(convertedOplogEntry, oplogEntry.diff);\n  return convertedOplogEntry;\n}"]}}},"code":"!module.wrapAsync(async function (module1, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module1.export({\n      oplogV2V1Converter: () => oplogV2V1Converter\n    });\n    let EJSON;\n    module1.link(\"meteor/ejson\", {\n      EJSON(v) {\n        EJSON = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    const arrayOperatorKeyRegex = /^(a|[su]\\d+)$/;\n    /**\n     * Checks if a field is an array operator key of form 'a' or 's1' or 'u1' etc\n     */\n    function isArrayOperatorKey(field) {\n      return arrayOperatorKeyRegex.test(field);\n    }\n    /**\n     * Type guard to check if an operator is a valid array operator.\n     * Array operators have 'a: true' and keys that match the arrayOperatorKeyRegex\n     */\n    function isArrayOperator(operator) {\n      return operator !== null && typeof operator === 'object' && 'a' in operator && operator.a === true && Object.keys(operator).every(isArrayOperatorKey);\n    }\n    /**\n     * Joins two parts of a field path with a dot.\n     * Returns the key itself if prefix is empty.\n     */\n    function join(prefix, key) {\n      return prefix ? \"\".concat(prefix, \".\").concat(key) : key;\n    }\n    /**\n     * Recursively flattens an object into a target object with dot notation paths.\n     * Handles special cases:\n     * - Arrays are assigned directly\n     * - Custom EJSON types are preserved\n     * - Mongo.ObjectIDs are preserved\n     * - Plain objects are recursively flattened\n     * - Empty objects are assigned directly\n     */\n    function flattenObjectInto(target, source, prefix) {\n      if (Array.isArray(source) || typeof source !== 'object' || source === null || source instanceof Mongo.ObjectID || EJSON._isCustomType(source)) {\n        target[prefix] = source;\n        return;\n      }\n      const entries = Object.entries(source);\n      if (entries.length) {\n        entries.forEach(_ref => {\n          let [key, value] = _ref;\n          flattenObjectInto(target, value, join(prefix, key));\n        });\n      } else {\n        target[prefix] = source;\n      }\n    }\n    /**\n     * Converts an oplog diff to a series of $set and $unset operations.\n     * Handles several types of operations:\n     * - Direct unsets via 'd' field\n     * - Nested sets via 'i' field\n     * - Top-level sets via 'u' field\n     * - Array operations and nested objects via 's' prefixed fields\n     *\n     * Preserves the structure of EJSON custom types and ObjectIDs while\n     * flattening paths into dot notation for MongoDB updates.\n     */\n    function convertOplogDiff(oplogEntry, diff) {\n      let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      Object.entries(diff).forEach(_ref2 => {\n        let [diffKey, value] = _ref2;\n        if (diffKey === 'd') {\n          var _oplogEntry$$unset;\n          // Handle `$unset`s\n          (_oplogEntry$$unset = oplogEntry.$unset) !== null && _oplogEntry$$unset !== void 0 ? _oplogEntry$$unset : oplogEntry.$unset = {};\n          Object.keys(value).forEach(key => {\n            oplogEntry.$unset[join(prefix, key)] = true;\n          });\n        } else if (diffKey === 'i') {\n          var _oplogEntry$$set;\n          // Handle (potentially) nested `$set`s\n          (_oplogEntry$$set = oplogEntry.$set) !== null && _oplogEntry$$set !== void 0 ? _oplogEntry$$set : oplogEntry.$set = {};\n          flattenObjectInto(oplogEntry.$set, value, prefix);\n        } else if (diffKey === 'u') {\n          var _oplogEntry$$set2;\n          // Handle flat `$set`s\n          (_oplogEntry$$set2 = oplogEntry.$set) !== null && _oplogEntry$$set2 !== void 0 ? _oplogEntry$$set2 : oplogEntry.$set = {};\n          Object.entries(value).forEach(_ref3 => {\n            let [key, fieldValue] = _ref3;\n            oplogEntry.$set[join(prefix, key)] = fieldValue;\n          });\n        } else if (diffKey.startsWith('s')) {\n          // Handle s-fields (array operations and nested objects)\n          const key = diffKey.slice(1);\n          if (isArrayOperator(value)) {\n            // Array operator\n            Object.entries(value).forEach(_ref4 => {\n              let [position, fieldValue] = _ref4;\n              if (position === 'a') return;\n              const positionKey = join(prefix, \"\".concat(key, \".\").concat(position.slice(1)));\n              if (position[0] === 's') {\n                convertOplogDiff(oplogEntry, fieldValue, positionKey);\n              } else if (fieldValue === null) {\n                var _oplogEntry$$unset2;\n                (_oplogEntry$$unset2 = oplogEntry.$unset) !== null && _oplogEntry$$unset2 !== void 0 ? _oplogEntry$$unset2 : oplogEntry.$unset = {};\n                oplogEntry.$unset[positionKey] = true;\n              } else {\n                var _oplogEntry$$set3;\n                (_oplogEntry$$set3 = oplogEntry.$set) !== null && _oplogEntry$$set3 !== void 0 ? _oplogEntry$$set3 : oplogEntry.$set = {};\n                oplogEntry.$set[positionKey] = fieldValue;\n              }\n            });\n          } else if (key) {\n            // Nested object\n            convertOplogDiff(oplogEntry, value, join(prefix, key));\n          }\n        }\n      });\n    }\n    /**\n     * Converts a MongoDB v2 oplog entry to v1 format.\n     * Returns the original entry unchanged if it's not a v2 oplog entry\n     * or doesn't contain a diff field.\n     *\n     * The converted entry will contain $set and $unset operations that are\n     * equivalent to the v2 diff format, with paths flattened to dot notation\n     * and special handling for EJSON custom types and ObjectIDs.\n     */\n    function oplogV2V1Converter(oplogEntry) {\n      if (oplogEntry.$v !== 2 || !oplogEntry.diff) {\n        return oplogEntry;\n      }\n      const convertedOplogEntry = {\n        $v: 2\n      };\n      convertOplogDiff(convertedOplogEntry, oplogEntry.diff);\n      return convertedOplogEntry;\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module1","export","oplogV2V1Converter","EJSON","link","v","__reifyWaitForDeps__","arrayOperatorKeyRegex","isArrayOperatorKey","field","test","isArrayOperator","operator","a","Object","keys","every","join","prefix","key","concat","flattenObjectInto","target","source","Array","isArray","Mongo","ObjectID","_isCustomType","entries","length","forEach","_ref","value","convertOplogDiff","oplogEntry","diff","arguments","undefined","_ref2","diffKey","_oplogEntry$$unset","$unset","_oplogEntry$$set","$set","_oplogEntry$$set2","_ref3","fieldValue","startsWith","slice","_ref4","position","positionKey","_oplogEntry$$unset2","_oplogEntry$$set3","$v","convertedOplogEntry","__reify_async_result__","_reifyError","self","async"],"sources":["packages/mongo/oplog_v2_converter.ts"],"sourcesContent":["/**\n * Converter module for the new MongoDB Oplog format (>=5.0) to the one that Meteor\n * handles well, i.e., `$set` and `$unset`. The new format is completely new,\n * and looks as follows:\n *\n * ```js\n * { $v: 2, diff: Diff }\n * ```\n *\n * where `Diff` is a recursive structure:\n * ```js\n * {\n *   // Nested updates (sometimes also represented with an s-field).\n *   // Example: `{ $set: { 'foo.bar': 1 } }`.\n *   i: { <key>: <value>, ... },\n *\n *   // Top-level updates.\n *   // Example: `{ $set: { foo: { bar: 1 } } }`.\n *   u: { <key>: <value>, ... },\n *\n *   // Unsets.\n *   // Example: `{ $unset: { foo: '' } }`.\n *   d: { <key>: false, ... },\n *\n *   // Array operations.\n *   // Example: `{ $push: { foo: 'bar' } }`.\n *   s<key>: { a: true, u<index>: <value>, ... },\n *   ...\n *\n *   // Nested operations (sometimes also represented in the `i` field).\n *   // Example: `{ $set: { 'foo.bar': 1 } }`.\n *   s<key>: Diff,\n *   ...\n * }\n * ```\n *\n * (all fields are optional)\n */\n\nimport { EJSON } from 'meteor/ejson';\n\ninterface OplogEntry {\n  $v: number;\n  diff?: OplogDiff;\n  $set?: Record<string, any>;\n  $unset?: Record<string, true>;\n}\n\ninterface OplogDiff {\n  i?: Record<string, any>;\n  u?: Record<string, any>;\n  d?: Record<string, boolean>;\n  [key: `s${string}`]: ArrayOperator | Record<string, any>;\n}\n\ninterface ArrayOperator {\n  a: true;\n  [key: `u${number}`]: any;\n}\n\nconst arrayOperatorKeyRegex = /^(a|[su]\\d+)$/;\n\n/**\n * Checks if a field is an array operator key of form 'a' or 's1' or 'u1' etc\n */\nfunction isArrayOperatorKey(field: string): boolean {\n  return arrayOperatorKeyRegex.test(field);\n}\n\n/**\n * Type guard to check if an operator is a valid array operator.\n * Array operators have 'a: true' and keys that match the arrayOperatorKeyRegex\n */\nfunction isArrayOperator(operator: unknown): operator is ArrayOperator {\n  return (\n    operator !== null &&\n    typeof operator === 'object' &&\n    'a' in operator &&\n    (operator as ArrayOperator).a === true &&\n    Object.keys(operator).every(isArrayOperatorKey)\n  );\n}\n\n/**\n * Joins two parts of a field path with a dot.\n * Returns the key itself if prefix is empty.\n */\nfunction join(prefix: string, key: string): string {\n  return prefix ? `${prefix}.${key}` : key;\n}\n\n/**\n * Recursively flattens an object into a target object with dot notation paths.\n * Handles special cases:\n * - Arrays are assigned directly\n * - Custom EJSON types are preserved\n * - Mongo.ObjectIDs are preserved\n * - Plain objects are recursively flattened\n * - Empty objects are assigned directly\n */\nfunction flattenObjectInto(\n  target: Record<string, any>,\n  source: any,\n  prefix: string\n): void {\n  if (\n    Array.isArray(source) ||\n    typeof source !== 'object' ||\n    source === null ||\n    source instanceof Mongo.ObjectID ||\n    EJSON._isCustomType(source)\n  ) {\n    target[prefix] = source;\n    return;\n  }\n\n  const entries = Object.entries(source);\n  if (entries.length) {\n    entries.forEach(([key, value]) => {\n      flattenObjectInto(target, value, join(prefix, key));\n    });\n  } else {\n    target[prefix] = source;\n  }\n}\n\n/**\n * Converts an oplog diff to a series of $set and $unset operations.\n * Handles several types of operations:\n * - Direct unsets via 'd' field\n * - Nested sets via 'i' field\n * - Top-level sets via 'u' field\n * - Array operations and nested objects via 's' prefixed fields\n *\n * Preserves the structure of EJSON custom types and ObjectIDs while\n * flattening paths into dot notation for MongoDB updates.\n */\nfunction convertOplogDiff(\n  oplogEntry: OplogEntry,\n  diff: OplogDiff,\n  prefix = ''\n): void {\n  Object.entries(diff).forEach(([diffKey, value]) => {\n    if (diffKey === 'd') {\n      // Handle `$unset`s\n      oplogEntry.$unset ??= {};\n      Object.keys(value).forEach(key => {\n        oplogEntry.$unset![join(prefix, key)] = true;\n      });\n    } else if (diffKey === 'i') {\n      // Handle (potentially) nested `$set`s\n      oplogEntry.$set ??= {};\n      flattenObjectInto(oplogEntry.$set, value, prefix);\n    } else if (diffKey === 'u') {\n      // Handle flat `$set`s\n      oplogEntry.$set ??= {};\n      Object.entries(value).forEach(([key, fieldValue]) => {\n        oplogEntry.$set![join(prefix, key)] = fieldValue;\n      });\n    } else if (diffKey.startsWith('s')) {\n      // Handle s-fields (array operations and nested objects)\n      const key = diffKey.slice(1);\n      if (isArrayOperator(value)) {\n        // Array operator\n        Object.entries(value).forEach(([position, fieldValue]) => {\n          if (position === 'a') return;\n\n          const positionKey = join(prefix, `${key}.${position.slice(1)}`);\n          if (position[0] === 's') {\n            convertOplogDiff(oplogEntry, fieldValue, positionKey);\n          } else if (fieldValue === null) {\n            oplogEntry.$unset ??= {};\n            oplogEntry.$unset[positionKey] = true;\n          } else {\n            oplogEntry.$set ??= {};\n            oplogEntry.$set[positionKey] = fieldValue;\n          }\n        });\n      } else if (key) {\n        // Nested object\n        convertOplogDiff(oplogEntry, value, join(prefix, key));\n      }\n    }\n  });\n}\n\n/**\n * Converts a MongoDB v2 oplog entry to v1 format.\n * Returns the original entry unchanged if it's not a v2 oplog entry\n * or doesn't contain a diff field.\n *\n * The converted entry will contain $set and $unset operations that are\n * equivalent to the v2 diff format, with paths flattened to dot notation\n * and special handling for EJSON custom types and ObjectIDs.\n */\nexport function oplogV2V1Converter(oplogEntry: OplogEntry): OplogEntry {\n  if (oplogEntry.$v !== 2 || !oplogEntry.diff) {\n    return oplogEntry;\n  }\n\n  const convertedOplogEntry: OplogEntry = { $v: 2 };\n  convertOplogDiff(convertedOplogEntry, oplogEntry.diff);\n  return convertedOplogEntry;\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"7f9bbd786f28792976fc774b88b695d147bc5e5b"}

{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/ddp-client/common/document_processors.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-client/common/document_processors.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      DocumentProcessors: () => DocumentProcessors\n    });\n    let MongoID;\n    module.link(\"meteor/mongo-id\", {\n      MongoID(v) {\n        MongoID = v;\n      }\n    }, 0);\n    let DiffSequence;\n    module.link(\"meteor/diff-sequence\", {\n      DiffSequence(v) {\n        DiffSequence = v;\n      }\n    }, 1);\n    let hasOwn;\n    module.link(\"meteor/ddp-common/utils\", {\n      hasOwn(v) {\n        hasOwn = v;\n      }\n    }, 2);\n    let isEmpty;\n    module.link(\"meteor/ddp-common/utils\", {\n      isEmpty(v) {\n        isEmpty = v;\n      }\n    }, 3);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class DocumentProcessors {\n      constructor(connection) {\n        this._connection = connection;\n      }\n\n      /**\n       * @summary Process an 'added' message from the server\n       * @param {Object} msg The added message\n       * @param {Object} updates The updates accumulator\n       */\n      async _process_added(msg, updates) {\n        const self = this._connection;\n        const id = MongoID.idParse(msg.id);\n        const serverDoc = self._getServerDoc(msg.collection, id);\n        if (serverDoc) {\n          // Some outstanding stub wrote here.\n          const isExisting = serverDoc.document !== undefined;\n          serverDoc.document = msg.fields || Object.create(null);\n          serverDoc.document._id = id;\n          if (self._resetStores) {\n            // During reconnect the server is sending adds for existing ids.\n            // Always push an update so that document stays in the store after\n            // reset. Use current version of the document for this update, so\n            // that stub-written values are preserved.\n            const currentDoc = await self._stores[msg.collection].getDoc(msg.id);\n            if (currentDoc !== undefined) msg.fields = currentDoc;\n            self._pushUpdate(updates, msg.collection, msg);\n          } else if (isExisting) {\n            throw new Error('Server sent add for existing id: ' + msg.id);\n          }\n        } else {\n          self._pushUpdate(updates, msg.collection, msg);\n        }\n      }\n\n      /**\n       * @summary Process a 'changed' message from the server\n       * @param {Object} msg The changed message\n       * @param {Object} updates The updates accumulator\n       */\n      _process_changed(msg, updates) {\n        const self = this._connection;\n        const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n        if (serverDoc) {\n          if (serverDoc.document === undefined) {\n            throw new Error('Server sent changed for nonexisting id: ' + msg.id);\n          }\n          DiffSequence.applyChanges(serverDoc.document, msg.fields);\n        } else {\n          self._pushUpdate(updates, msg.collection, msg);\n        }\n      }\n\n      /**\n       * @summary Process a 'removed' message from the server\n       * @param {Object} msg The removed message\n       * @param {Object} updates The updates accumulator\n       */\n      _process_removed(msg, updates) {\n        const self = this._connection;\n        const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n        if (serverDoc) {\n          // Some outstanding stub wrote here.\n          if (serverDoc.document === undefined) {\n            throw new Error('Server sent removed for nonexisting id:' + msg.id);\n          }\n          serverDoc.document = undefined;\n        } else {\n          self._pushUpdate(updates, msg.collection, {\n            msg: 'removed',\n            collection: msg.collection,\n            id: msg.id\n          });\n        }\n      }\n\n      /**\n       * @summary Process a 'ready' message from the server\n       * @param {Object} msg The ready message\n       * @param {Object} updates The updates accumulator\n       */\n      _process_ready(msg, updates) {\n        const self = this._connection;\n\n        // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n        // until all current server documents have been flushed to the local\n        // database. We can use a write fence to implement this.\n        msg.subs.forEach(subId => {\n          self._runWhenAllServerDocsAreFlushed(() => {\n            const subRecord = self._subscriptions[subId];\n            // Did we already unsubscribe?\n            if (!subRecord) return;\n            // Did we already receive a ready message? (Oops!)\n            if (subRecord.ready) return;\n            subRecord.ready = true;\n            subRecord.readyCallback && subRecord.readyCallback();\n            subRecord.readyDeps.changed();\n          });\n        });\n      }\n\n      /**\n       * @summary Process an 'updated' message from the server\n       * @param {Object} msg The updated message\n       * @param {Object} updates The updates accumulator\n       */\n      _process_updated(msg, updates) {\n        const self = this._connection;\n        // Process \"method done\" messages.\n        msg.methods.forEach(methodId => {\n          const docs = self._documentsWrittenByStub[methodId] || {};\n          Object.values(docs).forEach(written => {\n            const serverDoc = self._getServerDoc(written.collection, written.id);\n            if (!serverDoc) {\n              throw new Error('Lost serverDoc for ' + JSON.stringify(written));\n            }\n            if (!serverDoc.writtenByStubs[methodId]) {\n              throw new Error('Doc ' + JSON.stringify(written) + ' not written by method ' + methodId);\n            }\n            delete serverDoc.writtenByStubs[methodId];\n            if (isEmpty(serverDoc.writtenByStubs)) {\n              // All methods whose stubs wrote this method have completed! We can\n              // now copy the saved document to the database (reverting the stub's\n              // change if the server did not write to this object, or applying the\n              // server's writes if it did).\n\n              // This is a fake ddp 'replace' message.  It's just for talking\n              // between livedata connections and minimongo.  (We have to stringify\n              // the ID because it's supposed to look like a wire message.)\n              self._pushUpdate(updates, written.collection, {\n                msg: 'replace',\n                id: MongoID.idStringify(written.id),\n                replace: serverDoc.document\n              });\n              // Call all flush callbacks.\n              serverDoc.flushCallbacks.forEach(c => {\n                c();\n              });\n\n              // Delete this completed serverDocument. Don't bother to GC empty\n              // IdMaps inside self._serverDocuments, since there probably aren't\n              // many collections and they'll be written repeatedly.\n              self._serverDocuments[written.collection].remove(written.id);\n            }\n          });\n          delete self._documentsWrittenByStub[methodId];\n\n          // We want to call the data-written callback, but we can't do so until all\n          // currently buffered messages are flushed.\n          const callbackInvoker = self._methodInvokers[methodId];\n          if (!callbackInvoker) {\n            throw new Error('No callback invoker for method ' + methodId);\n          }\n          self._runWhenAllServerDocsAreFlushed(function () {\n            return callbackInvoker.dataVisible(...arguments);\n          });\n        });\n      }\n\n      /**\n       * @summary Push an update to the buffer\n       * @private\n       * @param {Object} updates The updates accumulator\n       * @param {String} collection The collection name\n       * @param {Object} msg The update message\n       */\n      _pushUpdate(updates, collection, msg) {\n        if (!hasOwn.call(updates, collection)) {\n          updates[collection] = [];\n        }\n        updates[collection].push(msg);\n      }\n\n      /**\n       * @summary Get a server document by collection and id\n       * @private\n       * @param {String} collection The collection name\n       * @param {String} id The document id\n       * @returns {Object|null} The server document or null\n       */\n      _getServerDoc(collection, id) {\n        const self = this._connection;\n        if (!hasOwn.call(self._serverDocuments, collection)) {\n          return null;\n        }\n        const serverDocsForCollection = self._serverDocuments[collection];\n        return serverDocsForCollection.get(id) || null;\n      }\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","DocumentProcessors","MongoID","link","v","DiffSequence","hasOwn","isEmpty","__reifyWaitForDeps__","constructor","connection","_connection","_process_added","msg","updates","self","id","idParse","serverDoc","_getServerDoc","collection","isExisting","document","undefined","fields","Object","create","_id","_resetStores","currentDoc","_stores","getDoc","_pushUpdate","Error","_process_changed","applyChanges","_process_removed","_process_ready","subs","forEach","subId","_runWhenAllServerDocsAreFlushed","subRecord","_subscriptions","ready","readyCallback","readyDeps","changed","_process_updated","methods","methodId","docs","_documentsWrittenByStub","values","written","JSON","stringify","writtenByStubs","idStringify","replace","flushCallbacks","c","_serverDocuments","remove","callbackInvoker","_methodInvokers","dataVisible","arguments","call","push","serverDocsForCollection","get","__reify_async_result__","_reifyError","async"],"sources":["packages/ddp-client/common/document_processors.js"],"sourcesContent":["import { MongoID } from 'meteor/mongo-id';\nimport { DiffSequence } from 'meteor/diff-sequence';\nimport { hasOwn } from \"meteor/ddp-common/utils\";\nimport { isEmpty } from \"meteor/ddp-common/utils\";\n\nexport class DocumentProcessors {\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process an 'added' message from the server\n   * @param {Object} msg The added message\n   * @param {Object} updates The updates accumulator\n   */\n  async _process_added(msg, updates) {\n    const self = this._connection;\n    const id = MongoID.idParse(msg.id);\n    const serverDoc = self._getServerDoc(msg.collection, id);\n\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      const isExisting = serverDoc.document !== undefined;\n\n      serverDoc.document = msg.fields || Object.create(null);\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        const currentDoc = await self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined) msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error('Server sent add for existing id: ' + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  }\n\n  /**\n   * @summary Process a 'changed' message from the server\n   * @param {Object} msg The changed message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_changed(msg, updates) {\n    const self = this._connection;\n    const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n\n    if (serverDoc) {\n      if (serverDoc.document === undefined) {\n        throw new Error('Server sent changed for nonexisting id: ' + msg.id);\n      }\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  }\n\n  /**\n   * @summary Process a 'removed' message from the server\n   * @param {Object} msg The removed message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_removed(msg, updates) {\n    const self = this._connection;\n    const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined) {\n        throw new Error('Server sent removed for nonexisting id:' + msg.id);\n      }\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  }\n\n  /**\n   * @summary Process a 'ready' message from the server\n   * @param {Object} msg The ready message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_ready(msg, updates) {\n    const self = this._connection;\n\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    msg.subs.forEach((subId) => {\n      self._runWhenAllServerDocsAreFlushed(() => {\n        const subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord) return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready) return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  }\n\n  /**\n   * @summary Process an 'updated' message from the server\n   * @param {Object} msg The updated message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_updated(msg, updates) {\n    const self = this._connection;\n    // Process \"method done\" messages.\n    msg.methods.forEach((methodId) => {\n      const docs = self._documentsWrittenByStub[methodId] || {};\n      Object.values(docs).forEach((written) => {\n        const serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc) {\n          throw new Error('Lost serverDoc for ' + JSON.stringify(written));\n        }\n        if (!serverDoc.writtenByStubs[methodId]) {\n          throw new Error(\n            'Doc ' +\n            JSON.stringify(written) +\n            ' not written by method ' +\n            methodId\n          );\n        }\n        delete serverDoc.writtenByStubs[methodId];\n        if (isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          serverDoc.flushCallbacks.forEach((c) => {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      const callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker) {\n        throw new Error('No callback invoker for method ' + methodId);\n      }\n\n      self._runWhenAllServerDocsAreFlushed(\n        (...args) => callbackInvoker.dataVisible(...args)\n      );\n    });\n  }\n\n  /**\n   * @summary Push an update to the buffer\n   * @private\n   * @param {Object} updates The updates accumulator\n   * @param {String} collection The collection name\n   * @param {Object} msg The update message\n   */\n  _pushUpdate(updates, collection, msg) {\n    if (!hasOwn.call(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  }\n\n  /**\n   * @summary Get a server document by collection and id\n   * @private\n   * @param {String} collection The collection name\n   * @param {String} id The document id\n   * @returns {Object|null} The server document or null\n   */\n  _getServerDoc(collection, id) {\n    const self = this._connection;\n    if (!hasOwn.call(self._serverDocuments, collection)) {\n      return null;\n    }\n    const serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  }\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"659fa137e48be8a8dca7060820fd94fd43819510"}

{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\mongo_common.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mongo/mongo_common.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\mongo_common.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"production","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\mongo_common.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/mongo_common.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      MongoDB: () => MongoDB,\n      writeCallback: () => writeCallback,\n      transformResult: () => transformResult,\n      replaceMeteorAtomWithMongo: () => replaceMeteorAtomWithMongo,\n      replaceTypes: () => replaceTypes,\n      replaceMongoAtomWithMeteor: () => replaceMongoAtomWithMeteor,\n      replaceNames: () => replaceNames\n    });\n    let clone;\n    module.link(\"lodash.clone\", {\n      default(v) {\n        clone = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    const MongoDB = Object.assign(NpmModuleMongodb, {\n      ObjectID: NpmModuleMongodb.ObjectId\n    });\n    const writeCallback = function (write, refresh, callback) {\n      return function (err, result) {\n        if (!err) {\n          // XXX We don't have to run this on error, right?\n          try {\n            refresh();\n          } catch (refreshErr) {\n            if (callback) {\n              callback(refreshErr);\n              return;\n            } else {\n              throw refreshErr;\n            }\n          }\n        }\n        write.committed();\n        if (callback) {\n          callback(err, result);\n        } else if (err) {\n          throw err;\n        }\n      };\n    };\n    const transformResult = function (driverResult) {\n      var meteorResult = {\n        numberAffected: 0\n      };\n      if (driverResult) {\n        var mongoResult = driverResult.result;\n        // On updates with upsert:true, the inserted values come as a list of\n        // upserted values -- even with options.multi, when the upsert does insert,\n        // it only inserts one element.\n        if (mongoResult.upsertedCount) {\n          meteorResult.numberAffected = mongoResult.upsertedCount;\n          if (mongoResult.upsertedId) {\n            meteorResult.insertedId = mongoResult.upsertedId;\n          }\n        } else {\n          // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n          // field and so we are using modifiedCount instead\n          meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n        }\n      }\n      return meteorResult;\n    };\n    const replaceMeteorAtomWithMongo = function (document) {\n      if (EJSON.isBinary(document)) {\n        // This does more copies than we'd like, but is necessary because\n        // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n        // serialize it correctly).\n        return new MongoDB.Binary(Buffer.from(document));\n      }\n      if (document instanceof MongoDB.Binary) {\n        return document;\n      }\n      if (document instanceof Mongo.ObjectID) {\n        return new MongoDB.ObjectId(document.toHexString());\n      }\n      if (document instanceof MongoDB.ObjectId) {\n        return new MongoDB.ObjectId(document.toHexString());\n      }\n      if (document instanceof MongoDB.Timestamp) {\n        // For now, the Meteor representation of a Mongo timestamp type (not a date!\n        // this is a weird internal thing used in the oplog!) is the same as the\n        // Mongo representation. We need to do this explicitly or else we would do a\n        // structural clone and lose the prototype.\n        return document;\n      }\n      if (document instanceof Decimal) {\n        return MongoDB.Decimal128.fromString(document.toString());\n      }\n      if (EJSON._isCustomType(document)) {\n        return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n      }\n      // It is not ordinarily possible to stick dollar-sign keys into mongo\n      // so we don't bother checking for things that need escaping at this time.\n      return undefined;\n    };\n    const replaceTypes = function (document, atomTransformer) {\n      if (typeof document !== 'object' || document === null) return document;\n      var replacedTopLevelAtom = atomTransformer(document);\n      if (replacedTopLevelAtom !== undefined) return replacedTopLevelAtom;\n      var ret = document;\n      Object.entries(document).forEach(function (_ref) {\n        let [key, val] = _ref;\n        var valReplaced = replaceTypes(val, atomTransformer);\n        if (val !== valReplaced) {\n          // Lazy clone. Shallow copy.\n          if (ret === document) ret = clone(document);\n          ret[key] = valReplaced;\n        }\n      });\n      return ret;\n    };\n    const replaceMongoAtomWithMeteor = function (document) {\n      if (document instanceof MongoDB.Binary) {\n        // for backwards compatibility\n        if (document.sub_type !== 0) {\n          return document;\n        }\n        var buffer = document.value(true);\n        return new Uint8Array(buffer);\n      }\n      if (document instanceof MongoDB.ObjectId) {\n        return new Mongo.ObjectID(document.toHexString());\n      }\n      if (document instanceof MongoDB.Decimal128) {\n        return Decimal(document.toString());\n      }\n      if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && Object.keys(document).length === 2) {\n        return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n      }\n      if (document instanceof MongoDB.Timestamp) {\n        // For now, the Meteor representation of a Mongo timestamp type (not a date!\n        // this is a weird internal thing used in the oplog!) is the same as the\n        // Mongo representation. We need to do this explicitly or else we would do a\n        // structural clone and lose the prototype.\n        return document;\n      }\n      return undefined;\n    };\n    const makeMongoLegal = name => \"EJSON\" + name;\n    const unmakeMongoLegal = name => name.substr(5);\n    function replaceNames(filter, thing) {\n      if (typeof thing === \"object\" && thing !== null) {\n        if (Array.isArray(thing)) {\n          return thing.map(replaceNames.bind(null, filter));\n        }\n        var ret = {};\n        Object.entries(thing).forEach(function (_ref2) {\n          let [key, value] = _ref2;\n          ret[filter(key)] = replaceNames(filter, value);\n        });\n        return ret;\n      }\n      return thing;\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","MongoDB","writeCallback","transformResult","replaceMeteorAtomWithMongo","replaceTypes","replaceMongoAtomWithMeteor","replaceNames","clone","link","default","v","__reifyWaitForDeps__","Object","assign","NpmModuleMongodb","ObjectID","ObjectId","write","refresh","callback","err","result","refreshErr","committed","driverResult","meteorResult","numberAffected","mongoResult","upsertedCount","upsertedId","insertedId","n","matchedCount","modifiedCount","document","EJSON","isBinary","Binary","Buffer","from","Mongo","toHexString","Timestamp","Decimal","Decimal128","fromString","toString","_isCustomType","makeMongoLegal","toJSONValue","undefined","atomTransformer","replacedTopLevelAtom","ret","entries","forEach","_ref","key","val","valReplaced","sub_type","buffer","value","Uint8Array","keys","length","fromJSONValue","unmakeMongoLegal","name","substr","filter","thing","Array","isArray","map","bind","_ref2","__reify_async_result__","_reifyError","self","async"],"sources":["packages/mongo/mongo_common.js"],"sourcesContent":["import clone from 'lodash.clone'\n\n/** @type {import('mongodb')} */\nexport const MongoDB = Object.assign(NpmModuleMongodb, {\n  ObjectID: NpmModuleMongodb.ObjectId,\n});\n\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\nexport const writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (! err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n    write.committed();\n    if (callback) {\n      callback(err, result);\n    } else if (err) {\n      throw err;\n    }\n  };\n};\n\n\nexport const transformResult = function (driverResult) {\n  var meteorResult = { numberAffected: 0 };\n  if (driverResult) {\n    var mongoResult = driverResult.result;\n    // On updates with upsert:true, the inserted values come as a list of\n    // upserted values -- even with options.multi, when the upsert does insert,\n    // it only inserts one element.\n    if (mongoResult.upsertedCount) {\n      meteorResult.numberAffected = mongoResult.upsertedCount;\n\n      if (mongoResult.upsertedId) {\n        meteorResult.insertedId = mongoResult.upsertedId;\n      }\n    } else {\n      // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n      // field and so we are using modifiedCount instead\n      meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n    }\n  }\n\n  return meteorResult;\n};\n\nexport const replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(Buffer.from(document));\n  }\n  if (document instanceof MongoDB.Binary) {\n    return document;\n  }\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectId(document.toHexString());\n  }\n  if (document instanceof MongoDB.ObjectId) {\n    return new MongoDB.ObjectId(document.toHexString());\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  if (document instanceof Decimal) {\n    return MongoDB.Decimal128.fromString(document.toString());\n  }\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  }\n  // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n  return undefined;\n};\n\nexport const replaceTypes = function (document, atomTransformer) {\n  if (typeof document !== 'object' || document === null)\n    return document;\n\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined)\n    return replacedTopLevelAtom;\n\n  var ret = document;\n  Object.entries(document).forEach(function ([key, val]) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document)\n        ret = clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n  return ret;\n};\n\nexport const replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    // for backwards compatibility\n    if (document.sub_type !== 0) {\n      return document;\n    }\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n  if (document instanceof MongoDB.ObjectId) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Decimal128) {\n    return Decimal(document.toString());\n  }\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && Object.keys(document).length === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  return undefined;\n};\n\nconst makeMongoLegal = name => \"EJSON\" + name;\nconst unmakeMongoLegal = name => name.substr(5);\n\nexport function replaceNames(filter, thing) {\n  if (typeof thing === \"object\" && thing !== null) {\n    if (Array.isArray(thing)) {\n      return thing.map(replaceNames.bind(null, filter));\n    }\n    var ret = {};\n    Object.entries(thing).forEach(function ([key, value]) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n    return ret;\n  }\n  return thing;\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"3605a270b2b4715e3652b3a5dd511864789f9220"}

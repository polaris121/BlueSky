{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/ddp-client/common/message_processors.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-client/common/message_processors.js"}},"code":"var _regeneratorRuntime;\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 0);\nvar _slicedToArray;\nmodule.link(\"@babel/runtime/helpers/slicedToArray\", {\n  default: function (v) {\n    _slicedToArray = v;\n  }\n}, 1);\nmodule.export({\n  MessageProcessors: function () {\n    return MessageProcessors;\n  }\n});\nvar DDPCommon;\nmodule.link(\"meteor/ddp-common\", {\n  DDPCommon: function (v) {\n    DDPCommon = v;\n  }\n}, 0);\nvar Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 1);\nvar DDP;\nmodule.link(\"./namespace.js\", {\n  DDP: function (v) {\n    DDP = v;\n  }\n}, 2);\nvar EJSON;\nmodule.link(\"meteor/ejson\", {\n  EJSON: function (v) {\n    EJSON = v;\n  }\n}, 3);\nvar isEmpty, hasOwn;\nmodule.link(\"meteor/ddp-common/utils\", {\n  isEmpty: function (v) {\n    isEmpty = v;\n  },\n  hasOwn: function (v) {\n    hasOwn = v;\n  }\n}, 4);\nvar MessageProcessors = /*#__PURE__*/function () {\n  function MessageProcessors(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process the connection message and set up the session\n   * @param {Object} msg The connection message\n   */\n  var _proto = MessageProcessors.prototype;\n  _proto._livedata_connected = function () {\n    function _livedata_connected(msg) {\n      var self, reconnectedToPreviousSession, invokers, _i, _Object$values, store;\n      return _regeneratorRuntime.async(function (_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            self = this._connection;\n            if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n              self._heartbeat = new DDPCommon.Heartbeat({\n                heartbeatInterval: self._heartbeatInterval,\n                heartbeatTimeout: self._heartbeatTimeout,\n                onTimeout: function () {\n                  self._lostConnection(new DDP.ConnectionError('DDP heartbeat timed out'));\n                },\n                sendPing: function () {\n                  self._send({\n                    msg: 'ping'\n                  });\n                }\n              });\n              self._heartbeat.start();\n            }\n\n            // If this is a reconnect, we'll have to reset all stores.\n            if (self._lastSessionId) self._resetStores = true;\n            if (typeof msg.session === 'string') {\n              reconnectedToPreviousSession = self._lastSessionId === msg.session;\n              self._lastSessionId = msg.session;\n            }\n            if (!reconnectedToPreviousSession) {\n              _context.next = 1;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 1:\n            // Server doesn't have our data anymore. Re-sync a new session.\n\n            // Forget about messages we were buffering for unknown collections. They'll\n            // be resent if still relevant.\n            self._updatesForUnknownStores = Object.create(null);\n            if (self._resetStores) {\n              // Forget about the effects of stubs. We'll be resetting all collections\n              // anyway.\n              self._documentsWrittenByStub = Object.create(null);\n              self._serverDocuments = Object.create(null);\n            }\n\n            // Clear _afterUpdateCallbacks.\n            self._afterUpdateCallbacks = [];\n\n            // Mark all named subscriptions which are ready as needing to be revived.\n            self._subsBeingRevived = Object.create(null);\n            Object.entries(self._subscriptions).forEach(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                id = _ref2[0],\n                sub = _ref2[1];\n              if (sub.ready) {\n                self._subsBeingRevived[id] = true;\n              }\n            });\n\n            // Arrange for \"half-finished\" methods to have their callbacks run, and\n            // track methods that were sent on this connection so that we don't\n            // quiesce until they are all done.\n            //\n            // Start by clearing _methodsBlockingQuiescence: methods sent before\n            // reconnect don't matter, and any \"wait\" methods sent on the new connection\n            // that we drop here will be restored by the loop below.\n            self._methodsBlockingQuiescence = Object.create(null);\n            if (self._resetStores) {\n              invokers = self._methodInvokers;\n              Object.keys(invokers).forEach(function (id) {\n                var invoker = invokers[id];\n                if (invoker.gotResult()) {\n                  // This method already got its result, but it didn't call its callback\n                  // because its data didn't become visible. We did not resend the\n                  // method RPC. We'll call its callback when we get a full quiesce,\n                  // since that's as close as we'll get to \"data must be visible\".\n                  self._afterUpdateCallbacks.push(function () {\n                    return invoker.dataVisible.apply(invoker, arguments);\n                  });\n                } else if (invoker.sentMessage) {\n                  // This method has been sent on this connection (maybe as a resend\n                  // from the last connection, maybe from onReconnect, maybe just very\n                  // quickly before processing the connected message).\n                  //\n                  // We don't need to do anything special to ensure its callbacks get\n                  // called, but we'll count it as a method which is preventing\n                  // reconnect quiescence. (eg, it might be a login method that was run\n                  // from onReconnect, and we don't want to see flicker by seeing a\n                  // logged-out state.)\n                  self._methodsBlockingQuiescence[invoker.methodId] = true;\n                }\n              });\n            }\n            self._messagesBufferedUntilQuiescence = [];\n\n            // If we're not waiting on any methods or subs, we can reset the stores and\n            // call the callbacks immediately.\n            if (self._waitingForQuiescence()) {\n              _context.next = 7;\n              break;\n            }\n            if (!self._resetStores) {\n              _context.next = 6;\n              break;\n            }\n            _i = 0, _Object$values = Object.values(self._stores);\n          case 2:\n            if (!(_i < _Object$values.length)) {\n              _context.next = 5;\n              break;\n            }\n            store = _Object$values[_i];\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(store.beginUpdate(0, true));\n          case 3:\n            _context.next = 4;\n            return _regeneratorRuntime.awrap(store.endUpdate());\n          case 4:\n            _i++;\n            _context.next = 2;\n            break;\n          case 5:\n            self._resetStores = false;\n          case 6:\n            self._runAfterUpdateCallbacks();\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }, null, this, null, Promise);\n    }\n    return _livedata_connected;\n  }()\n  /**\n   * @summary Process various data messages from the server\n   * @param {Object} msg The data message\n   */\n  ;\n  _proto._livedata_data = function () {\n    function _livedata_data(msg) {\n      var self, bufferedMessages, _i2, _Object$values2, bufferedMessage, standardWrite;\n      return _regeneratorRuntime.async(function (_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            self = this._connection;\n            if (!self._waitingForQuiescence()) {\n              _context2.next = 5;\n              break;\n            }\n            self._messagesBufferedUntilQuiescence.push(msg);\n            if (msg.msg === 'nosub') {\n              delete self._subsBeingRevived[msg.id];\n            }\n            if (msg.subs) {\n              msg.subs.forEach(function (subId) {\n                delete self._subsBeingRevived[subId];\n              });\n            }\n            if (msg.methods) {\n              msg.methods.forEach(function (methodId) {\n                delete self._methodsBlockingQuiescence[methodId];\n              });\n            }\n            if (!self._waitingForQuiescence()) {\n              _context2.next = 1;\n              break;\n            }\n            return _context2.abrupt(\"return\");\n          case 1:\n            // No methods or subs are blocking quiescence!\n            // We'll now process and all of our buffered messages, reset all stores,\n            // and apply them all at once.\n            bufferedMessages = self._messagesBufferedUntilQuiescence;\n            _i2 = 0, _Object$values2 = Object.values(bufferedMessages);\n          case 2:\n            if (!(_i2 < _Object$values2.length)) {\n              _context2.next = 4;\n              break;\n            }\n            bufferedMessage = _Object$values2[_i2];\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(this._processOneDataMessage(bufferedMessage, self._bufferedWrites));\n          case 3:\n            _i2++;\n            _context2.next = 2;\n            break;\n          case 4:\n            self._messagesBufferedUntilQuiescence = [];\n            _context2.next = 6;\n            break;\n          case 5:\n            _context2.next = 6;\n            return _regeneratorRuntime.awrap(this._processOneDataMessage(msg, self._bufferedWrites));\n          case 6:\n            // Immediately flush writes when:\n            //  1. Buffering is disabled. Or;\n            //  2. any non-(added/changed/removed) message arrives.\n            standardWrite = msg.msg === \"added\" || msg.msg === \"changed\" || msg.msg === \"removed\";\n            if (!(self._bufferedWritesInterval === 0 || !standardWrite)) {\n              _context2.next = 8;\n              break;\n            }\n            _context2.next = 7;\n            return _regeneratorRuntime.awrap(self._flushBufferedWrites());\n          case 7:\n            return _context2.abrupt(\"return\");\n          case 8:\n            if (!(self._bufferedWritesFlushAt === null)) {\n              _context2.next = 9;\n              break;\n            }\n            self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n            _context2.next = 11;\n            break;\n          case 9:\n            if (!(self._bufferedWritesFlushAt < new Date().valueOf())) {\n              _context2.next = 11;\n              break;\n            }\n            _context2.next = 10;\n            return _regeneratorRuntime.awrap(self._flushBufferedWrites());\n          case 10:\n            return _context2.abrupt(\"return\");\n          case 11:\n            if (self._bufferedWritesFlushHandle) {\n              clearTimeout(self._bufferedWritesFlushHandle);\n            }\n            self._bufferedWritesFlushHandle = setTimeout(function () {\n              self._liveDataWritesPromise = self._flushBufferedWrites();\n              if (Meteor._isPromise(self._liveDataWritesPromise)) {\n                self._liveDataWritesPromise.finally(function () {\n                  return self._liveDataWritesPromise = undefined;\n                });\n              }\n            }, self._bufferedWritesInterval);\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, null, this, null, Promise);\n    }\n    return _livedata_data;\n  }()\n  /**\n   * @summary Process individual data messages by type\n   * @private\n   */\n  ;\n  _proto._processOneDataMessage = function () {\n    function _processOneDataMessage(msg, updates) {\n      var messageType, _t;\n      return _regeneratorRuntime.async(function (_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            messageType = msg.msg;\n            _t = messageType;\n            _context3.next = _t === 'added' ? 1 : _t === 'changed' ? 3 : _t === 'removed' ? 4 : _t === 'ready' ? 5 : _t === 'updated' ? 6 : _t === 'nosub' ? 7 : 8;\n            break;\n          case 1:\n            _context3.next = 2;\n            return _regeneratorRuntime.awrap(this._connection._process_added(msg, updates));\n          case 2:\n            return _context3.abrupt(\"continue\", 9);\n          case 3:\n            this._connection._process_changed(msg, updates);\n            return _context3.abrupt(\"continue\", 9);\n          case 4:\n            this._connection._process_removed(msg, updates);\n            return _context3.abrupt(\"continue\", 9);\n          case 5:\n            this._connection._process_ready(msg, updates);\n            return _context3.abrupt(\"continue\", 9);\n          case 6:\n            this._connection._process_updated(msg, updates);\n            return _context3.abrupt(\"continue\", 9);\n          case 7:\n            return _context3.abrupt(\"continue\", 9);\n          case 8:\n            Meteor._debug('discarding unknown livedata data message type', msg);\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, null, this, null, Promise);\n    }\n    return _processOneDataMessage;\n  }()\n  /**\n   * @summary Handle method results arriving from the server\n   * @param {Object} msg The method result message\n   */\n  ;\n  _proto._livedata_result = function () {\n    function _livedata_result(msg) {\n      var self, currentMethodBlock, i, m;\n      return _regeneratorRuntime.async(function (_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            self = this._connection; // Lets make sure there are no buffered writes before returning result.\n            if (isEmpty(self._bufferedWrites)) {\n              _context4.next = 1;\n              break;\n            }\n            _context4.next = 1;\n            return _regeneratorRuntime.awrap(self._flushBufferedWrites());\n          case 1:\n            if (!isEmpty(self._outstandingMethodBlocks)) {\n              _context4.next = 2;\n              break;\n            }\n            Meteor._debug('Received method result but no methods outstanding');\n            return _context4.abrupt(\"return\");\n          case 2:\n            currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n            m = currentMethodBlock.find(function (method, idx) {\n              var found = method.methodId === msg.id;\n              if (found) i = idx;\n              return found;\n            });\n            if (m) {\n              _context4.next = 3;\n              break;\n            }\n            Meteor._debug(\"Can't match method response to original method call\", msg);\n            return _context4.abrupt(\"return\");\n          case 3:\n            // Remove from current method block. This may leave the block empty, but we\n            // don't move on to the next block until the callback has been delivered, in\n            // _outstandingMethodFinished.\n            currentMethodBlock.splice(i, 1);\n            if (hasOwn.call(msg, 'error')) {\n              m.receiveResult(new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details));\n            } else {\n              // msg.result may be undefined if the method didn't return a value\n              m.receiveResult(undefined, msg.result);\n            }\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, null, this, null, Promise);\n    }\n    return _livedata_result;\n  }()\n  /**\n   * @summary Handle \"nosub\" messages arriving from the server\n   * @param {Object} msg The nosub message\n   */\n  ;\n  _proto._livedata_nosub = function () {\n    function _livedata_nosub(msg) {\n      var self, errorCallback, stopCallback, meteorErrorFromMsg;\n      return _regeneratorRuntime.async(function (_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            self = this._connection; // First pass it through _livedata_data, which only uses it to help get\n            // towards quiescence.\n            _context5.next = 1;\n            return _regeneratorRuntime.awrap(this._livedata_data(msg));\n          case 1:\n            if (hasOwn.call(self._subscriptions, msg.id)) {\n              _context5.next = 2;\n              break;\n            }\n            return _context5.abrupt(\"return\");\n          case 2:\n            // XXX COMPAT WITH 1.0.3.1 #errorCallback\n            errorCallback = self._subscriptions[msg.id].errorCallback;\n            stopCallback = self._subscriptions[msg.id].stopCallback;\n            self._subscriptions[msg.id].remove();\n            meteorErrorFromMsg = function (msgArg) {\n              return msgArg && msgArg.error && new Meteor.Error(msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n            }; // XXX COMPAT WITH 1.0.3.1 #errorCallback\n            if (errorCallback && msg.error) {\n              errorCallback(meteorErrorFromMsg(msg));\n            }\n            if (stopCallback) {\n              stopCallback(meteorErrorFromMsg(msg));\n            }\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, null, this, null, Promise);\n    }\n    return _livedata_nosub;\n  }()\n  /**\n   * @summary Handle errors from the server\n   * @param {Object} msg The error message\n   */\n  ;\n  _proto._livedata_error = function () {\n    function _livedata_error(msg) {\n      Meteor._debug('Received error from server: ', msg.reason);\n      if (msg.offendingMessage) Meteor._debug('For: ', msg.offendingMessage);\n    }\n    return _livedata_error;\n  }() // Document change message processors will be defined in a separate class\n  ;\n  return MessageProcessors;\n}();","map":{"version":3,"names":["_regeneratorRuntime","module","link","default","v","_slicedToArray","export","MessageProcessors","DDPCommon","Meteor","DDP","EJSON","isEmpty","hasOwn","connection","_connection","_proto","prototype","_livedata_connected","msg","self","reconnectedToPreviousSession","invokers","_i","_Object$values","store","async","_context","prev","next","_version","_heartbeatInterval","_heartbeat","Heartbeat","heartbeatInterval","heartbeatTimeout","_heartbeatTimeout","onTimeout","_lostConnection","ConnectionError","sendPing","_send","start","_lastSessionId","_resetStores","session","abrupt","_updatesForUnknownStores","Object","create","_documentsWrittenByStub","_serverDocuments","_afterUpdateCallbacks","_subsBeingRevived","entries","_subscriptions","forEach","_ref","_ref2","id","sub","ready","_methodsBlockingQuiescence","_methodInvokers","keys","invoker","gotResult","push","dataVisible","apply","arguments","sentMessage","methodId","_messagesBufferedUntilQuiescence","_waitingForQuiescence","values","_stores","length","awrap","beginUpdate","endUpdate","_runAfterUpdateCallbacks","stop","Promise","_livedata_data","bufferedMessages","_i2","_Object$values2","bufferedMessage","standardWrite","_context2","subs","subId","methods","_processOneDataMessage","_bufferedWrites","_bufferedWritesInterval","_flushBufferedWrites","_bufferedWritesFlushAt","Date","valueOf","_bufferedWritesMaxAge","_bufferedWritesFlushHandle","clearTimeout","setTimeout","_liveDataWritesPromise","_isPromise","finally","undefined","updates","messageType","_t","_context3","_process_added","_process_changed","_process_removed","_process_ready","_process_updated","_debug","_livedata_result","currentMethodBlock","i","m","_context4","_outstandingMethodBlocks","find","method","idx","found","splice","call","receiveResult","Error","error","reason","details","result","_livedata_nosub","errorCallback","stopCallback","meteorErrorFromMsg","_context5","remove","msgArg","_livedata_error","offendingMessage"],"sources":["packages/ddp-client/common/message_processors.js"],"sourcesContent":["import { DDPCommon } from 'meteor/ddp-common';\nimport { Meteor } from 'meteor/meteor';\nimport { DDP } from './namespace.js';\nimport { EJSON } from 'meteor/ejson';\nimport { isEmpty, hasOwn } from \"meteor/ddp-common/utils\";\n\nexport class MessageProcessors {\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process the connection message and set up the session\n   * @param {Object} msg The connection message\n   */\n  async _livedata_connected(msg) {\n    const self = this._connection;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout() {\n          self._lostConnection(\n            new DDP.ConnectionError('DDP heartbeat timed out')\n          );\n        },\n        sendPing() {\n          self._send({ msg: 'ping' });\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId) self._resetStores = true;\n\n    let reconnectedToPreviousSession;\n    if (typeof msg.session === 'string') {\n      reconnectedToPreviousSession = self._lastSessionId === msg.session;\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.\n      return;\n    }\n\n    // Server doesn't have our data anymore. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = Object.create(null);\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = Object.create(null);\n      self._serverDocuments = Object.create(null);\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready as needing to be revived.\n    self._subsBeingRevived = Object.create(null);\n    Object.entries(self._subscriptions).forEach(([id, sub]) => {\n      if (sub.ready) {\n        self._subsBeingRevived[id] = true;\n      }\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = Object.create(null);\n    if (self._resetStores) {\n      const invokers = self._methodInvokers;\n      Object.keys(invokers).forEach(id => {\n        const invoker = invokers[id];\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(\n            (...args) => invoker.dataVisible(...args)\n          );\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        for (const store of Object.values(self._stores)) {\n          await store.beginUpdate(0, true);\n          await store.endUpdate();\n        }\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  }\n\n  /**\n   * @summary Process various data messages from the server\n   * @param {Object} msg The data message\n   */\n  async _livedata_data(msg) {\n    const self = this._connection;\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === 'nosub') {\n        delete self._subsBeingRevived[msg.id];\n      }\n\n      if (msg.subs) {\n        msg.subs.forEach(subId => {\n          delete self._subsBeingRevived[subId];\n        });\n      }\n\n      if (msg.methods) {\n        msg.methods.forEach(methodId => {\n          delete self._methodsBlockingQuiescence[methodId];\n        });\n      }\n\n      if (self._waitingForQuiescence()) {\n        return;\n      }\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      const bufferedMessages = self._messagesBufferedUntilQuiescence;\n      for (const bufferedMessage of Object.values(bufferedMessages)) {\n        await this._processOneDataMessage(\n          bufferedMessage,\n          self._bufferedWrites\n        );\n      }\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      await this._processOneDataMessage(msg, self._bufferedWrites);\n    }\n\n    // Immediately flush writes when:\n    //  1. Buffering is disabled. Or;\n    //  2. any non-(added/changed/removed) message arrives.\n    const standardWrite =\n      msg.msg === \"added\" ||\n      msg.msg === \"changed\" ||\n      msg.msg === \"removed\";\n\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n      await self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushAt === null) {\n      self._bufferedWritesFlushAt =\n        new Date().valueOf() + self._bufferedWritesMaxAge;\n    } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n      await self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n    }\n    self._bufferedWritesFlushHandle = setTimeout(() => {\n      self._liveDataWritesPromise = self._flushBufferedWrites();\n      if (Meteor._isPromise(self._liveDataWritesPromise)) {\n        self._liveDataWritesPromise.finally(\n          () => (self._liveDataWritesPromise = undefined)\n        );\n      }\n    }, self._bufferedWritesInterval);\n  }\n\n  /**\n   * @summary Process individual data messages by type\n   * @private\n   */\n  async _processOneDataMessage(msg, updates) {\n    const messageType = msg.msg;\n\n    switch (messageType) {\n      case 'added':\n        await this._connection._process_added(msg, updates);\n        break;\n      case 'changed':\n        this._connection._process_changed(msg, updates);\n        break;\n      case 'removed':\n        this._connection._process_removed(msg, updates);\n        break;\n      case 'ready':\n        this._connection._process_ready(msg, updates);\n        break;\n      case 'updated':\n        this._connection._process_updated(msg, updates);\n        break;\n      case 'nosub':\n        // ignore this\n        break;\n      default:\n        Meteor._debug('discarding unknown livedata data message type', msg);\n    }\n  }\n\n  /**\n   * @summary Handle method results arriving from the server\n   * @param {Object} msg The method result message\n   */\n  async _livedata_result(msg) {\n    const self = this._connection;\n\n    // Lets make sure there are no buffered writes before returning result.\n    if (!isEmpty(self._bufferedWrites)) {\n      await self._flushBufferedWrites();\n    }\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug('Received method result but no methods outstanding');\n      return;\n    }\n    const currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    let i;\n    const m = currentMethodBlock.find((method, idx) => {\n      const found = method.methodId === msg.id;\n      if (found) i = idx;\n      return found;\n    });\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n\n    if (hasOwn.call(msg, 'error')) {\n      m.receiveResult(\n        new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details)\n      );\n    } else {\n      // msg.result may be undefined if the method didn't return a value\n      m.receiveResult(undefined, msg.result);\n    }\n  }\n\n  /**\n   * @summary Handle \"nosub\" messages arriving from the server\n   * @param {Object} msg The nosub message\n   */\n  async _livedata_nosub(msg) {\n    const self = this._connection;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    await this._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!hasOwn.call(self._subscriptions, msg.id)) {\n      return;\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    const errorCallback = self._subscriptions[msg.id].errorCallback;\n    const stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    const meteorErrorFromMsg = msgArg => {\n      return (\n        msgArg &&\n        msgArg.error &&\n        new Meteor.Error(\n          msgArg.error.error,\n          msgArg.error.reason,\n          msgArg.error.details\n        )\n      );\n    };\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  }\n\n  /**\n   * @summary Handle errors from the server\n   * @param {Object} msg The error message\n   */\n  _livedata_error(msg) {\n    Meteor._debug('Received error from server: ', msg.reason);\n    if (msg.offendingMessage) Meteor._debug('For: ', msg.offendingMessage);\n  }\n\n  // Document change message processors will be defined in a separate class\n}"],"mappings":"AAAA,IAAIA,mBAAmB;AAACC,MAAM,CAACC,IAAI,CAAC,4BAA4B,EAAC;EAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;IAACJ,mBAAmB,GAACI,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAC,IAAIC,cAAc;AAACJ,MAAM,CAACC,IAAI,CAAC,sCAAsC,EAAC;EAACC,OAAO,EAAC,SAAAA,CAASC,CAAC,EAAC;IAACC,cAAc,GAACD,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAjOH,MAAM,CAACK,MAAM,CAAC;EAACC,iBAAiB,EAAC,SAAAA,CAAA,EAAU;IAAC,OAAOA,iBAAiB;EAAA;AAAC,CAAC,CAAC;AAAC,IAAIC,SAAS;AAACP,MAAM,CAACC,IAAI,CAAC,mBAAmB,EAAC;EAACM,SAAS,EAAC,SAAAA,CAASJ,CAAC,EAAC;IAACI,SAAS,GAACJ,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAC,IAAIK,MAAM;AAACR,MAAM,CAACC,IAAI,CAAC,eAAe,EAAC;EAACO,MAAM,EAAC,SAAAA,CAASL,CAAC,EAAC;IAACK,MAAM,GAACL,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAC,IAAIM,GAAG;AAACT,MAAM,CAACC,IAAI,CAAC,gBAAgB,EAAC;EAACQ,GAAG,EAAC,SAAAA,CAASN,CAAC,EAAC;IAACM,GAAG,GAACN,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAC,IAAIO,KAAK;AAACV,MAAM,CAACC,IAAI,CAAC,cAAc,EAAC;EAACS,KAAK,EAAC,SAAAA,CAASP,CAAC,EAAC;IAACO,KAAK,GAACP,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAC,IAAIQ,OAAO,EAACC,MAAM;AAACZ,MAAM,CAACC,IAAI,CAAC,yBAAyB,EAAC;EAACU,OAAO,EAAC,SAAAA,CAASR,CAAC,EAAC;IAACQ,OAAO,GAACR,CAAC;EAAA,CAAC;EAACS,MAAM,EAAC,SAAAA,CAAST,CAAC,EAAC;IAACS,MAAM,GAACT,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAC,IAM1dG,iBAAiB;EAC5B,SAAAA,kBAAYO,UAAU,EAAE;IACtB,IAAI,CAACC,WAAW,GAAGD,UAAU;EAC/B;;EAEA;AACF;AACA;AACA;EAHE,IAAAE,MAAA,GAAAT,iBAAA,CAAAU,SAAA;EAAAD,MAAA,CAIME,mBAAmB;IAAzB,SAAMA,mBAAmBA,CAACC,GAAG;MAAA,IAAAC,IAAA,EAAAC,4BAAA,EAAAC,QAAA,EAAAC,EAAA,EAAAC,cAAA,EAAAC,KAAA;MAAA,OAAAzB,mBAAA,CAAA0B,KAAA,WAAAC,QAAA;QAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;UAAA;YACrBT,IAAI,GAAG,IAAI,CAACL,WAAW;YAE7B,IAAIK,IAAI,CAACU,QAAQ,KAAK,MAAM,IAAIV,IAAI,CAACW,kBAAkB,KAAK,CAAC,EAAE;cAC7DX,IAAI,CAACY,UAAU,GAAG,IAAIxB,SAAS,CAACyB,SAAS,CAAC;gBACxCC,iBAAiB,EAAEd,IAAI,CAACW,kBAAkB;gBAC1CI,gBAAgB,EAAEf,IAAI,CAACgB,iBAAiB;gBACxCC,SAAS,WAAAA,CAAA,EAAG;kBACVjB,IAAI,CAACkB,eAAe,CAClB,IAAI5B,GAAG,CAAC6B,eAAe,CAAC,yBAAyB,CACnD,CAAC;gBACH,CAAC;gBACDC,QAAQ,WAAAA,CAAA,EAAG;kBACTpB,IAAI,CAACqB,KAAK,CAAC;oBAAEtB,GAAG,EAAE;kBAAO,CAAC,CAAC;gBAC7B;cACF,CAAC,CAAC;cACFC,IAAI,CAACY,UAAU,CAACU,KAAK,CAAC,CAAC;YACzB;;YAEA;YACA,IAAItB,IAAI,CAACuB,cAAc,EAAEvB,IAAI,CAACwB,YAAY,GAAG,IAAI;YAGjD,IAAI,OAAOzB,GAAG,CAAC0B,OAAO,KAAK,QAAQ,EAAE;cACnCxB,4BAA4B,GAAGD,IAAI,CAACuB,cAAc,KAAKxB,GAAG,CAAC0B,OAAO;cAClEzB,IAAI,CAACuB,cAAc,GAAGxB,GAAG,CAAC0B,OAAO;YACnC;YAAC,KAEGxB,4BAA4B;cAAAM,QAAA,CAAAE,IAAA;cAAA;YAAA;YAAA,OAAAF,QAAA,CAAAmB,MAAA;UAAA;YAKhC;;YAEA;YACA;YACA1B,IAAI,CAAC2B,wBAAwB,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;YAEnD,IAAI7B,IAAI,CAACwB,YAAY,EAAE;cACrB;cACA;cACAxB,IAAI,CAAC8B,uBAAuB,GAAGF,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;cAClD7B,IAAI,CAAC+B,gBAAgB,GAAGH,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;YAC7C;;YAEA;YACA7B,IAAI,CAACgC,qBAAqB,GAAG,EAAE;;YAE/B;YACAhC,IAAI,CAACiC,iBAAiB,GAAGL,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;YAC5CD,MAAM,CAACM,OAAO,CAAClC,IAAI,CAACmC,cAAc,CAAC,CAACC,OAAO,CAAC,UAAAC,IAAA,EAAe;cAAA,IAAAC,KAAA,GAAArD,cAAA,CAAAoD,IAAA;gBAAbE,EAAE,GAAAD,KAAA;gBAAEE,GAAG,GAAAF,KAAA;cACnD,IAAIE,GAAG,CAACC,KAAK,EAAE;gBACbzC,IAAI,CAACiC,iBAAiB,CAACM,EAAE,CAAC,GAAG,IAAI;cACnC;YACF,CAAC,CAAC;;YAEF;YACA;YACA;YACA;YACA;YACA;YACA;YACAvC,IAAI,CAAC0C,0BAA0B,GAAGd,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;YACrD,IAAI7B,IAAI,CAACwB,YAAY,EAAE;cACftB,QAAQ,GAAGF,IAAI,CAAC2C,eAAe;cACrCf,MAAM,CAACgB,IAAI,CAAC1C,QAAQ,CAAC,CAACkC,OAAO,CAAC,UAAAG,EAAE,EAAI;gBAClC,IAAMM,OAAO,GAAG3C,QAAQ,CAACqC,EAAE,CAAC;gBAC5B,IAAIM,OAAO,CAACC,SAAS,CAAC,CAAC,EAAE;kBACvB;kBACA;kBACA;kBACA;kBACA9C,IAAI,CAACgC,qBAAqB,CAACe,IAAI,CAC7B;oBAAA,OAAaF,OAAO,CAACG,WAAW,CAAAC,KAAA,CAAnBJ,OAAO,EAAAK,SAAoB,CAAC;kBAAA,CAC3C,CAAC;gBACH,CAAC,MAAM,IAAIL,OAAO,CAACM,WAAW,EAAE;kBAC9B;kBACA;kBACA;kBACA;kBACA;kBACA;kBACA;kBACA;kBACA;kBACAnD,IAAI,CAAC0C,0BAA0B,CAACG,OAAO,CAACO,QAAQ,CAAC,GAAG,IAAI;gBAC1D;cACF,CAAC,CAAC;YACJ;YAEApD,IAAI,CAACqD,gCAAgC,GAAG,EAAE;;YAE1C;YACA;YAAA,IACKrD,IAAI,CAACsD,qBAAqB,CAAC,CAAC;cAAA/C,QAAA,CAAAE,IAAA;cAAA;YAAA;YAAA,KAC3BT,IAAI,CAACwB,YAAY;cAAAjB,QAAA,CAAAE,IAAA;cAAA;YAAA;YAAAN,EAAA,MAAAC,cAAA,GACCwB,MAAM,CAAC2B,MAAM,CAACvD,IAAI,CAACwD,OAAO,CAAC;UAAA;YAAA,MAAArD,EAAA,GAAAC,cAAA,CAAAqD,MAAA;cAAAlD,QAAA,CAAAE,IAAA;cAAA;YAAA;YAApCJ,KAAK,GAAAD,cAAA,CAAAD,EAAA;YAAAI,QAAA,CAAAE,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CACRrD,KAAK,CAACsD,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC;UAAA;YAAApD,QAAA,CAAAE,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CAC1BrD,KAAK,CAACuD,SAAS,CAAC,CAAC;UAAA;YAAAzD,EAAA;YAAAI,QAAA,CAAAE,IAAA;YAAA;UAAA;YAEzBT,IAAI,CAACwB,YAAY,GAAG,KAAK;UAAC;YAE5BxB,IAAI,CAAC6D,wBAAwB,CAAC,CAAC;UAAC;UAAA;YAAA,OAAAtD,QAAA,CAAAuD,IAAA;QAAA;MAAA,qBAAAC,OAAA;IAAA;IAEnC,OA1GKjE,mBAAmB;EAAA;EA4GzB;AACF;AACA;AACA;EAHE;EAAAF,MAAA,CAIMoE,cAAc;IAApB,SAAMA,cAAcA,CAACjE,GAAG;MAAA,IAAAC,IAAA,EAAAiE,gBAAA,EAAAC,GAAA,EAAAC,eAAA,EAAAC,eAAA,EAAAC,aAAA;MAAA,OAAAzF,mBAAA,CAAA0B,KAAA,WAAAgE,SAAA;QAAA,kBAAAA,SAAA,CAAA9D,IAAA,GAAA8D,SAAA,CAAA7D,IAAA;UAAA;YAChBT,IAAI,GAAG,IAAI,CAACL,WAAW;YAAA,KAEzBK,IAAI,CAACsD,qBAAqB,CAAC,CAAC;cAAAgB,SAAA,CAAA7D,IAAA;cAAA;YAAA;YAC9BT,IAAI,CAACqD,gCAAgC,CAACN,IAAI,CAAChD,GAAG,CAAC;YAE/C,IAAIA,GAAG,CAACA,GAAG,KAAK,OAAO,EAAE;cACvB,OAAOC,IAAI,CAACiC,iBAAiB,CAAClC,GAAG,CAACwC,EAAE,CAAC;YACvC;YAEA,IAAIxC,GAAG,CAACwE,IAAI,EAAE;cACZxE,GAAG,CAACwE,IAAI,CAACnC,OAAO,CAAC,UAAAoC,KAAK,EAAI;gBACxB,OAAOxE,IAAI,CAACiC,iBAAiB,CAACuC,KAAK,CAAC;cACtC,CAAC,CAAC;YACJ;YAEA,IAAIzE,GAAG,CAAC0E,OAAO,EAAE;cACf1E,GAAG,CAAC0E,OAAO,CAACrC,OAAO,CAAC,UAAAgB,QAAQ,EAAI;gBAC9B,OAAOpD,IAAI,CAAC0C,0BAA0B,CAACU,QAAQ,CAAC;cAClD,CAAC,CAAC;YACJ;YAAC,KAEGpD,IAAI,CAACsD,qBAAqB,CAAC,CAAC;cAAAgB,SAAA,CAAA7D,IAAA;cAAA;YAAA;YAAA,OAAA6D,SAAA,CAAA5C,MAAA;UAAA;YAIhC;YACA;YACA;YACMuC,gBAAgB,GAAGjE,IAAI,CAACqD,gCAAgC;YAAAa,GAAA,MAAAC,eAAA,GAChCvC,MAAM,CAAC2B,MAAM,CAACU,gBAAgB,CAAC;UAAA;YAAA,MAAAC,GAAA,GAAAC,eAAA,CAAAV,MAAA;cAAAa,SAAA,CAAA7D,IAAA;cAAA;YAAA;YAAlD2D,eAAe,GAAAD,eAAA,CAAAD,GAAA;YAAAI,SAAA,CAAA7D,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CAClB,IAAI,CAACgB,sBAAsB,CAC/BN,eAAe,EACfpE,IAAI,CAAC2E,eACP,CAAC;UAAA;YAAAT,GAAA;YAAAI,SAAA,CAAA7D,IAAA;YAAA;UAAA;YAEHT,IAAI,CAACqD,gCAAgC,GAAG,EAAE;YAACiB,SAAA,CAAA7D,IAAA;YAAA;UAAA;YAAA6D,SAAA,CAAA7D,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CAErC,IAAI,CAACgB,sBAAsB,CAAC3E,GAAG,EAAEC,IAAI,CAAC2E,eAAe,CAAC;UAAA;YAG9D;YACA;YACA;YACMN,aAAa,GACjBtE,GAAG,CAACA,GAAG,KAAK,OAAO,IACnBA,GAAG,CAACA,GAAG,KAAK,SAAS,IACrBA,GAAG,CAACA,GAAG,KAAK,SAAS;YAAA,MAEnBC,IAAI,CAAC4E,uBAAuB,KAAK,CAAC,IAAI,CAACP,aAAa;cAAAC,SAAA,CAAA7D,IAAA;cAAA;YAAA;YAAA6D,SAAA,CAAA7D,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CAChD1D,IAAI,CAAC6E,oBAAoB,CAAC,CAAC;UAAA;YAAA,OAAAP,SAAA,CAAA5C,MAAA;UAAA;YAAA,MAI/B1B,IAAI,CAAC8E,sBAAsB,KAAK,IAAI;cAAAR,SAAA,CAAA7D,IAAA;cAAA;YAAA;YACtCT,IAAI,CAAC8E,sBAAsB,GACzB,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,GAAGhF,IAAI,CAACiF,qBAAqB;YAACX,SAAA,CAAA7D,IAAA;YAAA;UAAA;YAAA,MAC3CT,IAAI,CAAC8E,sBAAsB,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;cAAAV,SAAA,CAAA7D,IAAA;cAAA;YAAA;YAAA6D,SAAA,CAAA7D,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CACrD1D,IAAI,CAAC6E,oBAAoB,CAAC,CAAC;UAAA;YAAA,OAAAP,SAAA,CAAA5C,MAAA;UAAA;YAInC,IAAI1B,IAAI,CAACkF,0BAA0B,EAAE;cACnCC,YAAY,CAACnF,IAAI,CAACkF,0BAA0B,CAAC;YAC/C;YACAlF,IAAI,CAACkF,0BAA0B,GAAGE,UAAU,CAAC,YAAM;cACjDpF,IAAI,CAACqF,sBAAsB,GAAGrF,IAAI,CAAC6E,oBAAoB,CAAC,CAAC;cACzD,IAAIxF,MAAM,CAACiG,UAAU,CAACtF,IAAI,CAACqF,sBAAsB,CAAC,EAAE;gBAClDrF,IAAI,CAACqF,sBAAsB,CAACE,OAAO,CACjC;kBAAA,OAAOvF,IAAI,CAACqF,sBAAsB,GAAGG,SAAS;gBAAA,CAChD,CAAC;cACH;YACF,CAAC,EAAExF,IAAI,CAAC4E,uBAAuB,CAAC;UAAC;UAAA;YAAA,OAAAN,SAAA,CAAAR,IAAA;QAAA;MAAA,qBAAAC,OAAA;IAAA;IAClC,OAzEKC,cAAc;EAAA;EA2EpB;AACF;AACA;AACA;EAHE;EAAApE,MAAA,CAIM8E,sBAAsB;IAA5B,SAAMA,sBAAsBA,CAAC3E,GAAG,EAAE0F,OAAO;MAAA,IAAAC,WAAA,EAAAC,EAAA;MAAA,OAAA/G,mBAAA,CAAA0B,KAAA,WAAAsF,SAAA;QAAA,kBAAAA,SAAA,CAAApF,IAAA,GAAAoF,SAAA,CAAAnF,IAAA;UAAA;YACjCiF,WAAW,GAAG3F,GAAG,CAACA,GAAG;YAAA4F,EAAA,GAEnBD,WAAW;YAAAE,SAAA,CAAAnF,IAAA,GAAAkF,EAAA,KACZ,OAAO,OAAAA,EAAA,KAGP,SAAS,OAAAA,EAAA,KAGT,SAAS,OAAAA,EAAA,KAGT,OAAO,OAAAA,EAAA,KAGP,SAAS,OAAAA,EAAA,KAGT,OAAO;YAAA;UAAA;YAAAC,SAAA,CAAAnF,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CAdJ,IAAI,CAAC/D,WAAW,CAACkG,cAAc,CAAC9F,GAAG,EAAE0F,OAAO,CAAC;UAAA;YAAA,OAAAG,SAAA,CAAAlE,MAAA;UAAA;YAGnD,IAAI,CAAC/B,WAAW,CAACmG,gBAAgB,CAAC/F,GAAG,EAAE0F,OAAO,CAAC;YAAC,OAAAG,SAAA,CAAAlE,MAAA;UAAA;YAGhD,IAAI,CAAC/B,WAAW,CAACoG,gBAAgB,CAAChG,GAAG,EAAE0F,OAAO,CAAC;YAAC,OAAAG,SAAA,CAAAlE,MAAA;UAAA;YAGhD,IAAI,CAAC/B,WAAW,CAACqG,cAAc,CAACjG,GAAG,EAAE0F,OAAO,CAAC;YAAC,OAAAG,SAAA,CAAAlE,MAAA;UAAA;YAG9C,IAAI,CAAC/B,WAAW,CAACsG,gBAAgB,CAAClG,GAAG,EAAE0F,OAAO,CAAC;YAAC,OAAAG,SAAA,CAAAlE,MAAA;UAAA;YAAA,OAAAkE,SAAA,CAAAlE,MAAA;UAAA;YAMhDrC,MAAM,CAAC6G,MAAM,CAAC,+CAA+C,EAAEnG,GAAG,CAAC;UAAC;UAAA;YAAA,OAAA6F,SAAA,CAAA9B,IAAA;QAAA;MAAA,qBAAAC,OAAA;IAAA;IAEzE,OAzBKW,sBAAsB;EAAA;EA2B5B;AACF;AACA;AACA;EAHE;EAAA9E,MAAA,CAIMuG,gBAAgB;IAAtB,SAAMA,gBAAgBA,CAACpG,GAAG;MAAA,IAAAC,IAAA,EAAAoG,kBAAA,EAAAC,CAAA,EAAAC,CAAA;MAAA,OAAA1H,mBAAA,CAAA0B,KAAA,WAAAiG,SAAA;QAAA,kBAAAA,SAAA,CAAA/F,IAAA,GAAA+F,SAAA,CAAA9F,IAAA;UAAA;YAClBT,IAAI,GAAG,IAAI,CAACL,WAAW,EAE7B;YAAA,IACKH,OAAO,CAACQ,IAAI,CAAC2E,eAAe,CAAC;cAAA4B,SAAA,CAAA9F,IAAA;cAAA;YAAA;YAAA8F,SAAA,CAAA9F,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CAC1B1D,IAAI,CAAC6E,oBAAoB,CAAC,CAAC;UAAA;YAAA,KAK/BrF,OAAO,CAACQ,IAAI,CAACwG,wBAAwB,CAAC;cAAAD,SAAA,CAAA9F,IAAA;cAAA;YAAA;YACxCpB,MAAM,CAAC6G,MAAM,CAAC,mDAAmD,CAAC;YAAC,OAAAK,SAAA,CAAA7E,MAAA;UAAA;YAG/D0E,kBAAkB,GAAGpG,IAAI,CAACwG,wBAAwB,CAAC,CAAC,CAAC,CAAC/B,OAAO;YAE7D6B,CAAC,GAAGF,kBAAkB,CAACK,IAAI,CAAC,UAACC,MAAM,EAAEC,GAAG,EAAK;cACjD,IAAMC,KAAK,GAAGF,MAAM,CAACtD,QAAQ,KAAKrD,GAAG,CAACwC,EAAE;cACxC,IAAIqE,KAAK,EAAEP,CAAC,GAAGM,GAAG;cAClB,OAAOC,KAAK;YACd,CAAC,CAAC;YAAA,IACGN,CAAC;cAAAC,SAAA,CAAA9F,IAAA;cAAA;YAAA;YACJpB,MAAM,CAAC6G,MAAM,CAAC,qDAAqD,EAAEnG,GAAG,CAAC;YAAC,OAAAwG,SAAA,CAAA7E,MAAA;UAAA;YAI5E;YACA;YACA;YACA0E,kBAAkB,CAACS,MAAM,CAACR,CAAC,EAAE,CAAC,CAAC;YAE/B,IAAI5G,MAAM,CAACqH,IAAI,CAAC/G,GAAG,EAAE,OAAO,CAAC,EAAE;cAC7BuG,CAAC,CAACS,aAAa,CACb,IAAI1H,MAAM,CAAC2H,KAAK,CAACjH,GAAG,CAACkH,KAAK,CAACA,KAAK,EAAElH,GAAG,CAACkH,KAAK,CAACC,MAAM,EAAEnH,GAAG,CAACkH,KAAK,CAACE,OAAO,CACvE,CAAC;YACH,CAAC,MAAM;cACL;cACAb,CAAC,CAACS,aAAa,CAACvB,SAAS,EAAEzF,GAAG,CAACqH,MAAM,CAAC;YACxC;UAAC;UAAA;YAAA,OAAAb,SAAA,CAAAzC,IAAA;QAAA;MAAA,qBAAAC,OAAA;IAAA;IACF,OAvCKoC,gBAAgB;EAAA;EAyCtB;AACF;AACA;AACA;EAHE;EAAAvG,MAAA,CAIMyH,eAAe;IAArB,SAAMA,eAAeA,CAACtH,GAAG;MAAA,IAAAC,IAAA,EAAAsH,aAAA,EAAAC,YAAA,EAAAC,kBAAA;MAAA,OAAA5I,mBAAA,CAAA0B,KAAA,WAAAmH,SAAA;QAAA,kBAAAA,SAAA,CAAAjH,IAAA,GAAAiH,SAAA,CAAAhH,IAAA;UAAA;YACjBT,IAAI,GAAG,IAAI,CAACL,WAAW,EAE7B;YACA;YAAA8H,SAAA,CAAAhH,IAAA;YAAA,OAAA7B,mBAAA,CAAA8E,KAAA,CACM,IAAI,CAACM,cAAc,CAACjE,GAAG,CAAC;UAAA;YAAA,IAMzBN,MAAM,CAACqH,IAAI,CAAC9G,IAAI,CAACmC,cAAc,EAAEpC,GAAG,CAACwC,EAAE,CAAC;cAAAkF,SAAA,CAAAhH,IAAA;cAAA;YAAA;YAAA,OAAAgH,SAAA,CAAA/F,MAAA;UAAA;YAI7C;YACM4F,aAAa,GAAGtH,IAAI,CAACmC,cAAc,CAACpC,GAAG,CAACwC,EAAE,CAAC,CAAC+E,aAAa;YACzDC,YAAY,GAAGvH,IAAI,CAACmC,cAAc,CAACpC,GAAG,CAACwC,EAAE,CAAC,CAACgF,YAAY;YAE7DvH,IAAI,CAACmC,cAAc,CAACpC,GAAG,CAACwC,EAAE,CAAC,CAACmF,MAAM,CAAC,CAAC;YAE9BF,kBAAkB,GAAG,SAAAA,CAAAG,MAAM,EAAI;cACnC,OACEA,MAAM,IACNA,MAAM,CAACV,KAAK,IACZ,IAAI5H,MAAM,CAAC2H,KAAK,CACdW,MAAM,CAACV,KAAK,CAACA,KAAK,EAClBU,MAAM,CAACV,KAAK,CAACC,MAAM,EACnBS,MAAM,CAACV,KAAK,CAACE,OACf,CAAC;YAEL,CAAC,EAED;YACA,IAAIG,aAAa,IAAIvH,GAAG,CAACkH,KAAK,EAAE;cAC9BK,aAAa,CAACE,kBAAkB,CAACzH,GAAG,CAAC,CAAC;YACxC;YAEA,IAAIwH,YAAY,EAAE;cAChBA,YAAY,CAACC,kBAAkB,CAACzH,GAAG,CAAC,CAAC;YACvC;UAAC;UAAA;YAAA,OAAA0H,SAAA,CAAA3D,IAAA;QAAA;MAAA,qBAAAC,OAAA;IAAA;IACF,OAzCKsD,eAAe;EAAA;EA2CrB;AACF;AACA;AACA;EAHE;EAAAzH,MAAA,CAIAgI,eAAe;IAAf,SAAAA,eAAeA,CAAC7H,GAAG,EAAE;MACnBV,MAAM,CAAC6G,MAAM,CAAC,8BAA8B,EAAEnG,GAAG,CAACmH,MAAM,CAAC;MACzD,IAAInH,GAAG,CAAC8H,gBAAgB,EAAExI,MAAM,CAAC6G,MAAM,CAAC,OAAO,EAAEnG,GAAG,CAAC8H,gBAAgB,CAAC;IACxE;IAAC,OAHDD,eAAe;EAAA,IAKf;EAAA;EAAA,OAAAzI,iBAAA;AAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"f1c993a7f04f6c7a194776441695a639de6715f5"}

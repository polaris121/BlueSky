{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\oplog_observe_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mongo/oplog_observe_driver.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\oplog_observe_driver.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"production","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\oplog_observe_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/oplog_observe_driver.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _asyncIterator;\n    module.link(\"@babel/runtime/helpers/asyncIterator\", {\n      default(v) {\n        _asyncIterator = v;\n      }\n    }, 0);\n    module.export({\n      OplogObserveDriver: () => OplogObserveDriver\n    });\n    let has;\n    module.link(\"lodash.has\", {\n      default(v) {\n        has = v;\n      }\n    }, 0);\n    let isEmpty;\n    module.link(\"lodash.isempty\", {\n      default(v) {\n        isEmpty = v;\n      }\n    }, 1);\n    let oplogV2V1Converter;\n    module.link(\"./oplog_v2_converter\", {\n      oplogV2V1Converter(v) {\n        oplogV2V1Converter = v;\n      }\n    }, 2);\n    let check, Match;\n    module.link(\"meteor/check\", {\n      check(v) {\n        check = v;\n      },\n      Match(v) {\n        Match = v;\n      }\n    }, 3);\n    let CursorDescription;\n    module.link(\"./cursor_description\", {\n      CursorDescription(v) {\n        CursorDescription = v;\n      }\n    }, 4);\n    let forEachTrigger, listenAll;\n    module.link(\"./mongo_driver\", {\n      forEachTrigger(v) {\n        forEachTrigger = v;\n      },\n      listenAll(v) {\n        listenAll = v;\n      }\n    }, 5);\n    let Cursor;\n    module.link(\"./cursor\", {\n      Cursor(v) {\n        Cursor = v;\n      }\n    }, 6);\n    let LocalCollection;\n    module.link(\"meteor/minimongo/local_collection\", {\n      default(v) {\n        LocalCollection = v;\n      }\n    }, 7);\n    let idForOp;\n    module.link(\"./oplog_tailing\", {\n      idForOp(v) {\n        idForOp = v;\n      }\n    }, 8);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    var PHASE = {\n      QUERYING: \"QUERYING\",\n      FETCHING: \"FETCHING\",\n      STEADY: \"STEADY\"\n    };\n\n    // Exception thrown by _needToPollQuery which unrolls the stack up to the\n    // enclosing call to finishIfNeedToPollQuery.\n    var SwitchedToQuery = function () {};\n    var finishIfNeedToPollQuery = function (f) {\n      return function () {\n        try {\n          f.apply(this, arguments);\n        } catch (e) {\n          if (!(e instanceof SwitchedToQuery)) throw e;\n        }\n      };\n    };\n    var currentId = 0;\n\n    /**\n     * @class OplogObserveDriver\n     * An alternative to PollingObserveDriver which follows the MongoDB operation log\n     * instead of re-polling the query.\n     *\n     * Characteristics:\n     * - Follows the MongoDB operation log\n     * - Directly observes database changes\n     * - More efficient than polling for most use cases\n     * - Requires access to MongoDB oplog\n     *\n     * Interface:\n     * - Construction initiates observeChanges callbacks and ready() invocation to the ObserveMultiplexer\n     * - Observation can be terminated via the stop() method\n     */\n    const OplogObserveDriver = function (options) {\n      const self = this;\n      self._usesOplog = true; // tests look at this\n\n      self._id = currentId;\n      currentId++;\n      self._cursorDescription = options.cursorDescription;\n      self._mongoHandle = options.mongoHandle;\n      self._multiplexer = options.multiplexer;\n      if (options.ordered) {\n        throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n      }\n      const sorter = options.sorter;\n      // We don't support $near and other geo-queries so it's OK to initialize the\n      // comparator only once in the constructor.\n      const comparator = sorter && sorter.getComparator();\n      if (options.cursorDescription.options.limit) {\n        // There are several properties ordered driver implements:\n        // - _limit is a positive number\n        // - _comparator is a function-comparator by which the query is ordered\n        // - _unpublishedBuffer is non-null Min/Max Heap,\n        //                      the empty buffer in STEADY phase implies that the\n        //                      everything that matches the queries selector fits\n        //                      into published set.\n        // - _published - Max Heap (also implements IdMap methods)\n\n        const heapOptions = {\n          IdMap: LocalCollection._IdMap\n        };\n        self._limit = self._cursorDescription.options.limit;\n        self._comparator = comparator;\n        self._sorter = sorter;\n        self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);\n        // We need something that can find Max value in addition to IdMap interface\n        self._published = new MaxHeap(comparator, heapOptions);\n      } else {\n        self._limit = 0;\n        self._comparator = null;\n        self._sorter = null;\n        self._unpublishedBuffer = null;\n        // Memory Growth\n        self._published = new LocalCollection._IdMap();\n      }\n\n      // Indicates if it is safe to insert a new document at the end of the buffer\n      // for this query. i.e. it is known that there are no documents matching the\n      // selector those are not in published or buffer.\n      self._safeAppendToBuffer = false;\n      self._stopped = false;\n      self._stopHandles = [];\n      self._addStopHandles = function (newStopHandles) {\n        const expectedPattern = Match.ObjectIncluding({\n          stop: Function\n        });\n        // Single item or array\n        check(newStopHandles, Match.OneOf([expectedPattern], expectedPattern));\n        self._stopHandles.push(newStopHandles);\n      };\n      Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", 1);\n      self._registerPhaseChange(PHASE.QUERYING);\n      self._matcher = options.matcher;\n      // we are now using projection, not fields in the cursor description even if you pass {fields}\n      // in the cursor construction\n      const projection = self._cursorDescription.options.fields || self._cursorDescription.options.projection || {};\n      self._projectionFn = LocalCollection._compileProjection(projection);\n      // Projection function, result of combining important fields for selector and\n      // existing fields projection\n      self._sharedProjection = self._matcher.combineIntoProjection(projection);\n      if (sorter) self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n      self._sharedProjectionFn = LocalCollection._compileProjection(self._sharedProjection);\n      self._needToFetch = new LocalCollection._IdMap();\n      self._currentlyFetching = null;\n      self._fetchGeneration = 0;\n      self._requeryWhenDoneThisQuery = false;\n      self._writesToCommitWhenWeReachSteady = [];\n    };\n    Object.assign(OplogObserveDriver.prototype, {\n      _init: async function () {\n        const self = this;\n\n        // If the oplog handle tells us that it skipped some entries (because it got\n        // behind, say), re-poll.\n        self._addStopHandles(self._mongoHandle._oplogHandle.onSkippedEntries(finishIfNeedToPollQuery(function () {\n          return self._needToPollQuery();\n        })));\n        await forEachTrigger(self._cursorDescription, async function (trigger) {\n          self._addStopHandles(await self._mongoHandle._oplogHandle.onOplogEntry(trigger, function (notification) {\n            finishIfNeedToPollQuery(function () {\n              const op = notification.op;\n              if (notification.dropCollection || notification.dropDatabase) {\n                // Note: this call is not allowed to block on anything (especially\n                // on waiting for oplog entries to catch up) because that will block\n                // onOplogEntry!\n                return self._needToPollQuery();\n              } else {\n                // All other operators should be handled depending on phase\n                if (self._phase === PHASE.QUERYING) {\n                  return self._handleOplogEntryQuerying(op);\n                } else {\n                  return self._handleOplogEntrySteadyOrFetching(op);\n                }\n              }\n            })();\n          }));\n        });\n\n        // XXX ordering w.r.t. everything else?\n        self._addStopHandles(await listenAll(self._cursorDescription, function () {\n          // If we're not in a pre-fire write fence, we don't have to do anything.\n          const fence = DDPServer._getCurrentFence();\n          if (!fence || fence.fired) return;\n          if (fence._oplogObserveDrivers) {\n            fence._oplogObserveDrivers[self._id] = self;\n            return;\n          }\n          fence._oplogObserveDrivers = {};\n          fence._oplogObserveDrivers[self._id] = self;\n          fence.onBeforeFire(async function () {\n            const drivers = fence._oplogObserveDrivers;\n            delete fence._oplogObserveDrivers;\n\n            // This fence cannot fire until we've caught up to \"this point\" in the\n            // oplog, and all observers made it back to the steady state.\n            await self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n            for (const driver of Object.values(drivers)) {\n              if (driver._stopped) continue;\n              const write = await fence.beginWrite();\n              if (driver._phase === PHASE.STEADY) {\n                // Make sure that all of the callbacks have made it through the\n                // multiplexer and been delivered to ObserveHandles before committing\n                // writes.\n                await driver._multiplexer.onFlush(write.committed);\n              } else {\n                driver._writesToCommitWhenWeReachSteady.push(write);\n              }\n            }\n          });\n        }));\n\n        // When Mongo fails over, we need to repoll the query, in case we processed an\n        // oplog entry that got rolled back.\n        self._addStopHandles(self._mongoHandle._onFailover(finishIfNeedToPollQuery(function () {\n          return self._needToPollQuery();\n        })));\n\n        // Give _observeChanges a chance to add the new ObserveHandle to our\n        // multiplexer, so that the added calls get streamed.\n        return self._runInitialQuery();\n      },\n      _addPublished: function (id, doc) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          var fields = Object.assign({}, doc);\n          delete fields._id;\n          self._published.set(id, self._sharedProjectionFn(doc));\n          self._multiplexer.added(id, self._projectionFn(fields));\n\n          // After adding this document, the published set might be overflowed\n          // (exceeding capacity specified by limit). If so, push the maximum\n          // element to the buffer, we might want to save it in memory to reduce the\n          // amount of Mongo lookups in the future.\n          if (self._limit && self._published.size() > self._limit) {\n            // XXX in theory the size of published is no more than limit+1\n            if (self._published.size() !== self._limit + 1) {\n              throw new Error(\"After adding to published, \" + (self._published.size() - self._limit) + \" documents are overflowing the set\");\n            }\n            var overflowingDocId = self._published.maxElementId();\n            var overflowingDoc = self._published.get(overflowingDocId);\n            if (EJSON.equals(overflowingDocId, id)) {\n              throw new Error(\"The document just added is overflowing the published set\");\n            }\n            self._published.remove(overflowingDocId);\n            self._multiplexer.removed(overflowingDocId);\n            self._addBuffered(overflowingDocId, overflowingDoc);\n          }\n        });\n      },\n      _removePublished: function (id) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          self._published.remove(id);\n          self._multiplexer.removed(id);\n          if (!self._limit || self._published.size() === self._limit) return;\n          if (self._published.size() > self._limit) throw Error(\"self._published got too big\");\n\n          // OK, we are publishing less than the limit. Maybe we should look in the\n          // buffer to find the next element past what we were publishing before.\n\n          if (!self._unpublishedBuffer.empty()) {\n            // There's something in the buffer; move the first thing in it to\n            // _published.\n            var newDocId = self._unpublishedBuffer.minElementId();\n            var newDoc = self._unpublishedBuffer.get(newDocId);\n            self._removeBuffered(newDocId);\n            self._addPublished(newDocId, newDoc);\n            return;\n          }\n\n          // There's nothing in the buffer.  This could mean one of a few things.\n\n          // (a) We could be in the middle of re-running the query (specifically, we\n          // could be in _publishNewResults). In that case, _unpublishedBuffer is\n          // empty because we clear it at the beginning of _publishNewResults. In\n          // this case, our caller already knows the entire answer to the query and\n          // we don't need to do anything fancy here.  Just return.\n          if (self._phase === PHASE.QUERYING) return;\n\n          // (b) We're pretty confident that the union of _published and\n          // _unpublishedBuffer contain all documents that match selector. Because\n          // _unpublishedBuffer is empty, that means we're confident that _published\n          // contains all documents that match selector. So we have nothing to do.\n          if (self._safeAppendToBuffer) return;\n\n          // (c) Maybe there are other documents out there that should be in our\n          // buffer. But in that case, when we emptied _unpublishedBuffer in\n          // _removeBuffered, we should have called _needToPollQuery, which will\n          // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n          // (or both), and it will put us in QUERYING for that whole time. So in\n          // fact, we shouldn't be able to get here.\n\n          throw new Error(\"Buffer inexplicably empty\");\n        });\n      },\n      _changePublished: function (id, oldDoc, newDoc) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          self._published.set(id, self._sharedProjectionFn(newDoc));\n          var projectedNew = self._projectionFn(newDoc);\n          var projectedOld = self._projectionFn(oldDoc);\n          var changed = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n          if (!isEmpty(changed)) self._multiplexer.changed(id, changed);\n        });\n      },\n      _addBuffered: function (id, doc) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));\n\n          // If something is overflowing the buffer, we just remove it from cache\n          if (self._unpublishedBuffer.size() > self._limit) {\n            var maxBufferedId = self._unpublishedBuffer.maxElementId();\n            self._unpublishedBuffer.remove(maxBufferedId);\n\n            // Since something matching is removed from cache (both published set and\n            // buffer), set flag to false\n            self._safeAppendToBuffer = false;\n          }\n        });\n      },\n      // Is called either to remove the doc completely from matching set or to move\n      // it to the published set later.\n      _removeBuffered: function (id) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          self._unpublishedBuffer.remove(id);\n          // To keep the contract \"buffer is never empty in STEADY phase unless the\n          // everything matching fits into published\" true, we poll everything as\n          // soon as we see the buffer becoming empty.\n          if (!self._unpublishedBuffer.size() && !self._safeAppendToBuffer) self._needToPollQuery();\n        });\n      },\n      // Called when a document has joined the \"Matching\" results set.\n      // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n      // and the effect of limit enforced.\n      _addMatching: function (doc) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          var id = doc._id;\n          if (self._published.has(id)) throw Error(\"tried to add something already published \" + id);\n          if (self._limit && self._unpublishedBuffer.has(id)) throw Error(\"tried to add something already existed in buffer \" + id);\n          var limit = self._limit;\n          var comparator = self._comparator;\n          var maxPublished = limit && self._published.size() > 0 ? self._published.get(self._published.maxElementId()) : null;\n          var maxBuffered = limit && self._unpublishedBuffer.size() > 0 ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId()) : null;\n          // The query is unlimited or didn't publish enough documents yet or the\n          // new document would fit into published set pushing the maximum element\n          // out, then we need to publish the doc.\n          var toPublish = !limit || self._published.size() < limit || comparator(doc, maxPublished) < 0;\n\n          // Otherwise we might need to buffer it (only in case of limited query).\n          // Buffering is allowed if the buffer is not filled up yet and all\n          // matching docs are either in the published set or in the buffer.\n          var canAppendToBuffer = !toPublish && self._safeAppendToBuffer && self._unpublishedBuffer.size() < limit;\n\n          // Or if it is small enough to be safely inserted to the middle or the\n          // beginning of the buffer.\n          var canInsertIntoBuffer = !toPublish && maxBuffered && comparator(doc, maxBuffered) <= 0;\n          var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n          if (toPublish) {\n            self._addPublished(id, doc);\n          } else if (toBuffer) {\n            self._addBuffered(id, doc);\n          } else {\n            // dropping it and not saving to the cache\n            self._safeAppendToBuffer = false;\n          }\n        });\n      },\n      // Called when a document leaves the \"Matching\" results set.\n      // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n      // and the effect of limit enforced.\n      _removeMatching: function (id) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          if (!self._published.has(id) && !self._limit) throw Error(\"tried to remove something matching but not cached \" + id);\n          if (self._published.has(id)) {\n            self._removePublished(id);\n          } else if (self._unpublishedBuffer.has(id)) {\n            self._removeBuffered(id);\n          }\n        });\n      },\n      _handleDoc: function (id, newDoc) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n          var publishedBefore = self._published.has(id);\n          var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n          var cachedBefore = publishedBefore || bufferedBefore;\n          if (matchesNow && !cachedBefore) {\n            self._addMatching(newDoc);\n          } else if (cachedBefore && !matchesNow) {\n            self._removeMatching(id);\n          } else if (cachedBefore && matchesNow) {\n            var oldDoc = self._published.get(id);\n            var comparator = self._comparator;\n            var minBuffered = self._limit && self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n            var maxBuffered;\n            if (publishedBefore) {\n              // Unlimited case where the document stays in published once it\n              // matches or the case when we don't have enough matching docs to\n              // publish or the changed but matching doc will stay in published\n              // anyways.\n              //\n              // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n              // fact that buffer can't be empty if there are matching documents not\n              // published. Notably, we don't want to schedule repoll and continue\n              // relying on this property.\n              var staysInPublished = !self._limit || self._unpublishedBuffer.size() === 0 || comparator(newDoc, minBuffered) <= 0;\n              if (staysInPublished) {\n                self._changePublished(id, oldDoc, newDoc);\n              } else {\n                // after the change doc doesn't stay in the published, remove it\n                self._removePublished(id);\n                // but it can move into buffered now, check it\n                maxBuffered = self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n                var toBuffer = self._safeAppendToBuffer || maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n                if (toBuffer) {\n                  self._addBuffered(id, newDoc);\n                } else {\n                  // Throw away from both published set and buffer\n                  self._safeAppendToBuffer = false;\n                }\n              }\n            } else if (bufferedBefore) {\n              oldDoc = self._unpublishedBuffer.get(id);\n              // remove the old version manually instead of using _removeBuffered so\n              // we don't trigger the querying immediately.  if we end this block\n              // with the buffer empty, we will need to trigger the query poll\n              // manually too.\n              self._unpublishedBuffer.remove(id);\n              var maxPublished = self._published.get(self._published.maxElementId());\n              maxBuffered = self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n\n              // the buffered doc was updated, it could move to published\n              var toPublish = comparator(newDoc, maxPublished) < 0;\n\n              // or stays in buffer even after the change\n              var staysInBuffer = !toPublish && self._safeAppendToBuffer || !toPublish && maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n              if (toPublish) {\n                self._addPublished(id, newDoc);\n              } else if (staysInBuffer) {\n                // stays in buffer but changes\n                self._unpublishedBuffer.set(id, newDoc);\n              } else {\n                // Throw away from both published set and buffer\n                self._safeAppendToBuffer = false;\n                // Normally this check would have been done in _removeBuffered but\n                // we didn't use it, so we need to do it ourself now.\n                if (!self._unpublishedBuffer.size()) {\n                  self._needToPollQuery();\n                }\n              }\n            } else {\n              throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n            }\n          }\n        });\n      },\n      _fetchModifiedDocuments: function () {\n        var self = this;\n        self._registerPhaseChange(PHASE.FETCHING);\n        // Defer, because nothing called from the oplog entry handler may yield,\n        // but fetch() yields.\n        Meteor.defer(finishIfNeedToPollQuery(async function () {\n          while (!self._stopped && !self._needToFetch.empty()) {\n            if (self._phase === PHASE.QUERYING) {\n              // While fetching, we decided to go into QUERYING mode, and then we\n              // saw another oplog entry, so _needToFetch is not empty. But we\n              // shouldn't fetch these documents until AFTER the query is done.\n              break;\n            }\n\n            // Being in steady phase here would be surprising.\n            if (self._phase !== PHASE.FETCHING) throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n            self._currentlyFetching = self._needToFetch;\n            var thisGeneration = ++self._fetchGeneration;\n            self._needToFetch = new LocalCollection._IdMap();\n\n            // Create an array of promises for all the fetch operations\n            const fetchPromises = [];\n            self._currentlyFetching.forEach(function (op, id) {\n              const fetchPromise = new Promise((resolve, reject) => {\n                self._mongoHandle._docFetcher.fetch(self._cursorDescription.collectionName, id, op, finishIfNeedToPollQuery(function (err, doc) {\n                  if (err) {\n                    Meteor._debug('Got exception while fetching documents', err);\n                    // If we get an error from the fetcher (eg, trouble\n                    // connecting to Mongo), let's just abandon the fetch phase\n                    // altogether and fall back to polling. It's not like we're\n                    // getting live updates anyway.\n                    if (self._phase !== PHASE.QUERYING) {\n                      self._needToPollQuery();\n                    }\n                    resolve();\n                    return;\n                  }\n                  if (!self._stopped && self._phase === PHASE.FETCHING && self._fetchGeneration === thisGeneration) {\n                    // We re-check the generation in case we've had an explicit\n                    // _pollQuery call (eg, in another fiber) which should\n                    // effectively cancel this round of fetches.  (_pollQuery\n                    // increments the generation.)\n                    try {\n                      self._handleDoc(id, doc);\n                      resolve();\n                    } catch (err) {\n                      reject(err);\n                    }\n                  } else {\n                    resolve();\n                  }\n                }));\n              });\n              fetchPromises.push(fetchPromise);\n            });\n            // Wait for all fetch operations to complete\n            try {\n              const results = await Promise.allSettled(fetchPromises);\n              const errors = results.filter(result => result.status === 'rejected').map(result => result.reason);\n              if (errors.length > 0) {\n                Meteor._debug('Some fetch queries failed:', errors);\n              }\n            } catch (err) {\n              Meteor._debug('Got an exception in a fetch query', err);\n            }\n            // Exit now if we've had a _pollQuery call (here or in another fiber).\n            if (self._phase === PHASE.QUERYING) return;\n            self._currentlyFetching = null;\n          }\n          // We're done fetching, so we can be steady, unless we've had a\n          // _pollQuery call (here or in another fiber).\n          if (self._phase !== PHASE.QUERYING) await self._beSteady();\n        }));\n      },\n      _beSteady: async function () {\n        var self = this;\n        self._registerPhaseChange(PHASE.STEADY);\n        var writes = self._writesToCommitWhenWeReachSteady || [];\n        self._writesToCommitWhenWeReachSteady = [];\n        await self._multiplexer.onFlush(async function () {\n          try {\n            for (const w of writes) {\n              await w.committed();\n            }\n          } catch (e) {\n            console.error(\"_beSteady error\", {\n              writes\n            }, e);\n          }\n        });\n      },\n      _handleOplogEntryQuerying: function (op) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          self._needToFetch.set(idForOp(op), op);\n        });\n      },\n      _handleOplogEntrySteadyOrFetching: function (op) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          var id = idForOp(op);\n          // If we're already fetching this one, or about to, we can't optimize;\n          // make sure that we fetch it again if necessary.\n\n          if (self._phase === PHASE.FETCHING && (self._currentlyFetching && self._currentlyFetching.has(id) || self._needToFetch.has(id))) {\n            self._needToFetch.set(id, op);\n            return;\n          }\n          if (op.op === 'd') {\n            if (self._published.has(id) || self._limit && self._unpublishedBuffer.has(id)) self._removeMatching(id);\n          } else if (op.op === 'i') {\n            if (self._published.has(id)) throw new Error(\"insert found for already-existing ID in published\");\n            if (self._unpublishedBuffer && self._unpublishedBuffer.has(id)) throw new Error(\"insert found for already-existing ID in buffer\");\n\n            // XXX what if selector yields?  for now it can't but later it could\n            // have $where\n            if (self._matcher.documentMatches(op.o).result) self._addMatching(op.o);\n          } else if (op.op === 'u') {\n            // we are mapping the new oplog format on mongo 5\n            // to what we know better, $set\n            op.o = oplogV2V1Converter(op.o);\n            // Is this a modifier ($set/$unset, which may require us to poll the\n            // database to figure out if the whole document matches the selector) or\n            // a replacement (in which case we can just directly re-evaluate the\n            // selector)?\n            // oplog format has changed on mongodb 5, we have to support both now\n            // diff is the format in Mongo 5+ (oplog v2)\n            var isReplace = !has(op.o, '$set') && !has(op.o, 'diff') && !has(op.o, '$unset');\n            // If this modifier modifies something inside an EJSON custom type (ie,\n            // anything with EJSON$), then we can't try to use\n            // LocalCollection._modify, since that just mutates the EJSON encoding,\n            // not the actual object.\n            var canDirectlyModifyDoc = !isReplace && modifierCanBeDirectlyApplied(op.o);\n            var publishedBefore = self._published.has(id);\n            var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n            if (isReplace) {\n              self._handleDoc(id, Object.assign({\n                _id: id\n              }, op.o));\n            } else if ((publishedBefore || bufferedBefore) && canDirectlyModifyDoc) {\n              // Oh great, we actually know what the document is, so we can apply\n              // this directly.\n              var newDoc = self._published.has(id) ? self._published.get(id) : self._unpublishedBuffer.get(id);\n              newDoc = EJSON.clone(newDoc);\n              newDoc._id = id;\n              try {\n                LocalCollection._modify(newDoc, op.o);\n              } catch (e) {\n                if (e.name !== \"MinimongoError\") throw e;\n                // We didn't understand the modifier.  Re-fetch.\n                self._needToFetch.set(id, op);\n                if (self._phase === PHASE.STEADY) {\n                  self._fetchModifiedDocuments();\n                }\n                return;\n              }\n              self._handleDoc(id, self._sharedProjectionFn(newDoc));\n            } else if (!canDirectlyModifyDoc || self._matcher.canBecomeTrueByModifier(op.o) || self._sorter && self._sorter.affectedByModifier(op.o)) {\n              self._needToFetch.set(id, op);\n              if (self._phase === PHASE.STEADY) self._fetchModifiedDocuments();\n            }\n          } else {\n            throw Error(\"XXX SURPRISING OPERATION: \" + op);\n          }\n        });\n      },\n      async _runInitialQueryAsync() {\n        var self = this;\n        if (self._stopped) throw new Error(\"oplog stopped surprisingly early\");\n        await self._runQuery({\n          initial: true\n        }); // yields\n\n        if (self._stopped) return; // can happen on queryError\n\n        // Allow observeChanges calls to return. (After this, it's possible for\n        // stop() to be called.)\n        await self._multiplexer.ready();\n        await self._doneQuerying(); // yields\n      },\n      // Yields!\n      _runInitialQuery: function () {\n        return this._runInitialQueryAsync();\n      },\n      // In various circumstances, we may just want to stop processing the oplog and\n      // re-run the initial query, just as if we were a PollingObserveDriver.\n      //\n      // This function may not block, because it is called from an oplog entry\n      // handler.\n      //\n      // XXX We should call this when we detect that we've been in FETCHING for \"too\n      // long\".\n      //\n      // XXX We should call this when we detect Mongo failover (since that might\n      // mean that some of the oplog entries we have processed have been rolled\n      // back). The Node Mongo driver is in the middle of a bunch of huge\n      // refactorings, including the way that it notifies you when primary\n      // changes. Will put off implementing this until driver 1.4 is out.\n      _pollQuery: function () {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          if (self._stopped) return;\n\n          // Yay, we get to forget about all the things we thought we had to fetch.\n          self._needToFetch = new LocalCollection._IdMap();\n          self._currentlyFetching = null;\n          ++self._fetchGeneration; // ignore any in-flight fetches\n          self._registerPhaseChange(PHASE.QUERYING);\n\n          // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n          // here because SwitchedToQuery is not thrown in QUERYING mode.\n          Meteor.defer(async function () {\n            await self._runQuery();\n            await self._doneQuerying();\n          });\n        });\n      },\n      // Yields!\n      async _runQueryAsync(options) {\n        var self = this;\n        options = options || {};\n        var newResults, newBuffer;\n\n        // This while loop is just to retry failures.\n        while (true) {\n          // If we've been stopped, we don't have to run anything any more.\n          if (self._stopped) return;\n          newResults = new LocalCollection._IdMap();\n          newBuffer = new LocalCollection._IdMap();\n\n          // Query 2x documents as the half excluded from the original query will go\n          // into unpublished buffer to reduce additional Mongo lookups in cases\n          // when documents are removed from the published set and need a\n          // replacement.\n          // XXX needs more thought on non-zero skip\n          // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n          // buffer if such is needed.\n          var cursor = self._cursorForQuery({\n            limit: self._limit * 2\n          });\n          try {\n            await cursor.forEach(function (doc, i) {\n              // yields\n              if (!self._limit || i < self._limit) {\n                newResults.set(doc._id, doc);\n              } else {\n                newBuffer.set(doc._id, doc);\n              }\n            });\n            break;\n          } catch (e) {\n            if (options.initial && typeof e.code === 'number') {\n              // This is an error document sent to us by mongod, not a connection\n              // error generated by the client. And we've never seen this query work\n              // successfully. Probably it's a bad selector or something, so we\n              // should NOT retry. Instead, we should halt the observe (which ends\n              // up calling `stop` on us).\n              await self._multiplexer.queryError(e);\n              return;\n            }\n\n            // During failover (eg) if we get an exception we should log and retry\n            // instead of crashing.\n            Meteor._debug(\"Got exception while polling query\", e);\n            await Meteor._sleepForMs(100);\n          }\n        }\n        if (self._stopped) return;\n        self._publishNewResults(newResults, newBuffer);\n      },\n      // Yields!\n      _runQuery: function (options) {\n        return this._runQueryAsync(options);\n      },\n      // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n      // ensures that we will query again later.\n      //\n      // This function may not block, because it is called from an oplog entry\n      // handler. However, if we were not already in the QUERYING phase, it throws\n      // an exception that is caught by the closest surrounding\n      // finishIfNeedToPollQuery call; this ensures that we don't continue running\n      // close that was designed for another phase inside PHASE.QUERYING.\n      //\n      // (It's also necessary whenever logic in this file yields to check that other\n      // phases haven't put us into QUERYING mode, though; eg,\n      // _fetchModifiedDocuments does this.)\n      _needToPollQuery: function () {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          if (self._stopped) return;\n\n          // If we're not already in the middle of a query, we can query now\n          // (possibly pausing FETCHING).\n          if (self._phase !== PHASE.QUERYING) {\n            self._pollQuery();\n            throw new SwitchedToQuery();\n          }\n\n          // We're currently in QUERYING. Set a flag to ensure that we run another\n          // query when we're done.\n          self._requeryWhenDoneThisQuery = true;\n        });\n      },\n      // Yields!\n      _doneQuerying: async function () {\n        var self = this;\n        if (self._stopped) return;\n        await self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n        if (self._stopped) return;\n        if (self._phase !== PHASE.QUERYING) throw Error(\"Phase unexpectedly \" + self._phase);\n        if (self._requeryWhenDoneThisQuery) {\n          self._requeryWhenDoneThisQuery = false;\n          self._pollQuery();\n        } else if (self._needToFetch.empty()) {\n          await self._beSteady();\n        } else {\n          self._fetchModifiedDocuments();\n        }\n      },\n      _cursorForQuery: function (optionsOverwrite) {\n        var self = this;\n        return Meteor._noYieldsAllowed(function () {\n          // The query we run is almost the same as the cursor we are observing,\n          // with a few changes. We need to read all the fields that are relevant to\n          // the selector, not just the fields we are going to publish (that's the\n          // \"shared\" projection). And we don't want to apply any transform in the\n          // cursor, because observeChanges shouldn't use the transform.\n          var options = Object.assign({}, self._cursorDescription.options);\n\n          // Allow the caller to modify the options. Useful to specify different\n          // skip and limit values.\n          Object.assign(options, optionsOverwrite);\n          options.fields = self._sharedProjection;\n          delete options.transform;\n          // We are NOT deep cloning fields or selector here, which should be OK.\n          var description = new CursorDescription(self._cursorDescription.collectionName, self._cursorDescription.selector, options);\n          return new Cursor(self._mongoHandle, description);\n        });\n      },\n      // Replace self._published with newResults (both are IdMaps), invoking observe\n      // callbacks on the multiplexer.\n      // Replace self._unpublishedBuffer with newBuffer.\n      //\n      // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n      // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n      // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n      _publishNewResults: function (newResults, newBuffer) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          // If the query is limited and there is a buffer, shut down so it doesn't\n          // stay in a way.\n          if (self._limit) {\n            self._unpublishedBuffer.clear();\n          }\n\n          // First remove anything that's gone. Be careful not to modify\n          // self._published while iterating over it.\n          var idsToRemove = [];\n          self._published.forEach(function (doc, id) {\n            if (!newResults.has(id)) idsToRemove.push(id);\n          });\n          idsToRemove.forEach(function (id) {\n            self._removePublished(id);\n          });\n\n          // Now do adds and changes.\n          // If self has a buffer and limit, the new fetched result will be\n          // limited correctly as the query has sort specifier.\n          newResults.forEach(function (doc, id) {\n            self._handleDoc(id, doc);\n          });\n\n          // Sanity-check that everything we tried to put into _published ended up\n          // there.\n          // XXX if this is slow, remove it later\n          if (self._published.size() !== newResults.size()) {\n            Meteor._debug('The Mongo server and the Meteor query disagree on how ' + 'many documents match your query. Cursor description: ', self._cursorDescription);\n          }\n          self._published.forEach(function (doc, id) {\n            if (!newResults.has(id)) throw Error(\"_published has a doc that newResults doesn't; \" + id);\n          });\n\n          // Finally, replace the buffer\n          newBuffer.forEach(function (doc, id) {\n            self._addBuffered(id, doc);\n          });\n          self._safeAppendToBuffer = newBuffer.size() < self._limit;\n        });\n      },\n      // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n      // it shouldn't actually be possible to call it until the multiplexer is\n      // ready.\n      //\n      // It's important to check self._stopped after every call in this file that\n      // can yield!\n      _stop: async function () {\n        var self = this;\n        if (self._stopped) return;\n        self._stopped = true;\n\n        // Note: we *don't* use multiplexer.onFlush here because this stop\n        // callback is actually invoked by the multiplexer itself when it has\n        // determined that there are no handles left. So nothing is actually going\n        // to get flushed (and it's probably not valid to call methods on the\n        // dying multiplexer).\n        for (const w of self._writesToCommitWhenWeReachSteady) {\n          await w.committed();\n        }\n        self._writesToCommitWhenWeReachSteady = null;\n\n        // Proactively drop references to potentially big things.\n        self._published = null;\n        self._unpublishedBuffer = null;\n        self._needToFetch = null;\n        self._currentlyFetching = null;\n        self._oplogEntryHandle = null;\n        self._listenersHandle = null;\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", -1);\n        var _iteratorAbruptCompletion = false;\n        var _didIteratorError = false;\n        var _iteratorError;\n        try {\n          for (var _iterator = _asyncIterator(self._stopHandles), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n            const handle = _step.value;\n            {\n              await handle.stop();\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion && _iterator.return != null) {\n              await _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      },\n      stop: async function () {\n        const self = this;\n        return await self._stop();\n      },\n      _registerPhaseChange: function (phase) {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          var now = new Date();\n          if (self._phase) {\n            var timeDiff = now - self._phaseStartTime;\n            Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n          }\n          self._phase = phase;\n          self._phaseStartTime = now;\n        });\n      }\n    });\n\n    // Does our oplog tailing code support this cursor? For now, we are being very\n    // conservative and allowing only simple queries with simple options.\n    // (This is a \"static method\".)\n    OplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n      // First, check the options.\n      var options = cursorDescription.options;\n\n      // Did the user say no explicitly?\n      // underscored version of the option is COMPAT with 1.2\n      if (options.disableOplog || options._disableOplog) return false;\n\n      // skip is not supported: to support it we would need to keep track of all\n      // \"skipped\" documents or at least their ids.\n      // limit w/o a sort specifier is not supported: current implementation needs a\n      // deterministic way to order documents.\n      if (options.skip || options.limit && !options.sort) return false;\n\n      // If a fields projection option is given check if it is supported by\n      // minimongo (some operators are not supported).\n      const fields = options.fields || options.projection;\n      if (fields) {\n        try {\n          LocalCollection._checkSupportedProjection(fields);\n        } catch (e) {\n          if (e.name === \"MinimongoError\") {\n            return false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      // We don't allow the following selectors:\n      //   - $where (not confident that we provide the same JS environment\n      //             as Mongo, and can yield!)\n      //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n      //            of returning an ID multiple times, though even polling maybe\n      //            have a bug there)\n      //           XXX: once we support it, we would need to think more on how we\n      //           initialize the comparators when we create the driver.\n      return !matcher.hasWhere() && !matcher.hasGeoQuery();\n    };\n    var modifierCanBeDirectlyApplied = function (modifier) {\n      return Object.entries(modifier).every(function (_ref) {\n        let [operation, fields] = _ref;\n        return Object.entries(fields).every(function (_ref2) {\n          let [field, value] = _ref2;\n          return !/EJSON\\$/.test(field);\n        });\n      });\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_asyncIterator","module","link","default","v","export","OplogObserveDriver","has","isEmpty","oplogV2V1Converter","check","Match","CursorDescription","forEachTrigger","listenAll","Cursor","LocalCollection","idForOp","__reifyWaitForDeps__","PHASE","QUERYING","FETCHING","STEADY","SwitchedToQuery","finishIfNeedToPollQuery","f","apply","arguments","e","currentId","options","self","_usesOplog","_id","_cursorDescription","cursorDescription","_mongoHandle","mongoHandle","_multiplexer","multiplexer","ordered","Error","sorter","comparator","getComparator","limit","heapOptions","IdMap","_IdMap","_limit","_comparator","_sorter","_unpublishedBuffer","MinMaxHeap","_published","MaxHeap","_safeAppendToBuffer","_stopped","_stopHandles","_addStopHandles","newStopHandles","expectedPattern","ObjectIncluding","stop","Function","OneOf","push","Package","Facts","incrementServerFact","_registerPhaseChange","_matcher","matcher","projection","fields","_projectionFn","_compileProjection","_sharedProjection","combineIntoProjection","_sharedProjectionFn","_needToFetch","_currentlyFetching","_fetchGeneration","_requeryWhenDoneThisQuery","_writesToCommitWhenWeReachSteady","Object","assign","prototype","_init","_oplogHandle","onSkippedEntries","_needToPollQuery","trigger","onOplogEntry","notification","op","dropCollection","dropDatabase","_phase","_handleOplogEntryQuerying","_handleOplogEntrySteadyOrFetching","fence","DDPServer","_getCurrentFence","fired","_oplogObserveDrivers","onBeforeFire","drivers","waitUntilCaughtUp","driver","values","write","beginWrite","onFlush","committed","_onFailover","_runInitialQuery","_addPublished","id","doc","Meteor","_noYieldsAllowed","set","added","size","overflowingDocId","maxElementId","overflowingDoc","get","EJSON","equals","remove","removed","_addBuffered","_removePublished","empty","newDocId","minElementId","newDoc","_removeBuffered","_changePublished","oldDoc","projectedNew","projectedOld","changed","DiffSequence","makeChangedFields","maxBufferedId","_addMatching","maxPublished","maxBuffered","toPublish","canAppendToBuffer","canInsertIntoBuffer","toBuffer","_removeMatching","_handleDoc","matchesNow","documentMatches","result","publishedBefore","bufferedBefore","cachedBefore","minBuffered","staysInPublished","staysInBuffer","_fetchModifiedDocuments","defer","thisGeneration","fetchPromises","forEach","fetchPromise","Promise","resolve","reject","_docFetcher","fetch","collectionName","err","_debug","results","allSettled","errors","filter","status","map","reason","length","_beSteady","writes","w","console","error","o","isReplace","canDirectlyModifyDoc","modifierCanBeDirectlyApplied","clone","_modify","name","canBecomeTrueByModifier","affectedByModifier","_runInitialQueryAsync","_runQuery","initial","ready","_doneQuerying","_pollQuery","_runQueryAsync","newResults","newBuffer","cursor","_cursorForQuery","i","code","queryError","_sleepForMs","_publishNewResults","optionsOverwrite","transform","description","selector","clear","idsToRemove","_stop","_oplogEntryHandle","_listenersHandle","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","handle","value","return","phase","now","Date","timeDiff","_phaseStartTime","cursorSupported","disableOplog","_disableOplog","skip","sort","_checkSupportedProjection","hasWhere","hasGeoQuery","modifier","entries","every","_ref","operation","_ref2","field","test","__reify_async_result__","_reifyError","async"],"sources":["packages/mongo/oplog_observe_driver.js"],"sourcesContent":["import has from 'lodash.has';\nimport isEmpty from 'lodash.isempty';\nimport { oplogV2V1Converter } from \"./oplog_v2_converter\";\nimport { check, Match } from 'meteor/check';\nimport { CursorDescription } from './cursor_description';\nimport { forEachTrigger, listenAll } from './mongo_driver';\nimport { Cursor } from './cursor';\nimport LocalCollection from 'meteor/minimongo/local_collection';\nimport { idForOp } from './oplog_tailing';\n\nvar PHASE = {\n  QUERYING: \"QUERYING\",\n  FETCHING: \"FETCHING\",\n  STEADY: \"STEADY\"\n};\n\n// Exception thrown by _needToPollQuery which unrolls the stack up to the\n// enclosing call to finishIfNeedToPollQuery.\nvar SwitchedToQuery = function () {};\nvar finishIfNeedToPollQuery = function (f) {\n  return function () {\n    try {\n      f.apply(this, arguments);\n    } catch (e) {\n      if (!(e instanceof SwitchedToQuery))\n        throw e;\n    }\n  };\n};\n\nvar currentId = 0;\n\n/**\n * @class OplogObserveDriver\n * An alternative to PollingObserveDriver which follows the MongoDB operation log\n * instead of re-polling the query.\n *\n * Characteristics:\n * - Follows the MongoDB operation log\n * - Directly observes database changes\n * - More efficient than polling for most use cases\n * - Requires access to MongoDB oplog\n *\n * Interface:\n * - Construction initiates observeChanges callbacks and ready() invocation to the ObserveMultiplexer\n * - Observation can be terminated via the stop() method\n */\nexport const OplogObserveDriver = function (options) {\n  const self = this;\n  self._usesOplog = true;  // tests look at this\n\n  self._id = currentId;\n  currentId++;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._multiplexer = options.multiplexer;\n\n  if (options.ordered) {\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n  }\n\n  const sorter = options.sorter;\n  // We don't support $near and other geo-queries so it's OK to initialize the\n  // comparator only once in the constructor.\n  const comparator = sorter && sorter.getComparator();\n\n  if (options.cursorDescription.options.limit) {\n    // There are several properties ordered driver implements:\n    // - _limit is a positive number\n    // - _comparator is a function-comparator by which the query is ordered\n    // - _unpublishedBuffer is non-null Min/Max Heap,\n    //                      the empty buffer in STEADY phase implies that the\n    //                      everything that matches the queries selector fits\n    //                      into published set.\n    // - _published - Max Heap (also implements IdMap methods)\n\n    const heapOptions = { IdMap: LocalCollection._IdMap };\n    self._limit = self._cursorDescription.options.limit;\n    self._comparator = comparator;\n    self._sorter = sorter;\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);\n    // We need something that can find Max value in addition to IdMap interface\n    self._published = new MaxHeap(comparator, heapOptions);\n  } else {\n    self._limit = 0;\n    self._comparator = null;\n    self._sorter = null;\n    self._unpublishedBuffer = null;\n    // Memory Growth\n    self._published = new LocalCollection._IdMap;\n  }\n\n  // Indicates if it is safe to insert a new document at the end of the buffer\n  // for this query. i.e. it is known that there are no documents matching the\n  // selector those are not in published or buffer.\n  self._safeAppendToBuffer = false;\n\n  self._stopped = false;\n  self._stopHandles = [];\n  self._addStopHandles = function (newStopHandles) {\n    const expectedPattern = Match.ObjectIncluding({ stop: Function });\n    // Single item or array\n    check(newStopHandles, Match.OneOf([expectedPattern], expectedPattern));\n    self._stopHandles.push(newStopHandles);\n  }\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-oplog\", 1);\n\n  self._registerPhaseChange(PHASE.QUERYING);\n\n  self._matcher = options.matcher;\n  // we are now using projection, not fields in the cursor description even if you pass {fields}\n  // in the cursor construction\n  const projection = self._cursorDescription.options.fields || self._cursorDescription.options.projection || {};\n  self._projectionFn = LocalCollection._compileProjection(projection);\n  // Projection function, result of combining important fields for selector and\n  // existing fields projection\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);\n  if (sorter)\n    self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n  self._sharedProjectionFn = LocalCollection._compileProjection(\n    self._sharedProjection);\n\n  self._needToFetch = new LocalCollection._IdMap;\n  self._currentlyFetching = null;\n  self._fetchGeneration = 0;\n\n  self._requeryWhenDoneThisQuery = false;\n  self._writesToCommitWhenWeReachSteady = [];\n };\n\nObject.assign(OplogObserveDriver.prototype, {\n  _init: async function() {\n    const self = this;\n\n    // If the oplog handle tells us that it skipped some entries (because it got\n    // behind, say), re-poll.\n    self._addStopHandles(self._mongoHandle._oplogHandle.onSkippedEntries(\n      finishIfNeedToPollQuery(function () {\n        return self._needToPollQuery();\n      })\n    ));\n    \n    await forEachTrigger(self._cursorDescription, async function (trigger) {\n      self._addStopHandles(await self._mongoHandle._oplogHandle.onOplogEntry(\n        trigger, function (notification) {\n          finishIfNeedToPollQuery(function () {\n            const op = notification.op;\n            if (notification.dropCollection || notification.dropDatabase) {\n              // Note: this call is not allowed to block on anything (especially\n              // on waiting for oplog entries to catch up) because that will block\n              // onOplogEntry!\n              return self._needToPollQuery();\n            } else {\n              // All other operators should be handled depending on phase\n              if (self._phase === PHASE.QUERYING) {\n                return self._handleOplogEntryQuerying(op);\n              } else {\n                return self._handleOplogEntrySteadyOrFetching(op);\n              }\n            }\n          })();\n        }\n      ));\n    });\n  \n    // XXX ordering w.r.t. everything else?\n    self._addStopHandles(await listenAll(\n      self._cursorDescription, function () {\n        // If we're not in a pre-fire write fence, we don't have to do anything.\n        const fence = DDPServer._getCurrentFence();\n        if (!fence || fence.fired)\n          return;\n  \n        if (fence._oplogObserveDrivers) {\n          fence._oplogObserveDrivers[self._id] = self;\n          return;\n        }\n  \n        fence._oplogObserveDrivers = {};\n        fence._oplogObserveDrivers[self._id] = self;\n  \n        fence.onBeforeFire(async function () {\n          const drivers = fence._oplogObserveDrivers;\n          delete fence._oplogObserveDrivers;\n  \n          // This fence cannot fire until we've caught up to \"this point\" in the\n          // oplog, and all observers made it back to the steady state.\n          await self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n  \n          for (const driver of Object.values(drivers)) {\n            if (driver._stopped)\n              continue;\n  \n            const write = await fence.beginWrite();\n            if (driver._phase === PHASE.STEADY) {\n              // Make sure that all of the callbacks have made it through the\n              // multiplexer and been delivered to ObserveHandles before committing\n              // writes.\n              await driver._multiplexer.onFlush(write.committed);\n            } else {\n              driver._writesToCommitWhenWeReachSteady.push(write);\n            }\n          }\n        });\n      }\n    ));\n  \n    // When Mongo fails over, we need to repoll the query, in case we processed an\n    // oplog entry that got rolled back.\n    self._addStopHandles(self._mongoHandle._onFailover(finishIfNeedToPollQuery(\n      function () {\n        return self._needToPollQuery();\n      })));\n  \n    // Give _observeChanges a chance to add the new ObserveHandle to our\n    // multiplexer, so that the added calls get streamed.\n    return self._runInitialQuery();\n  },\n  _addPublished: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var fields = Object.assign({}, doc);\n      delete fields._id;\n      self._published.set(id, self._sharedProjectionFn(doc));\n      self._multiplexer.added(id, self._projectionFn(fields));\n\n      // After adding this document, the published set might be overflowed\n      // (exceeding capacity specified by limit). If so, push the maximum\n      // element to the buffer, we might want to save it in memory to reduce the\n      // amount of Mongo lookups in the future.\n      if (self._limit && self._published.size() > self._limit) {\n        // XXX in theory the size of published is no more than limit+1\n        if (self._published.size() !== self._limit + 1) {\n          throw new Error(\"After adding to published, \" +\n                          (self._published.size() - self._limit) +\n                          \" documents are overflowing the set\");\n        }\n\n        var overflowingDocId = self._published.maxElementId();\n        var overflowingDoc = self._published.get(overflowingDocId);\n\n        if (EJSON.equals(overflowingDocId, id)) {\n          throw new Error(\"The document just added is overflowing the published set\");\n        }\n\n        self._published.remove(overflowingDocId);\n        self._multiplexer.removed(overflowingDocId);\n        self._addBuffered(overflowingDocId, overflowingDoc);\n      }\n    });\n  },\n  _removePublished: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.remove(id);\n      self._multiplexer.removed(id);\n      if (! self._limit || self._published.size() === self._limit)\n        return;\n\n      if (self._published.size() > self._limit)\n        throw Error(\"self._published got too big\");\n\n      // OK, we are publishing less than the limit. Maybe we should look in the\n      // buffer to find the next element past what we were publishing before.\n\n      if (!self._unpublishedBuffer.empty()) {\n        // There's something in the buffer; move the first thing in it to\n        // _published.\n        var newDocId = self._unpublishedBuffer.minElementId();\n        var newDoc = self._unpublishedBuffer.get(newDocId);\n        self._removeBuffered(newDocId);\n        self._addPublished(newDocId, newDoc);\n        return;\n      }\n\n      // There's nothing in the buffer.  This could mean one of a few things.\n\n      // (a) We could be in the middle of re-running the query (specifically, we\n      // could be in _publishNewResults). In that case, _unpublishedBuffer is\n      // empty because we clear it at the beginning of _publishNewResults. In\n      // this case, our caller already knows the entire answer to the query and\n      // we don't need to do anything fancy here.  Just return.\n      if (self._phase === PHASE.QUERYING)\n        return;\n\n      // (b) We're pretty confident that the union of _published and\n      // _unpublishedBuffer contain all documents that match selector. Because\n      // _unpublishedBuffer is empty, that means we're confident that _published\n      // contains all documents that match selector. So we have nothing to do.\n      if (self._safeAppendToBuffer)\n        return;\n\n      // (c) Maybe there are other documents out there that should be in our\n      // buffer. But in that case, when we emptied _unpublishedBuffer in\n      // _removeBuffered, we should have called _needToPollQuery, which will\n      // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n      // (or both), and it will put us in QUERYING for that whole time. So in\n      // fact, we shouldn't be able to get here.\n\n      throw new Error(\"Buffer inexplicably empty\");\n    });\n  },\n  _changePublished: function (id, oldDoc, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.set(id, self._sharedProjectionFn(newDoc));\n      var projectedNew = self._projectionFn(newDoc);\n      var projectedOld = self._projectionFn(oldDoc);\n      var changed = DiffSequence.makeChangedFields(\n        projectedNew, projectedOld);\n      if (!isEmpty(changed))\n        self._multiplexer.changed(id, changed);\n    });\n  },\n  _addBuffered: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));\n\n      // If something is overflowing the buffer, we just remove it from cache\n      if (self._unpublishedBuffer.size() > self._limit) {\n        var maxBufferedId = self._unpublishedBuffer.maxElementId();\n\n        self._unpublishedBuffer.remove(maxBufferedId);\n\n        // Since something matching is removed from cache (both published set and\n        // buffer), set flag to false\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Is called either to remove the doc completely from matching set or to move\n  // it to the published set later.\n  _removeBuffered: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.remove(id);\n      // To keep the contract \"buffer is never empty in STEADY phase unless the\n      // everything matching fits into published\" true, we poll everything as\n      // soon as we see the buffer becoming empty.\n      if (! self._unpublishedBuffer.size() && ! self._safeAppendToBuffer)\n        self._needToPollQuery();\n    });\n  },\n  // Called when a document has joined the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _addMatching: function (doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = doc._id;\n      if (self._published.has(id))\n        throw Error(\"tried to add something already published \" + id);\n      if (self._limit && self._unpublishedBuffer.has(id))\n        throw Error(\"tried to add something already existed in buffer \" + id);\n\n      var limit = self._limit;\n      var comparator = self._comparator;\n      var maxPublished = (limit && self._published.size() > 0) ?\n        self._published.get(self._published.maxElementId()) : null;\n      var maxBuffered = (limit && self._unpublishedBuffer.size() > 0)\n        ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId())\n        : null;\n      // The query is unlimited or didn't publish enough documents yet or the\n      // new document would fit into published set pushing the maximum element\n      // out, then we need to publish the doc.\n      var toPublish = ! limit || self._published.size() < limit ||\n        comparator(doc, maxPublished) < 0;\n\n      // Otherwise we might need to buffer it (only in case of limited query).\n      // Buffering is allowed if the buffer is not filled up yet and all\n      // matching docs are either in the published set or in the buffer.\n      var canAppendToBuffer = !toPublish && self._safeAppendToBuffer &&\n        self._unpublishedBuffer.size() < limit;\n\n      // Or if it is small enough to be safely inserted to the middle or the\n      // beginning of the buffer.\n      var canInsertIntoBuffer = !toPublish && maxBuffered &&\n        comparator(doc, maxBuffered) <= 0;\n\n      var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n\n      if (toPublish) {\n        self._addPublished(id, doc);\n      } else if (toBuffer) {\n        self._addBuffered(id, doc);\n      } else {\n        // dropping it and not saving to the cache\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Called when a document leaves the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _removeMatching: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (! self._published.has(id) && ! self._limit)\n        throw Error(\"tried to remove something matching but not cached \" + id);\n\n      if (self._published.has(id)) {\n        self._removePublished(id);\n      } else if (self._unpublishedBuffer.has(id)) {\n        self._removeBuffered(id);\n      }\n    });\n  },\n  _handleDoc: function (id, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n\n      var publishedBefore = self._published.has(id);\n      var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n      var cachedBefore = publishedBefore || bufferedBefore;\n\n      if (matchesNow && !cachedBefore) {\n        self._addMatching(newDoc);\n      } else if (cachedBefore && !matchesNow) {\n        self._removeMatching(id);\n      } else if (cachedBefore && matchesNow) {\n        var oldDoc = self._published.get(id);\n        var comparator = self._comparator;\n        var minBuffered = self._limit && self._unpublishedBuffer.size() &&\n          self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n        var maxBuffered;\n\n        if (publishedBefore) {\n          // Unlimited case where the document stays in published once it\n          // matches or the case when we don't have enough matching docs to\n          // publish or the changed but matching doc will stay in published\n          // anyways.\n          //\n          // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n          // fact that buffer can't be empty if there are matching documents not\n          // published. Notably, we don't want to schedule repoll and continue\n          // relying on this property.\n          var staysInPublished = ! self._limit ||\n            self._unpublishedBuffer.size() === 0 ||\n            comparator(newDoc, minBuffered) <= 0;\n\n          if (staysInPublished) {\n            self._changePublished(id, oldDoc, newDoc);\n          } else {\n            // after the change doc doesn't stay in the published, remove it\n            self._removePublished(id);\n            // but it can move into buffered now, check it\n            maxBuffered = self._unpublishedBuffer.get(\n              self._unpublishedBuffer.maxElementId());\n\n            var toBuffer = self._safeAppendToBuffer ||\n                  (maxBuffered && comparator(newDoc, maxBuffered) <= 0);\n\n            if (toBuffer) {\n              self._addBuffered(id, newDoc);\n            } else {\n              // Throw away from both published set and buffer\n              self._safeAppendToBuffer = false;\n            }\n          }\n        } else if (bufferedBefore) {\n          oldDoc = self._unpublishedBuffer.get(id);\n          // remove the old version manually instead of using _removeBuffered so\n          // we don't trigger the querying immediately.  if we end this block\n          // with the buffer empty, we will need to trigger the query poll\n          // manually too.\n          self._unpublishedBuffer.remove(id);\n\n          var maxPublished = self._published.get(\n            self._published.maxElementId());\n          maxBuffered = self._unpublishedBuffer.size() &&\n                self._unpublishedBuffer.get(\n                  self._unpublishedBuffer.maxElementId());\n\n          // the buffered doc was updated, it could move to published\n          var toPublish = comparator(newDoc, maxPublished) < 0;\n\n          // or stays in buffer even after the change\n          var staysInBuffer = (! toPublish && self._safeAppendToBuffer) ||\n                (!toPublish && maxBuffered &&\n                 comparator(newDoc, maxBuffered) <= 0);\n\n          if (toPublish) {\n            self._addPublished(id, newDoc);\n          } else if (staysInBuffer) {\n            // stays in buffer but changes\n            self._unpublishedBuffer.set(id, newDoc);\n          } else {\n            // Throw away from both published set and buffer\n            self._safeAppendToBuffer = false;\n            // Normally this check would have been done in _removeBuffered but\n            // we didn't use it, so we need to do it ourself now.\n            if (! self._unpublishedBuffer.size()) {\n              self._needToPollQuery();\n            }\n          }\n        } else {\n          throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n        }\n      }\n    });\n  },\n  _fetchModifiedDocuments: function () {\n    var self = this;\n    self._registerPhaseChange(PHASE.FETCHING);\n    // Defer, because nothing called from the oplog entry handler may yield,\n    // but fetch() yields.\n    Meteor.defer(finishIfNeedToPollQuery(async function () {\n      while (!self._stopped && !self._needToFetch.empty()) {\n        if (self._phase === PHASE.QUERYING) {\n          // While fetching, we decided to go into QUERYING mode, and then we\n          // saw another oplog entry, so _needToFetch is not empty. But we\n          // shouldn't fetch these documents until AFTER the query is done.\n          break;\n        }\n\n        // Being in steady phase here would be surprising.\n        if (self._phase !== PHASE.FETCHING)\n          throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n\n        self._currentlyFetching = self._needToFetch;\n        var thisGeneration = ++self._fetchGeneration;\n        self._needToFetch = new LocalCollection._IdMap;\n\n        // Create an array of promises for all the fetch operations\n        const fetchPromises = [];\n\n        self._currentlyFetching.forEach(function (op, id) {\n          const fetchPromise = new Promise((resolve, reject) => {\n            self._mongoHandle._docFetcher.fetch(\n              self._cursorDescription.collectionName,\n              id,\n              op,\n              finishIfNeedToPollQuery(function(err, doc) {\n                if (err) {\n                  Meteor._debug('Got exception while fetching documents', err);\n                  // If we get an error from the fetcher (eg, trouble\n                  // connecting to Mongo), let's just abandon the fetch phase\n                  // altogether and fall back to polling. It's not like we're\n                  // getting live updates anyway.\n                  if (self._phase !== PHASE.QUERYING) {\n                    self._needToPollQuery();\n                  }\n                  resolve();\n                  return;\n                }\n\n                if (\n                  !self._stopped &&\n                  self._phase === PHASE.FETCHING &&\n                  self._fetchGeneration === thisGeneration\n                ) {\n                  // We re-check the generation in case we've had an explicit\n                  // _pollQuery call (eg, in another fiber) which should\n                  // effectively cancel this round of fetches.  (_pollQuery\n                  // increments the generation.)\n                  try {\n                    self._handleDoc(id, doc);\n                    resolve();\n                  } catch (err) {\n                    reject(err);\n                  }\n                } else {\n                  resolve();\n                }\n              })\n            )\n          })\n          fetchPromises.push(fetchPromise);\n        });\n        // Wait for all fetch operations to complete\n        try {\n          const results = await Promise.allSettled(fetchPromises);\n          const errors = results\n            .filter(result => result.status === 'rejected')\n            .map(result => result.reason);\n\n          if (errors.length > 0) {\n            Meteor._debug('Some fetch queries failed:', errors);\n          }\n        } catch (err) {\n          Meteor._debug('Got an exception in a fetch query', err);\n        }\n        // Exit now if we've had a _pollQuery call (here or in another fiber).\n        if (self._phase === PHASE.QUERYING)\n          return;\n        self._currentlyFetching = null;\n      }\n      // We're done fetching, so we can be steady, unless we've had a\n      // _pollQuery call (here or in another fiber).\n      if (self._phase !== PHASE.QUERYING)\n        await self._beSteady();\n    }));\n  },\n  _beSteady: async function () {\n    var self = this;\n    self._registerPhaseChange(PHASE.STEADY);\n    var writes = self._writesToCommitWhenWeReachSteady || [];\n    self._writesToCommitWhenWeReachSteady = [];\n    await self._multiplexer.onFlush(async function () {\n      try {\n        for (const w of writes) {\n          await w.committed();\n        }\n      } catch (e) {\n        console.error(\"_beSteady error\", {writes}, e);\n      }\n    });\n  },\n  _handleOplogEntryQuerying: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._needToFetch.set(idForOp(op), op);\n    });\n  },\n  _handleOplogEntrySteadyOrFetching: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = idForOp(op);\n      // If we're already fetching this one, or about to, we can't optimize;\n      // make sure that we fetch it again if necessary.\n\n      if (self._phase === PHASE.FETCHING &&\n          ((self._currentlyFetching && self._currentlyFetching.has(id)) ||\n           self._needToFetch.has(id))) {\n        self._needToFetch.set(id, op);\n        return;\n      }\n\n      if (op.op === 'd') {\n        if (self._published.has(id) ||\n            (self._limit && self._unpublishedBuffer.has(id)))\n          self._removeMatching(id);\n      } else if (op.op === 'i') {\n        if (self._published.has(id))\n          throw new Error(\"insert found for already-existing ID in published\");\n        if (self._unpublishedBuffer && self._unpublishedBuffer.has(id))\n          throw new Error(\"insert found for already-existing ID in buffer\");\n\n        // XXX what if selector yields?  for now it can't but later it could\n        // have $where\n        if (self._matcher.documentMatches(op.o).result)\n          self._addMatching(op.o);\n      } else if (op.op === 'u') {\n        // we are mapping the new oplog format on mongo 5\n        // to what we know better, $set\n        op.o = oplogV2V1Converter(op.o)\n        // Is this a modifier ($set/$unset, which may require us to poll the\n        // database to figure out if the whole document matches the selector) or\n        // a replacement (in which case we can just directly re-evaluate the\n        // selector)?\n        // oplog format has changed on mongodb 5, we have to support both now\n        // diff is the format in Mongo 5+ (oplog v2)\n        var isReplace = !has(op.o, '$set') && !has(op.o, 'diff') && !has(op.o, '$unset');\n        // If this modifier modifies something inside an EJSON custom type (ie,\n        // anything with EJSON$), then we can't try to use\n        // LocalCollection._modify, since that just mutates the EJSON encoding,\n        // not the actual object.\n        var canDirectlyModifyDoc =\n          !isReplace && modifierCanBeDirectlyApplied(op.o);\n\n        var publishedBefore = self._published.has(id);\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n\n        if (isReplace) {\n          self._handleDoc(id, Object.assign({_id: id}, op.o));\n        } else if ((publishedBefore || bufferedBefore) &&\n                   canDirectlyModifyDoc) {\n          // Oh great, we actually know what the document is, so we can apply\n          // this directly.\n          var newDoc = self._published.has(id)\n            ? self._published.get(id) : self._unpublishedBuffer.get(id);\n          newDoc = EJSON.clone(newDoc);\n\n          newDoc._id = id;\n          try {\n            LocalCollection._modify(newDoc, op.o);\n          } catch (e) {\n            if (e.name !== \"MinimongoError\")\n              throw e;\n            // We didn't understand the modifier.  Re-fetch.\n            self._needToFetch.set(id, op);\n            if (self._phase === PHASE.STEADY) {\n              self._fetchModifiedDocuments();\n            }\n            return;\n          }\n          self._handleDoc(id, self._sharedProjectionFn(newDoc));\n        } else if (!canDirectlyModifyDoc ||\n                   self._matcher.canBecomeTrueByModifier(op.o) ||\n                   (self._sorter && self._sorter.affectedByModifier(op.o))) {\n          self._needToFetch.set(id, op);\n          if (self._phase === PHASE.STEADY)\n            self._fetchModifiedDocuments();\n        }\n      } else {\n        throw Error(\"XXX SURPRISING OPERATION: \" + op);\n      }\n    });\n  },\n\n  async _runInitialQueryAsync() {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"oplog stopped surprisingly early\");\n\n    await self._runQuery({initial: true});  // yields\n\n    if (self._stopped)\n      return;  // can happen on queryError\n\n    // Allow observeChanges calls to return. (After this, it's possible for\n    // stop() to be called.)\n    await self._multiplexer.ready();\n\n    await self._doneQuerying();  // yields\n  },\n\n  // Yields!\n  _runInitialQuery: function () {\n    return this._runInitialQueryAsync();\n  },\n\n  // In various circumstances, we may just want to stop processing the oplog and\n  // re-run the initial query, just as if we were a PollingObserveDriver.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler.\n  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too\n  // long\".\n  //\n  // XXX We should call this when we detect Mongo failover (since that might\n  // mean that some of the oplog entries we have processed have been rolled\n  // back). The Node Mongo driver is in the middle of a bunch of huge\n  // refactorings, including the way that it notifies you when primary\n  // changes. Will put off implementing this until driver 1.4 is out.\n  _pollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // Yay, we get to forget about all the things we thought we had to fetch.\n      self._needToFetch = new LocalCollection._IdMap;\n      self._currentlyFetching = null;\n      ++self._fetchGeneration;  // ignore any in-flight fetches\n      self._registerPhaseChange(PHASE.QUERYING);\n\n      // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n      // here because SwitchedToQuery is not thrown in QUERYING mode.\n      Meteor.defer(async function () {\n        await self._runQuery();\n        await self._doneQuerying();\n      });\n    });\n  },\n\n  // Yields!\n  async _runQueryAsync(options) {\n    var self = this;\n    options = options || {};\n    var newResults, newBuffer;\n\n    // This while loop is just to retry failures.\n    while (true) {\n      // If we've been stopped, we don't have to run anything any more.\n      if (self._stopped)\n        return;\n\n      newResults = new LocalCollection._IdMap;\n      newBuffer = new LocalCollection._IdMap;\n\n      // Query 2x documents as the half excluded from the original query will go\n      // into unpublished buffer to reduce additional Mongo lookups in cases\n      // when documents are removed from the published set and need a\n      // replacement.\n      // XXX needs more thought on non-zero skip\n      // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n      // buffer if such is needed.\n      var cursor = self._cursorForQuery({ limit: self._limit * 2 });\n      try {\n        await cursor.forEach(function (doc, i) {  // yields\n          if (!self._limit || i < self._limit) {\n            newResults.set(doc._id, doc);\n          } else {\n            newBuffer.set(doc._id, doc);\n          }\n        });\n        break;\n      } catch (e) {\n        if (options.initial && typeof(e.code) === 'number') {\n          // This is an error document sent to us by mongod, not a connection\n          // error generated by the client. And we've never seen this query work\n          // successfully. Probably it's a bad selector or something, so we\n          // should NOT retry. Instead, we should halt the observe (which ends\n          // up calling `stop` on us).\n          await self._multiplexer.queryError(e);\n          return;\n        }\n\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while polling query\", e);\n        await Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    self._publishNewResults(newResults, newBuffer);\n  },\n\n  // Yields!\n  _runQuery: function (options) {\n    return this._runQueryAsync(options);\n  },\n\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n  // ensures that we will query again later.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler. However, if we were not already in the QUERYING phase, it throws\n  // an exception that is caught by the closest surrounding\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running\n  // close that was designed for another phase inside PHASE.QUERYING.\n  //\n  // (It's also necessary whenever logic in this file yields to check that other\n  // phases haven't put us into QUERYING mode, though; eg,\n  // _fetchModifiedDocuments does this.)\n  _needToPollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // If we're not already in the middle of a query, we can query now\n      // (possibly pausing FETCHING).\n      if (self._phase !== PHASE.QUERYING) {\n        self._pollQuery();\n        throw new SwitchedToQuery;\n      }\n\n      // We're currently in QUERYING. Set a flag to ensure that we run another\n      // query when we're done.\n      self._requeryWhenDoneThisQuery = true;\n    });\n  },\n\n  // Yields!\n  _doneQuerying: async function () {\n    var self = this;\n\n    if (self._stopped)\n      return;\n\n    await self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n\n    if (self._stopped)\n      return;\n\n    if (self._phase !== PHASE.QUERYING)\n      throw Error(\"Phase unexpectedly \" + self._phase);\n\n    if (self._requeryWhenDoneThisQuery) {\n      self._requeryWhenDoneThisQuery = false;\n      self._pollQuery();\n    } else if (self._needToFetch.empty()) {\n      await self._beSteady();\n    } else {\n      self._fetchModifiedDocuments();\n    }\n  },\n\n  _cursorForQuery: function (optionsOverwrite) {\n    var self = this;\n    return Meteor._noYieldsAllowed(function () {\n      // The query we run is almost the same as the cursor we are observing,\n      // with a few changes. We need to read all the fields that are relevant to\n      // the selector, not just the fields we are going to publish (that's the\n      // \"shared\" projection). And we don't want to apply any transform in the\n      // cursor, because observeChanges shouldn't use the transform.\n      var options = Object.assign({}, self._cursorDescription.options);\n\n      // Allow the caller to modify the options. Useful to specify different\n      // skip and limit values.\n      Object.assign(options, optionsOverwrite);\n\n      options.fields = self._sharedProjection;\n      delete options.transform;\n      // We are NOT deep cloning fields or selector here, which should be OK.\n      var description = new CursorDescription(\n        self._cursorDescription.collectionName,\n        self._cursorDescription.selector,\n        options);\n      return new Cursor(self._mongoHandle, description);\n    });\n  },\n\n\n  // Replace self._published with newResults (both are IdMaps), invoking observe\n  // callbacks on the multiplexer.\n  // Replace self._unpublishedBuffer with newBuffer.\n  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n  _publishNewResults: function (newResults, newBuffer) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n\n      // If the query is limited and there is a buffer, shut down so it doesn't\n      // stay in a way.\n      if (self._limit) {\n        self._unpublishedBuffer.clear();\n      }\n\n      // First remove anything that's gone. Be careful not to modify\n      // self._published while iterating over it.\n      var idsToRemove = [];\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          idsToRemove.push(id);\n      });\n      idsToRemove.forEach(function (id) {\n        self._removePublished(id);\n      });\n\n      // Now do adds and changes.\n      // If self has a buffer and limit, the new fetched result will be\n      // limited correctly as the query has sort specifier.\n      newResults.forEach(function (doc, id) {\n        self._handleDoc(id, doc);\n      });\n\n      // Sanity-check that everything we tried to put into _published ended up\n      // there.\n      // XXX if this is slow, remove it later\n      if (self._published.size() !== newResults.size()) {\n        Meteor._debug('The Mongo server and the Meteor query disagree on how ' +\n          'many documents match your query. Cursor description: ',\n          self._cursorDescription);\n      }\n      \n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          throw Error(\"_published has a doc that newResults doesn't; \" + id);\n      });\n\n      // Finally, replace the buffer\n      newBuffer.forEach(function (doc, id) {\n        self._addBuffered(id, doc);\n      });\n\n      self._safeAppendToBuffer = newBuffer.size() < self._limit;\n    });\n  },\n\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n  // it shouldn't actually be possible to call it until the multiplexer is\n  // ready.\n  //\n  // It's important to check self._stopped after every call in this file that\n  // can yield!\n  _stop: async function() {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n\n    // Note: we *don't* use multiplexer.onFlush here because this stop\n    // callback is actually invoked by the multiplexer itself when it has\n    // determined that there are no handles left. So nothing is actually going\n    // to get flushed (and it's probably not valid to call methods on the\n    // dying multiplexer).\n    for (const w of self._writesToCommitWhenWeReachSteady) {\n      await w.committed();\n    }\n    self._writesToCommitWhenWeReachSteady = null;\n\n    // Proactively drop references to potentially big things.\n    self._published = null;\n    self._unpublishedBuffer = null;\n    self._needToFetch = null;\n    self._currentlyFetching = null;\n    self._oplogEntryHandle = null;\n    self._listenersHandle = null;\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n        \"mongo-livedata\", \"observe-drivers-oplog\", -1);\n\n    for await (const handle of self._stopHandles) {\n      await handle.stop();\n    }\n  },\n  stop: async function() {\n    const self = this;\n    return await self._stop();\n  },\n\n  _registerPhaseChange: function (phase) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var now = new Date;\n\n      if (self._phase) {\n        var timeDiff = now - self._phaseStartTime;\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n          \"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n      }\n\n      self._phase = phase;\n      self._phaseStartTime = now;\n    });\n  }\n});\n\n// Does our oplog tailing code support this cursor? For now, we are being very\n// conservative and allowing only simple queries with simple options.\n// (This is a \"static method\".)\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n  // First, check the options.\n  var options = cursorDescription.options;\n\n  // Did the user say no explicitly?\n  // underscored version of the option is COMPAT with 1.2\n  if (options.disableOplog || options._disableOplog)\n    return false;\n\n  // skip is not supported: to support it we would need to keep track of all\n  // \"skipped\" documents or at least their ids.\n  // limit w/o a sort specifier is not supported: current implementation needs a\n  // deterministic way to order documents.\n  if (options.skip || (options.limit && !options.sort)) return false;\n\n  // If a fields projection option is given check if it is supported by\n  // minimongo (some operators are not supported).\n  const fields = options.fields || options.projection;\n  if (fields) {\n    try {\n      LocalCollection._checkSupportedProjection(fields);\n    } catch (e) {\n      if (e.name === \"MinimongoError\") {\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // We don't allow the following selectors:\n  //   - $where (not confident that we provide the same JS environment\n  //             as Mongo, and can yield!)\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n  //            of returning an ID multiple times, though even polling maybe\n  //            have a bug there)\n  //           XXX: once we support it, we would need to think more on how we\n  //           initialize the comparators when we create the driver.\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();\n};\n\nvar modifierCanBeDirectlyApplied = function (modifier) {\n  return Object.entries(modifier).every(function ([operation, fields]) {\n    return Object.entries(fields).every(function ([field, value]) {\n      return !/EJSON\\$/.test(field);\n    });\n  });\n};"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"39129e497da8ddc6067cb8cc7cd280d2b15e5155"}

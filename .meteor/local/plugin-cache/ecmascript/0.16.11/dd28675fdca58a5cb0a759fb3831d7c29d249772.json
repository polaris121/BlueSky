{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/ddp-client/common/message_processors.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-client/common/message_processors.js"}},"code":"module.export({\n  MessageProcessors: () => MessageProcessors\n});\nlet DDPCommon;\nmodule.link(\"meteor/ddp-common\", {\n  DDPCommon(v) {\n    DDPCommon = v;\n  }\n}, 0);\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n}, 1);\nlet DDP;\nmodule.link(\"./namespace.js\", {\n  DDP(v) {\n    DDP = v;\n  }\n}, 2);\nlet EJSON;\nmodule.link(\"meteor/ejson\", {\n  EJSON(v) {\n    EJSON = v;\n  }\n}, 3);\nlet isEmpty, hasOwn;\nmodule.link(\"meteor/ddp-common/utils\", {\n  isEmpty(v) {\n    isEmpty = v;\n  },\n  hasOwn(v) {\n    hasOwn = v;\n  }\n}, 4);\nclass MessageProcessors {\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process the connection message and set up the session\n   * @param {Object} msg The connection message\n   */\n  async _livedata_connected(msg) {\n    const self = this._connection;\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout() {\n          self._lostConnection(new DDP.ConnectionError('DDP heartbeat timed out'));\n        },\n        sendPing() {\n          self._send({\n            msg: 'ping'\n          });\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId) self._resetStores = true;\n    let reconnectedToPreviousSession;\n    if (typeof msg.session === 'string') {\n      reconnectedToPreviousSession = self._lastSessionId === msg.session;\n      self._lastSessionId = msg.session;\n    }\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.\n      return;\n    }\n\n    // Server doesn't have our data anymore. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = Object.create(null);\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = Object.create(null);\n      self._serverDocuments = Object.create(null);\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready as needing to be revived.\n    self._subsBeingRevived = Object.create(null);\n    Object.entries(self._subscriptions).forEach(_ref => {\n      let [id, sub] = _ref;\n      if (sub.ready) {\n        self._subsBeingRevived[id] = true;\n      }\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = Object.create(null);\n    if (self._resetStores) {\n      const invokers = self._methodInvokers;\n      Object.keys(invokers).forEach(id => {\n        const invoker = invokers[id];\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(function () {\n            return invoker.dataVisible(...arguments);\n          });\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        for (const store of Object.values(self._stores)) {\n          await store.beginUpdate(0, true);\n          await store.endUpdate();\n        }\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  }\n\n  /**\n   * @summary Process various data messages from the server\n   * @param {Object} msg The data message\n   */\n  async _livedata_data(msg) {\n    const self = this._connection;\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n      if (msg.msg === 'nosub') {\n        delete self._subsBeingRevived[msg.id];\n      }\n      if (msg.subs) {\n        msg.subs.forEach(subId => {\n          delete self._subsBeingRevived[subId];\n        });\n      }\n      if (msg.methods) {\n        msg.methods.forEach(methodId => {\n          delete self._methodsBlockingQuiescence[methodId];\n        });\n      }\n      if (self._waitingForQuiescence()) {\n        return;\n      }\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      const bufferedMessages = self._messagesBufferedUntilQuiescence;\n      for (const bufferedMessage of Object.values(bufferedMessages)) {\n        await this._processOneDataMessage(bufferedMessage, self._bufferedWrites);\n      }\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      await this._processOneDataMessage(msg, self._bufferedWrites);\n    }\n\n    // Immediately flush writes when:\n    //  1. Buffering is disabled. Or;\n    //  2. any non-(added/changed/removed) message arrives.\n    const standardWrite = msg.msg === \"added\" || msg.msg === \"changed\" || msg.msg === \"removed\";\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n      await self._flushBufferedWrites();\n      return;\n    }\n    if (self._bufferedWritesFlushAt === null) {\n      self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n    } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n      await self._flushBufferedWrites();\n      return;\n    }\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n    }\n    self._bufferedWritesFlushHandle = setTimeout(() => {\n      self._liveDataWritesPromise = self._flushBufferedWrites();\n      if (Meteor._isPromise(self._liveDataWritesPromise)) {\n        self._liveDataWritesPromise.finally(() => self._liveDataWritesPromise = undefined);\n      }\n    }, self._bufferedWritesInterval);\n  }\n\n  /**\n   * @summary Process individual data messages by type\n   * @private\n   */\n  async _processOneDataMessage(msg, updates) {\n    const messageType = msg.msg;\n    switch (messageType) {\n      case 'added':\n        await this._connection._process_added(msg, updates);\n        break;\n      case 'changed':\n        this._connection._process_changed(msg, updates);\n        break;\n      case 'removed':\n        this._connection._process_removed(msg, updates);\n        break;\n      case 'ready':\n        this._connection._process_ready(msg, updates);\n        break;\n      case 'updated':\n        this._connection._process_updated(msg, updates);\n        break;\n      case 'nosub':\n        // ignore this\n        break;\n      default:\n        Meteor._debug('discarding unknown livedata data message type', msg);\n    }\n  }\n\n  /**\n   * @summary Handle method results arriving from the server\n   * @param {Object} msg The method result message\n   */\n  async _livedata_result(msg) {\n    const self = this._connection;\n\n    // Lets make sure there are no buffered writes before returning result.\n    if (!isEmpty(self._bufferedWrites)) {\n      await self._flushBufferedWrites();\n    }\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug('Received method result but no methods outstanding');\n      return;\n    }\n    const currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    let i;\n    const m = currentMethodBlock.find((method, idx) => {\n      const found = method.methodId === msg.id;\n      if (found) i = idx;\n      return found;\n    });\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n    if (hasOwn.call(msg, 'error')) {\n      m.receiveResult(new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details));\n    } else {\n      // msg.result may be undefined if the method didn't return a value\n      m.receiveResult(undefined, msg.result);\n    }\n  }\n\n  /**\n   * @summary Handle \"nosub\" messages arriving from the server\n   * @param {Object} msg The nosub message\n   */\n  async _livedata_nosub(msg) {\n    const self = this._connection;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    await this._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!hasOwn.call(self._subscriptions, msg.id)) {\n      return;\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    const errorCallback = self._subscriptions[msg.id].errorCallback;\n    const stopCallback = self._subscriptions[msg.id].stopCallback;\n    self._subscriptions[msg.id].remove();\n    const meteorErrorFromMsg = msgArg => {\n      return msgArg && msgArg.error && new Meteor.Error(msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n    };\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  }\n\n  /**\n   * @summary Handle errors from the server\n   * @param {Object} msg The error message\n   */\n  _livedata_error(msg) {\n    Meteor._debug('Received error from server: ', msg.reason);\n    if (msg.offendingMessage) Meteor._debug('For: ', msg.offendingMessage);\n  }\n\n  // Document change message processors will be defined in a separate class\n}","map":{"version":3,"names":["module","export","MessageProcessors","DDPCommon","link","v","Meteor","DDP","EJSON","isEmpty","hasOwn","constructor","connection","_connection","_livedata_connected","msg","self","_version","_heartbeatInterval","_heartbeat","Heartbeat","heartbeatInterval","heartbeatTimeout","_heartbeatTimeout","onTimeout","_lostConnection","ConnectionError","sendPing","_send","start","_lastSessionId","_resetStores","reconnectedToPreviousSession","session","_updatesForUnknownStores","Object","create","_documentsWrittenByStub","_serverDocuments","_afterUpdateCallbacks","_subsBeingRevived","entries","_subscriptions","forEach","_ref","id","sub","ready","_methodsBlockingQuiescence","invokers","_methodInvokers","keys","invoker","gotResult","push","dataVisible","arguments","sentMessage","methodId","_messagesBufferedUntilQuiescence","_waitingForQuiescence","store","values","_stores","beginUpdate","endUpdate","_runAfterUpdateCallbacks","_livedata_data","subs","subId","methods","bufferedMessages","bufferedMessage","_processOneDataMessage","_bufferedWrites","standardWrite","_bufferedWritesInterval","_flushBufferedWrites","_bufferedWritesFlushAt","Date","valueOf","_bufferedWritesMaxAge","_bufferedWritesFlushHandle","clearTimeout","setTimeout","_liveDataWritesPromise","_isPromise","finally","undefined","updates","messageType","_process_added","_process_changed","_process_removed","_process_ready","_process_updated","_debug","_livedata_result","_outstandingMethodBlocks","currentMethodBlock","i","m","find","method","idx","found","splice","call","receiveResult","Error","error","reason","details","result","_livedata_nosub","errorCallback","stopCallback","remove","meteorErrorFromMsg","msgArg","_livedata_error","offendingMessage"],"sources":["packages/ddp-client/common/message_processors.js"],"sourcesContent":["import { DDPCommon } from 'meteor/ddp-common';\nimport { Meteor } from 'meteor/meteor';\nimport { DDP } from './namespace.js';\nimport { EJSON } from 'meteor/ejson';\nimport { isEmpty, hasOwn } from \"meteor/ddp-common/utils\";\n\nexport class MessageProcessors {\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process the connection message and set up the session\n   * @param {Object} msg The connection message\n   */\n  async _livedata_connected(msg) {\n    const self = this._connection;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout() {\n          self._lostConnection(\n            new DDP.ConnectionError('DDP heartbeat timed out')\n          );\n        },\n        sendPing() {\n          self._send({ msg: 'ping' });\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId) self._resetStores = true;\n\n    let reconnectedToPreviousSession;\n    if (typeof msg.session === 'string') {\n      reconnectedToPreviousSession = self._lastSessionId === msg.session;\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.\n      return;\n    }\n\n    // Server doesn't have our data anymore. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = Object.create(null);\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = Object.create(null);\n      self._serverDocuments = Object.create(null);\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready as needing to be revived.\n    self._subsBeingRevived = Object.create(null);\n    Object.entries(self._subscriptions).forEach(([id, sub]) => {\n      if (sub.ready) {\n        self._subsBeingRevived[id] = true;\n      }\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = Object.create(null);\n    if (self._resetStores) {\n      const invokers = self._methodInvokers;\n      Object.keys(invokers).forEach(id => {\n        const invoker = invokers[id];\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(\n            (...args) => invoker.dataVisible(...args)\n          );\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        for (const store of Object.values(self._stores)) {\n          await store.beginUpdate(0, true);\n          await store.endUpdate();\n        }\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  }\n\n  /**\n   * @summary Process various data messages from the server\n   * @param {Object} msg The data message\n   */\n  async _livedata_data(msg) {\n    const self = this._connection;\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === 'nosub') {\n        delete self._subsBeingRevived[msg.id];\n      }\n\n      if (msg.subs) {\n        msg.subs.forEach(subId => {\n          delete self._subsBeingRevived[subId];\n        });\n      }\n\n      if (msg.methods) {\n        msg.methods.forEach(methodId => {\n          delete self._methodsBlockingQuiescence[methodId];\n        });\n      }\n\n      if (self._waitingForQuiescence()) {\n        return;\n      }\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      const bufferedMessages = self._messagesBufferedUntilQuiescence;\n      for (const bufferedMessage of Object.values(bufferedMessages)) {\n        await this._processOneDataMessage(\n          bufferedMessage,\n          self._bufferedWrites\n        );\n      }\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      await this._processOneDataMessage(msg, self._bufferedWrites);\n    }\n\n    // Immediately flush writes when:\n    //  1. Buffering is disabled. Or;\n    //  2. any non-(added/changed/removed) message arrives.\n    const standardWrite =\n      msg.msg === \"added\" ||\n      msg.msg === \"changed\" ||\n      msg.msg === \"removed\";\n\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n      await self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushAt === null) {\n      self._bufferedWritesFlushAt =\n        new Date().valueOf() + self._bufferedWritesMaxAge;\n    } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n      await self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n    }\n    self._bufferedWritesFlushHandle = setTimeout(() => {\n      self._liveDataWritesPromise = self._flushBufferedWrites();\n      if (Meteor._isPromise(self._liveDataWritesPromise)) {\n        self._liveDataWritesPromise.finally(\n          () => (self._liveDataWritesPromise = undefined)\n        );\n      }\n    }, self._bufferedWritesInterval);\n  }\n\n  /**\n   * @summary Process individual data messages by type\n   * @private\n   */\n  async _processOneDataMessage(msg, updates) {\n    const messageType = msg.msg;\n\n    switch (messageType) {\n      case 'added':\n        await this._connection._process_added(msg, updates);\n        break;\n      case 'changed':\n        this._connection._process_changed(msg, updates);\n        break;\n      case 'removed':\n        this._connection._process_removed(msg, updates);\n        break;\n      case 'ready':\n        this._connection._process_ready(msg, updates);\n        break;\n      case 'updated':\n        this._connection._process_updated(msg, updates);\n        break;\n      case 'nosub':\n        // ignore this\n        break;\n      default:\n        Meteor._debug('discarding unknown livedata data message type', msg);\n    }\n  }\n\n  /**\n   * @summary Handle method results arriving from the server\n   * @param {Object} msg The method result message\n   */\n  async _livedata_result(msg) {\n    const self = this._connection;\n\n    // Lets make sure there are no buffered writes before returning result.\n    if (!isEmpty(self._bufferedWrites)) {\n      await self._flushBufferedWrites();\n    }\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug('Received method result but no methods outstanding');\n      return;\n    }\n    const currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    let i;\n    const m = currentMethodBlock.find((method, idx) => {\n      const found = method.methodId === msg.id;\n      if (found) i = idx;\n      return found;\n    });\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n\n    if (hasOwn.call(msg, 'error')) {\n      m.receiveResult(\n        new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details)\n      );\n    } else {\n      // msg.result may be undefined if the method didn't return a value\n      m.receiveResult(undefined, msg.result);\n    }\n  }\n\n  /**\n   * @summary Handle \"nosub\" messages arriving from the server\n   * @param {Object} msg The nosub message\n   */\n  async _livedata_nosub(msg) {\n    const self = this._connection;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    await this._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!hasOwn.call(self._subscriptions, msg.id)) {\n      return;\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    const errorCallback = self._subscriptions[msg.id].errorCallback;\n    const stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    const meteorErrorFromMsg = msgArg => {\n      return (\n        msgArg &&\n        msgArg.error &&\n        new Meteor.Error(\n          msgArg.error.error,\n          msgArg.error.reason,\n          msgArg.error.details\n        )\n      );\n    };\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  }\n\n  /**\n   * @summary Handle errors from the server\n   * @param {Object} msg The error message\n   */\n  _livedata_error(msg) {\n    Meteor._debug('Received error from server: ', msg.reason);\n    if (msg.offendingMessage) Meteor._debug('For: ', msg.offendingMessage);\n  }\n\n  // Document change message processors will be defined in a separate class\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"dd28675fdca58a5cb0a759fb3831d7c29d249772"}

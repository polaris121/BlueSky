{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\allow-deny\\allow-deny.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/allow-deny/allow-deny.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\allow-deny\\allow-deny.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\allow-deny\\allow-deny.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/allow-deny/allow-deny.js"}},"code":"var _regeneratorRuntime;\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 0);\nvar _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default: function (v) {\n    _objectSpread = v;\n  }\n}, 1);\nvar _createForOfIteratorHelperLoose;\nmodule.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\", {\n  default: function (v) {\n    _createForOfIteratorHelperLoose = v;\n  }\n}, 2);\n///\n/// Remote methods and access control.\n///\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// Restrict default mutators on collection. allow() and deny() take the\n// same options:\n//\n// options.insertAsync {Function(userId, doc)}\n//   return true to allow/deny adding this document\n//\n// options.updateAsync {Function(userId, docs, fields, modifier)}\n//   return true to allow/deny updating these documents.\n//   `fields` is passed as an array of fields that are to be modified\n//\n// options.removeAsync {Function(userId, docs)}\n//   return true to allow/deny removing these documents\n//\n// options.fetch {Array}\n//   Fields to fetch for these validators. If any call to allow or deny\n//   does not have this option then all fields are loaded.\n//\n// allow and deny can be called multiple times. The validators are\n// evaluated as follows:\n// - If neither deny() nor allow() has been called on the collection,\n//   then the request is allowed if and only if the \"insecure\" smart\n//   package is in use.\n// - Otherwise, if any deny() function returns true, the request is denied.\n// - Otherwise, if any allow() function returns true, the request is allowed.\n// - Otherwise, the request is denied.\n//\n// Meteor may call your deny() and allow() functions in any order, and may not\n// call all of them if it is able to make a decision without calling them all\n// (so don't include side effects).\n\nAllowDeny = {\n  CollectionPrototype: {}\n};\n\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\n// methods\nvar CollectionPrototype = AllowDeny.CollectionPrototype;\n\n/**\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server\n * @method allow\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.allow = function (options) {\n  addValidator(this, 'allow', options);\n};\n\n/**\n * @summary Override `allow` rules.\n * @locus Server\n * @method deny\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.deny = function (options) {\n  addValidator(this, 'deny', options);\n};\nCollectionPrototype._defineMutationMethods = function (options) {\n  var self = this;\n  options = options || {};\n\n  // set to true once we call any allow or deny methods. If true, use\n  // allow/deny semantics. If false, use insecure mode semantics.\n  self._restricted = false;\n\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\n  // means insecure iff the insecure package is loaded. This property can be\n  // overriden by tests or packages wishing to change insecure mode behavior of\n  // their collections.\n  self._insecure = undefined;\n  self._validators = {\n    insert: {\n      allow: [],\n      deny: []\n    },\n    update: {\n      allow: [],\n      deny: []\n    },\n    remove: {\n      allow: [],\n      deny: []\n    },\n    insertAsync: {\n      allow: [],\n      deny: []\n    },\n    updateAsync: {\n      allow: [],\n      deny: []\n    },\n    removeAsync: {\n      allow: [],\n      deny: []\n    },\n    upsertAsync: {\n      allow: [],\n      deny: []\n    },\n    // dummy arrays; can't set these!\n    fetch: [],\n    fetchAllFields: false\n  };\n  if (!self._name) return; // anonymous collection\n\n  // XXX Think about method namespacing. Maybe methods should be\n  // \"Meteor:Mongo:insertAsync/NAME\"?\n  self._prefix = '/' + self._name + '/';\n\n  // Mutation Methods\n  // Minimongo on the server gets no stubs; instead, by default\n  // it wait()s until its result is ready, yielding.\n  // This matches the behavior of macromongo on the server better.\n  // XXX see #MeteorServerNull\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\n    var m = {};\n    ['insertAsync', 'updateAsync', 'removeAsync', 'insert', 'update', 'remove'].forEach(function (method) {\n      var methodName = self._prefix + method;\n      if (options.useExisting) {\n        var handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers';\n        // Do not try to create additional methods if this has already been called.\n        // (Otherwise the .methods() call below will throw an error.)\n        if (self._connection[handlerPropName] && typeof self._connection[handlerPropName][methodName] === 'function') return;\n      }\n      var isInsert = function (name) {\n        return name.includes('insert');\n      };\n      m[methodName] = function /* ... */\n      () {\n        // All the methods do their own validation, instead of using check().\n        check(arguments, [Match.Any]);\n        var args = Array.from(arguments);\n        try {\n          // For an insert/insertAsync, if the client didn't specify an _id, generate one\n          // now; because this uses DDP.randomStream, it will be consistent with\n          // what the client generated. We generate it now rather than later so\n          // that if (eg) an allow/deny rule does an insert/insertAsync to the same\n          // collection (not that it really should), the generated _id will\n          // still be the first use of the stream and will be consistent.\n          //\n          // However, we don't actually stick the _id onto the document yet,\n          // because we want allow/deny rules to be able to differentiate\n          // between arbitrary client-specified _id fields and merely\n          // client-controlled-via-randomSeed fields.\n          var generatedId = null;\n          if (isInsert(method) && !hasOwn.call(args[0], '_id')) {\n            generatedId = self._makeNewID();\n          }\n          if (this.isSimulation) {\n            // In a client simulation, you can do any mutation (even with a\n            // complex selector).\n            if (generatedId !== null) {\n              args[0]._id = generatedId;\n            }\n            return self._collection[method].apply(self._collection, args);\n          }\n\n          // This is the server receiving a method call from the client.\n\n          // We don't allow arbitrary selectors in mutations from the client: only\n          // single-ID selectors.\n          if (!isInsert(method)) throwIfSelectorIsNotId(args[0], method);\n          var syncMethodName = method.replace('Async', '');\n          var syncValidatedMethodName = '_validated' + method.charAt(0).toUpperCase() + syncMethodName.slice(1);\n          // it forces to use async validated behavior\n          var validatedMethodName = syncValidatedMethodName + 'Async';\n          if (self._restricted) {\n            // short circuit if there is no way it will pass.\n            if (self._validators[syncMethodName].allow.length === 0) {\n              throw new Meteor.Error(403, 'Access denied. No allow validators set on restricted ' + \"collection for method '\" + method + \"'.\");\n            }\n            args.unshift(this.userId);\n            isInsert(method) && args.push(generatedId);\n            return self[validatedMethodName].apply(self, args);\n          } else if (self._isInsecure()) {\n            if (generatedId !== null) args[0]._id = generatedId;\n            // In insecure mode we use the server _collection methods, and these sync methods\n            // do not exist in the server anymore, so we have this mapper to call the async methods\n            // instead.\n            var syncMethodsMapper = {\n              insert: \"insertAsync\",\n              update: \"updateAsync\",\n              remove: \"removeAsync\"\n            };\n\n            // In insecure mode, allow any mutation (with a simple selector).\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\n            //     we get from the network to this function, we should actually\n            //     know the correct arguments for the function and pass just\n            //     them.  For example, if you have an extraneous extra null\n            //     argument and this is Mongo on the server, the .wrapAsync'd\n            //     functions like update will get confused and pass the\n            //     \"fut.resolver()\" in the wrong slot, where _update will never\n            //     invoke it. Bam, broken DDP connection.  Probably should just\n            //     take this whole method and write it three times, invoking\n            //     helpers for the common code.\n            return self._collection[syncMethodsMapper[method] || method].apply(self._collection, args);\n          } else {\n            // In secure mode, if we haven't called allow or deny, then nothing\n            // is permitted.\n            throw new Meteor.Error(403, 'Access denied');\n          }\n        } catch (e) {\n          if (e.name === 'MongoError' ||\n          // for old versions of MongoDB (probably not necessary but it's here just in case)\n          e.name === 'BulkWriteError' ||\n          // for newer versions of MongoDB (https://docs.mongodb.com/drivers/node/current/whats-new/#bulkwriteerror---mongobulkwriteerror)\n          e.name === 'MongoBulkWriteError' || e.name === 'MinimongoError') {\n            throw new Meteor.Error(409, e.toString());\n          } else {\n            throw e;\n          }\n        }\n      };\n    });\n    self._connection.methods(m);\n  }\n};\nCollectionPrototype._updateFetch = function (fields) {\n  var self = this;\n  if (!self._validators.fetchAllFields) {\n    if (fields) {\n      var union = Object.create(null);\n      var add = function (names) {\n        return names && names.forEach(function (name) {\n          return union[name] = 1;\n        });\n      };\n      add(self._validators.fetch);\n      add(fields);\n      self._validators.fetch = Object.keys(union);\n    } else {\n      self._validators.fetchAllFields = true;\n      // clear fetch just to make sure we don't accidentally read it\n      self._validators.fetch = null;\n    }\n  }\n};\nCollectionPrototype._isInsecure = function () {\n  var self = this;\n  if (self._insecure === undefined) return !!Package.insecure;\n  return self._insecure;\n};\nfunction asyncSome(array, predicate) {\n  var _iterator, _step, item;\n  return _regeneratorRuntime.async(function (_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        _iterator = _createForOfIteratorHelperLoose(array);\n      case 1:\n        if ((_step = _iterator()).done) {\n          _context.next = 4;\n          break;\n        }\n        item = _step.value;\n        _context.next = 2;\n        return _regeneratorRuntime.awrap(predicate(item));\n      case 2:\n        if (!_context.sent) {\n          _context.next = 3;\n          break;\n        }\n        return _context.abrupt(\"return\", true);\n      case 3:\n        _context.next = 1;\n        break;\n      case 4:\n        return _context.abrupt(\"return\", false);\n      case 5:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction asyncEvery(array, predicate) {\n  var _iterator2, _step2, item;\n  return _regeneratorRuntime.async(function (_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        _iterator2 = _createForOfIteratorHelperLoose(array);\n      case 1:\n        if ((_step2 = _iterator2()).done) {\n          _context2.next = 4;\n          break;\n        }\n        item = _step2.value;\n        _context2.next = 2;\n        return _regeneratorRuntime.awrap(predicate(item));\n      case 2:\n        if (_context2.sent) {\n          _context2.next = 3;\n          break;\n        }\n        return _context2.abrupt(\"return\", false);\n      case 3:\n        _context2.next = 1;\n        break;\n      case 4:\n        return _context2.abrupt(\"return\", true);\n      case 5:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, null, null, null, Promise);\n}\nCollectionPrototype._validatedInsertAsync = function () {\n  function _callee3(userId, doc, generatedId) {\n    var self;\n    return _regeneratorRuntime.async(function (_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          self = this; // call user validators.\n          // Any deny returns true means denied.\n          _context5.next = 1;\n          return _regeneratorRuntime.awrap(asyncSome(self._validators.insert.deny, function () {\n            function _callee(validator) {\n              var result, _t;\n              return _regeneratorRuntime.async(function (_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    result = validator(userId, docToValidate(validator, doc, generatedId));\n                    if (!Meteor._isPromise(result)) {\n                      _context3.next = 2;\n                      break;\n                    }\n                    _context3.next = 1;\n                    return _regeneratorRuntime.awrap(result);\n                  case 1:\n                    _t = _context3.sent;\n                    _context3.next = 3;\n                    break;\n                  case 2:\n                    _t = result;\n                  case 3:\n                    return _context3.abrupt(\"return\", _t);\n                  case 4:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, null, null, null, Promise);\n            }\n            return _callee;\n          }()));\n        case 1:\n          if (!_context5.sent) {\n            _context5.next = 2;\n            break;\n          }\n          throw new Meteor.Error(403, \"Access denied\");\n        case 2:\n          _context5.next = 3;\n          return _regeneratorRuntime.awrap(asyncEvery(self._validators.insert.allow, function () {\n            function _callee2(validator) {\n              var result, _t2;\n              return _regeneratorRuntime.async(function (_context4) {\n                while (1) switch (_context4.prev = _context4.next) {\n                  case 0:\n                    result = validator(userId, docToValidate(validator, doc, generatedId));\n                    if (!Meteor._isPromise(result)) {\n                      _context4.next = 2;\n                      break;\n                    }\n                    _context4.next = 1;\n                    return _regeneratorRuntime.awrap(result);\n                  case 1:\n                    _t2 = _context4.sent;\n                    _context4.next = 3;\n                    break;\n                  case 2:\n                    _t2 = result;\n                  case 3:\n                    return _context4.abrupt(\"return\", !_t2);\n                  case 4:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }, null, null, null, Promise);\n            }\n            return _callee2;\n          }()));\n        case 3:\n          if (!_context5.sent) {\n            _context5.next = 4;\n            break;\n          }\n          throw new Meteor.Error(403, \"Access denied\");\n        case 4:\n          // If we generated an ID above, insertAsync it now: after the validation, but\n          // before actually inserting.\n          if (generatedId !== null) doc._id = generatedId;\n          return _context5.abrupt(\"return\", self._collection.insertAsync.call(self._collection, doc));\n        case 5:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, null, this, null, Promise);\n  }\n  return _callee3;\n}();\n\n// Simulate a mongo `update` operation while validating that the access\n// control rules set by calls to `allow/deny` are satisfied. If all\n// pass, rewrite the mongo operation to use $in to set the list of\n// document ids to change ##ValidatedChange\nCollectionPrototype._validatedUpdateAsync = function () {\n  function _callee6(userId, selector, mutator, options) {\n    var self, noReplaceError, mutatorKeys, modifiedFields, fields, findOptions, doc;\n    return _regeneratorRuntime.async(function (_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          self = this;\n          check(mutator, Object);\n          options = Object.assign(Object.create(null), options);\n          if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n            _context8.next = 1;\n            break;\n          }\n          throw new Error(\"validated update should be of a single ID\");\n        case 1:\n          if (!options.upsert) {\n            _context8.next = 2;\n            break;\n          }\n          throw new Meteor.Error(403, \"Access denied. Upserts not \" + \"allowed in a restricted collection.\");\n        case 2:\n          noReplaceError = \"Access denied. In a restricted collection you can only\" + \" update documents, not replace them. Use a Mongo update operator, such \" + \"as '$set'.\";\n          mutatorKeys = Object.keys(mutator); // compute modified fields\n          modifiedFields = {};\n          if (!(mutatorKeys.length === 0)) {\n            _context8.next = 3;\n            break;\n          }\n          throw new Meteor.Error(403, noReplaceError);\n        case 3:\n          mutatorKeys.forEach(function (op) {\n            var params = mutator[op];\n            if (op.charAt(0) !== '$') {\n              throw new Meteor.Error(403, noReplaceError);\n            } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\n              throw new Meteor.Error(403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n            } else {\n              Object.keys(params).forEach(function (field) {\n                // treat dotted fields as if they are replacing their\n                // top-level part\n                if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.'));\n\n                // record the field we are trying to change\n                modifiedFields[field] = true;\n              });\n            }\n          });\n          fields = Object.keys(modifiedFields);\n          findOptions = {\n            transform: null\n          };\n          if (!self._validators.fetchAllFields) {\n            findOptions.fields = {};\n            self._validators.fetch.forEach(function (fieldName) {\n              findOptions.fields[fieldName] = 1;\n            });\n          }\n          _context8.next = 4;\n          return _regeneratorRuntime.awrap(self._collection.findOneAsync(selector, findOptions));\n        case 4:\n          doc = _context8.sent;\n          if (doc) {\n            _context8.next = 5;\n            break;\n          }\n          return _context8.abrupt(\"return\", 0);\n        case 5:\n          _context8.next = 6;\n          return _regeneratorRuntime.awrap(asyncSome(self._validators.update.deny, function () {\n            function _callee4(validator) {\n              var factoriedDoc, result, _t3;\n              return _regeneratorRuntime.async(function (_context6) {\n                while (1) switch (_context6.prev = _context6.next) {\n                  case 0:\n                    factoriedDoc = transformDoc(validator, doc);\n                    result = validator(userId, factoriedDoc, fields, mutator);\n                    if (!Meteor._isPromise(result)) {\n                      _context6.next = 2;\n                      break;\n                    }\n                    _context6.next = 1;\n                    return _regeneratorRuntime.awrap(result);\n                  case 1:\n                    _t3 = _context6.sent;\n                    _context6.next = 3;\n                    break;\n                  case 2:\n                    _t3 = result;\n                  case 3:\n                    return _context6.abrupt(\"return\", _t3);\n                  case 4:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }, null, null, null, Promise);\n            }\n            return _callee4;\n          }()));\n        case 6:\n          if (!_context8.sent) {\n            _context8.next = 7;\n            break;\n          }\n          throw new Meteor.Error(403, \"Access denied\");\n        case 7:\n          _context8.next = 8;\n          return _regeneratorRuntime.awrap(asyncEvery(self._validators.update.allow, function () {\n            function _callee5(validator) {\n              var factoriedDoc, result, _t4;\n              return _regeneratorRuntime.async(function (_context7) {\n                while (1) switch (_context7.prev = _context7.next) {\n                  case 0:\n                    factoriedDoc = transformDoc(validator, doc);\n                    result = validator(userId, factoriedDoc, fields, mutator);\n                    if (!Meteor._isPromise(result)) {\n                      _context7.next = 2;\n                      break;\n                    }\n                    _context7.next = 1;\n                    return _regeneratorRuntime.awrap(result);\n                  case 1:\n                    _t4 = _context7.sent;\n                    _context7.next = 3;\n                    break;\n                  case 2:\n                    _t4 = result;\n                  case 3:\n                    return _context7.abrupt(\"return\", !_t4);\n                  case 4:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }, null, null, null, Promise);\n            }\n            return _callee5;\n          }()));\n        case 8:\n          if (!_context8.sent) {\n            _context8.next = 9;\n            break;\n          }\n          throw new Meteor.Error(403, \"Access denied\");\n        case 9:\n          options._forbidReplace = true;\n\n          // Back when we supported arbitrary client-provided selectors, we actually\n          // rewrote the selector to include an _id clause before passing to Mongo to\n          // avoid races, but since selector is guaranteed to already just be an ID, we\n          // don't have to any more.\n          return _context8.abrupt(\"return\", self._collection.updateAsync.call(self._collection, selector, mutator, options));\n        case 10:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, null, this, null, Promise);\n  }\n  return _callee6;\n}();\n\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nvar ALLOWED_UPDATE_OPERATIONS = {\n  $inc: 1,\n  $set: 1,\n  $unset: 1,\n  $addToSet: 1,\n  $pop: 1,\n  $pullAll: 1,\n  $pull: 1,\n  $pushAll: 1,\n  $push: 1,\n  $bit: 1\n};\n\n// Simulate a mongo `remove` operation while validating access control\n// rules. See #ValidatedChange\nCollectionPrototype._validatedRemoveAsync = function () {\n  function _callee9(userId, selector) {\n    var self, findOptions, doc;\n    return _regeneratorRuntime.async(function (_context1) {\n      while (1) switch (_context1.prev = _context1.next) {\n        case 0:\n          self = this;\n          findOptions = {\n            transform: null\n          };\n          if (!self._validators.fetchAllFields) {\n            findOptions.fields = {};\n            self._validators.fetch.forEach(function (fieldName) {\n              findOptions.fields[fieldName] = 1;\n            });\n          }\n          _context1.next = 1;\n          return _regeneratorRuntime.awrap(self._collection.findOneAsync(selector, findOptions));\n        case 1:\n          doc = _context1.sent;\n          if (doc) {\n            _context1.next = 2;\n            break;\n          }\n          return _context1.abrupt(\"return\", 0);\n        case 2:\n          _context1.next = 3;\n          return _regeneratorRuntime.awrap(asyncSome(self._validators.remove.deny, function () {\n            function _callee7(validator) {\n              var result, _t5;\n              return _regeneratorRuntime.async(function (_context9) {\n                while (1) switch (_context9.prev = _context9.next) {\n                  case 0:\n                    result = validator(userId, transformDoc(validator, doc));\n                    if (!Meteor._isPromise(result)) {\n                      _context9.next = 2;\n                      break;\n                    }\n                    _context9.next = 1;\n                    return _regeneratorRuntime.awrap(result);\n                  case 1:\n                    _t5 = _context9.sent;\n                    _context9.next = 3;\n                    break;\n                  case 2:\n                    _t5 = result;\n                  case 3:\n                    return _context9.abrupt(\"return\", _t5);\n                  case 4:\n                  case \"end\":\n                    return _context9.stop();\n                }\n              }, null, null, null, Promise);\n            }\n            return _callee7;\n          }()));\n        case 3:\n          if (!_context1.sent) {\n            _context1.next = 4;\n            break;\n          }\n          throw new Meteor.Error(403, \"Access denied\");\n        case 4:\n          _context1.next = 5;\n          return _regeneratorRuntime.awrap(asyncEvery(self._validators.remove.allow, function () {\n            function _callee8(validator) {\n              var result, _t6;\n              return _regeneratorRuntime.async(function (_context0) {\n                while (1) switch (_context0.prev = _context0.next) {\n                  case 0:\n                    result = validator(userId, transformDoc(validator, doc));\n                    if (!Meteor._isPromise(result)) {\n                      _context0.next = 2;\n                      break;\n                    }\n                    _context0.next = 1;\n                    return _regeneratorRuntime.awrap(result);\n                  case 1:\n                    _t6 = _context0.sent;\n                    _context0.next = 3;\n                    break;\n                  case 2:\n                    _t6 = result;\n                  case 3:\n                    return _context0.abrupt(\"return\", !_t6);\n                  case 4:\n                  case \"end\":\n                    return _context0.stop();\n                }\n              }, null, null, null, Promise);\n            }\n            return _callee8;\n          }()));\n        case 5:\n          if (!_context1.sent) {\n            _context1.next = 6;\n            break;\n          }\n          throw new Meteor.Error(403, \"Access denied\");\n        case 6:\n          return _context1.abrupt(\"return\", self._collection.removeAsync.call(self._collection, selector));\n        case 7:\n        case \"end\":\n          return _context1.stop();\n      }\n    }, null, this, null, Promise);\n  }\n  return _callee9;\n}();\nCollectionPrototype._callMutatorMethodAsync = function () {\n  function _callMutatorMethodAsync(name, args) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // For two out of three mutator methods, the first argument is a selector\n    var firstArgIsSelector = name === \"updateAsync\" || name === \"removeAsync\";\n    if (firstArgIsSelector && !alreadyInSimulation()) {\n      // If we're about to actually send an RPC, we should throw an error if\n      // this is a non-ID selector, because the mutation methods only allow\n      // single-ID selectors. (If we don't throw here, we'll see flicker.)\n      throwIfSelectorIsNotId(args[0], name);\n    }\n    var mutatorMethodName = this._prefix + name;\n    return this._connection.applyAsync(mutatorMethodName, args, _objectSpread({\n      returnStubValue: this.resolverType === 'stub' || this.resolverType == null,\n      // StubStream is only used for testing where you don't care about the server\n      returnServerResultPromise: !this._connection._stream._isStub && this.resolverType !== 'stub'\n    }, options));\n  }\n  return _callMutatorMethodAsync;\n}();\nCollectionPrototype._callMutatorMethod = function () {\n  function _callMutatorMethod(name, args, callback) {\n    if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n      // Client can't block, so it can't report errors by exception,\n      // only by callback. If they forget the callback, give them a\n      // default one that logs the error, so they aren't totally\n      // baffled if their writes don't work because their database is\n      // down.\n      // Don't give a default callback in simulation, because inside stubs we\n      // want to return the results from the local collection immediately and\n      // not force a callback.\n      callback = function (err) {\n        if (err) Meteor._debug(name + \" failed\", err);\n      };\n    }\n\n    // For two out of three mutator methods, the first argument is a selector\n    var firstArgIsSelector = name === \"update\" || name === \"remove\";\n    if (firstArgIsSelector && !alreadyInSimulation()) {\n      // If we're about to actually send an RPC, we should throw an error if\n      // this is a non-ID selector, because the mutation methods only allow\n      // single-ID selectors. (If we don't throw here, we'll see flicker.)\n      throwIfSelectorIsNotId(args[0], name);\n    }\n    var mutatorMethodName = this._prefix + name;\n    return this._connection.apply(mutatorMethodName, args, {\n      returnStubValue: true\n    }, callback);\n  }\n  return _callMutatorMethod;\n}();\nfunction transformDoc(validator, doc) {\n  if (validator.transform) return validator.transform(doc);\n  return doc;\n}\nfunction docToValidate(validator, doc, generatedId) {\n  var ret = doc;\n  if (validator.transform) {\n    ret = EJSON.clone(doc);\n    // If you set a server-side transform on your collection, then you don't get\n    // to tell the difference between \"client specified the ID\" and \"server\n    // generated the ID\", because transforms expect to get _id.  If you want to\n    // do that check, you can do it with a specific\n    // `C.allow({insertAsync: f, transform: null})` validator.\n    if (generatedId !== null) {\n      ret._id = generatedId;\n    }\n    ret = validator.transform(ret);\n  }\n  return ret;\n}\nfunction addValidator(collection, allowOrDeny, options) {\n  // validate keys\n  var validKeysRegEx = /^(?:insertAsync|updateAsync|removeAsync|insert|update|remove|fetch|transform)$/;\n  Object.keys(options).forEach(function (key) {\n    if (!validKeysRegEx.test(key)) throw new Error(allowOrDeny + \": Invalid key: \" + key);\n\n    // TODO deprecated async config on future versions\n    var isAsyncKey = key.includes('Async');\n    if (isAsyncKey) {\n      var syncKey = key.replace('Async', '');\n      Meteor.deprecate(allowOrDeny + (\": The \\\"\" + key + \"\\\" key is deprecated. Use \\\"\" + syncKey + \"\\\" instead.\"));\n    }\n  });\n  collection._restricted = true;\n  ['insertAsync', 'updateAsync', 'removeAsync', 'insert', 'update', 'remove'].forEach(function (name) {\n    if (hasOwn.call(options, name)) {\n      if (!(options[name] instanceof Function)) {\n        throw new Error(allowOrDeny + ': Value for `' + name + '` must be a function');\n      }\n\n      // If the transform is specified at all (including as 'null') in this\n      // call, then take that; otherwise, take the transform from the\n      // collection.\n      if (options.transform === undefined) {\n        options[name].transform = collection._transform; // already wrapped\n      } else {\n        options[name].transform = LocalCollection.wrapTransform(options.transform);\n      }\n      var isAsyncName = name.includes('Async');\n      var validatorSyncName = isAsyncName ? name.replace('Async', '') : name;\n      collection._validators[validatorSyncName][allowOrDeny].push(options[name]);\n    }\n  });\n\n  // Only updateAsync the fetch fields if we're passed things that affect\n  // fetching. This way allow({}) and allow({insertAsync: f}) don't result in\n  // setting fetchAllFields\n  if (options.updateAsync || options.removeAsync || options.fetch) {\n    if (options.fetch && !(options.fetch instanceof Array)) {\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");\n    }\n    collection._updateFetch(options.fetch);\n  }\n}\nfunction throwIfSelectorIsNotId(selector, methodName) {\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    throw new Meteor.Error(403, \"Not permitted. Untrusted code may only \" + methodName + \" documents by ID.\");\n  }\n}\n;\n\n// Determine if we are in a DDP method simulation\nfunction alreadyInSimulation() {\n  var CurrentInvocation = DDP._CurrentMethodInvocation ||\n  // For backwards compatibility, as explained in this issue:\n  // https://github.com/meteor/meteor/issues/8947\n  DDP._CurrentInvocation;\n  var enclosing = CurrentInvocation.get();\n  return enclosing && enclosing.isSimulation;\n}","map":{"version":3,"names":["_regeneratorRuntime","module","link","default","v","_objectSpread","_createForOfIteratorHelperLoose","hasOwn","Object","prototype","hasOwnProperty","AllowDeny","CollectionPrototype","allow","options","addValidator","deny","_defineMutationMethods","self","_restricted","_insecure","undefined","_validators","insert","update","remove","insertAsync","updateAsync","removeAsync","upsertAsync","fetch","fetchAllFields","_name","_prefix","_connection","Meteor","server","isClient","m","forEach","method","methodName","useExisting","handlerPropName","isInsert","name","includes","check","arguments","Match","Any","args","Array","from","generatedId","call","_makeNewID","isSimulation","_id","_collection","apply","throwIfSelectorIsNotId","syncMethodName","replace","syncValidatedMethodName","charAt","toUpperCase","slice","validatedMethodName","length","Error","unshift","userId","push","_isInsecure","syncMethodsMapper","e","toString","methods","_updateFetch","fields","union","create","add","names","keys","Package","insecure","asyncSome","array","predicate","_iterator","_step","item","async","_context","prev","next","done","value","awrap","sent","abrupt","stop","Promise","asyncEvery","_iterator2","_step2","_context2","_validatedInsertAsync","_callee3","doc","_context5","_callee","validator","result","_t","_context3","docToValidate","_isPromise","_callee2","_t2","_context4","_validatedUpdateAsync","_callee6","selector","mutator","noReplaceError","mutatorKeys","modifiedFields","findOptions","_context8","assign","LocalCollection","_selectorIsIdPerhapsAsObject","upsert","op","params","ALLOWED_UPDATE_OPERATIONS","field","indexOf","substring","transform","fieldName","findOneAsync","_callee4","factoriedDoc","_t3","_context6","transformDoc","_callee5","_t4","_context7","_forbidReplace","$inc","$set","$unset","$addToSet","$pop","$pullAll","$pull","$pushAll","$push","$bit","_validatedRemoveAsync","_callee9","_context1","_callee7","_t5","_context9","_callee8","_t6","_context0","_callMutatorMethodAsync","firstArgIsSelector","alreadyInSimulation","mutatorMethodName","applyAsync","returnStubValue","resolverType","returnServerResultPromise","_stream","_isStub","_callMutatorMethod","callback","err","_debug","ret","EJSON","clone","collection","allowOrDeny","validKeysRegEx","key","test","isAsyncKey","syncKey","deprecate","Function","_transform","wrapTransform","isAsyncName","validatorSyncName","CurrentInvocation","DDP","_CurrentMethodInvocation","_CurrentInvocation","enclosing","get"],"sources":["packages/allow-deny/allow-deny.js"],"sourcesContent":["///\n/// Remote methods and access control.\n///\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// Restrict default mutators on collection. allow() and deny() take the\n// same options:\n//\n// options.insertAsync {Function(userId, doc)}\n//   return true to allow/deny adding this document\n//\n// options.updateAsync {Function(userId, docs, fields, modifier)}\n//   return true to allow/deny updating these documents.\n//   `fields` is passed as an array of fields that are to be modified\n//\n// options.removeAsync {Function(userId, docs)}\n//   return true to allow/deny removing these documents\n//\n// options.fetch {Array}\n//   Fields to fetch for these validators. If any call to allow or deny\n//   does not have this option then all fields are loaded.\n//\n// allow and deny can be called multiple times. The validators are\n// evaluated as follows:\n// - If neither deny() nor allow() has been called on the collection,\n//   then the request is allowed if and only if the \"insecure\" smart\n//   package is in use.\n// - Otherwise, if any deny() function returns true, the request is denied.\n// - Otherwise, if any allow() function returns true, the request is allowed.\n// - Otherwise, the request is denied.\n//\n// Meteor may call your deny() and allow() functions in any order, and may not\n// call all of them if it is able to make a decision without calling them all\n// (so don't include side effects).\n\nAllowDeny = {\n  CollectionPrototype: {}\n};\n\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\n// methods\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\n\n/**\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server\n * @method allow\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.allow = function(options) {\n  addValidator(this, 'allow', options);\n};\n\n/**\n * @summary Override `allow` rules.\n * @locus Server\n * @method deny\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.deny = function(options) {\n  addValidator(this, 'deny', options);\n};\n\nCollectionPrototype._defineMutationMethods = function(options) {\n  const self = this;\n  options = options || {};\n\n  // set to true once we call any allow or deny methods. If true, use\n  // allow/deny semantics. If false, use insecure mode semantics.\n  self._restricted = false;\n\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\n  // means insecure iff the insecure package is loaded. This property can be\n  // overriden by tests or packages wishing to change insecure mode behavior of\n  // their collections.\n  self._insecure = undefined;\n\n  self._validators = {\n    insert: {allow: [], deny: []},\n    update: {allow: [], deny: []},\n    remove: {allow: [], deny: []},\n    insertAsync: {allow: [], deny: []},\n    updateAsync: {allow: [], deny: []},\n    removeAsync: {allow: [], deny: []},\n    upsertAsync: {allow: [], deny: []}, // dummy arrays; can't set these!\n    fetch: [],\n    fetchAllFields: false\n  };\n\n  if (!self._name)\n    return; // anonymous collection\n\n  // XXX Think about method namespacing. Maybe methods should be\n  // \"Meteor:Mongo:insertAsync/NAME\"?\n  self._prefix = '/' + self._name + '/';\n\n  // Mutation Methods\n  // Minimongo on the server gets no stubs; instead, by default\n  // it wait()s until its result is ready, yielding.\n  // This matches the behavior of macromongo on the server better.\n  // XXX see #MeteorServerNull\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\n    const m = {};\n\n    [\n      'insertAsync',\n      'updateAsync',\n      'removeAsync',\n      'insert',\n      'update',\n      'remove',\n    ].forEach(method => {\n      const methodName = self._prefix + method;\n\n      if (options.useExisting) {\n        const handlerPropName = Meteor.isClient\n          ? '_methodHandlers'\n          : 'method_handlers';\n        // Do not try to create additional methods if this has already been called.\n        // (Otherwise the .methods() call below will throw an error.)\n        if (\n          self._connection[handlerPropName] &&\n          typeof self._connection[handlerPropName][methodName] === 'function'\n        )\n          return;\n      }\n\n      const isInsert = name => name.includes('insert');\n\n      m[methodName] = function (/* ... */) {\n        // All the methods do their own validation, instead of using check().\n        check(arguments, [Match.Any]);\n        const args = Array.from(arguments);\n        try {\n          // For an insert/insertAsync, if the client didn't specify an _id, generate one\n          // now; because this uses DDP.randomStream, it will be consistent with\n          // what the client generated. We generate it now rather than later so\n          // that if (eg) an allow/deny rule does an insert/insertAsync to the same\n          // collection (not that it really should), the generated _id will\n          // still be the first use of the stream and will be consistent.\n          //\n          // However, we don't actually stick the _id onto the document yet,\n          // because we want allow/deny rules to be able to differentiate\n          // between arbitrary client-specified _id fields and merely\n          // client-controlled-via-randomSeed fields.\n          let generatedId = null;\n          if (isInsert(method) && !hasOwn.call(args[0], '_id')) {\n            generatedId = self._makeNewID();\n          }\n\n          if (this.isSimulation) {\n            // In a client simulation, you can do any mutation (even with a\n            // complex selector).\n            if (generatedId !== null) {\n              args[0]._id = generatedId;\n            }\n            return self._collection[method].apply(self._collection, args);\n          }\n\n          // This is the server receiving a method call from the client.\n\n          // We don't allow arbitrary selectors in mutations from the client: only\n          // single-ID selectors.\n          if (!isInsert(method)) throwIfSelectorIsNotId(args[0], method);\n\n          const syncMethodName = method.replace('Async', '');\n          const syncValidatedMethodName = '_validated' + method.charAt(0).toUpperCase() + syncMethodName.slice(1);\n          // it forces to use async validated behavior\n          const validatedMethodName = syncValidatedMethodName + 'Async';\n\n          if (self._restricted) {\n            // short circuit if there is no way it will pass.\n            if (self._validators[syncMethodName].allow.length === 0) {\n              throw new Meteor.Error(\n                403,\n                'Access denied. No allow validators set on restricted ' +\n                  \"collection for method '\" +\n                  method +\n                  \"'.\"\n              );\n            }\n\n            args.unshift(this.userId);\n            isInsert(method) && args.push(generatedId);\n            return self[validatedMethodName].apply(self, args);\n          } else if (self._isInsecure()) {\n            if (generatedId !== null) args[0]._id = generatedId;\n            // In insecure mode we use the server _collection methods, and these sync methods\n            // do not exist in the server anymore, so we have this mapper to call the async methods\n            // instead.\n            const syncMethodsMapper = {\n              insert: \"insertAsync\",\n              update: \"updateAsync\",\n              remove: \"removeAsync\",\n            };\n\n\n            // In insecure mode, allow any mutation (with a simple selector).\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\n            //     we get from the network to this function, we should actually\n            //     know the correct arguments for the function and pass just\n            //     them.  For example, if you have an extraneous extra null\n            //     argument and this is Mongo on the server, the .wrapAsync'd\n            //     functions like update will get confused and pass the\n            //     \"fut.resolver()\" in the wrong slot, where _update will never\n            //     invoke it. Bam, broken DDP connection.  Probably should just\n            //     take this whole method and write it three times, invoking\n            //     helpers for the common code.\n            return self._collection[syncMethodsMapper[method] || method].apply(self._collection, args);\n          } else {\n            // In secure mode, if we haven't called allow or deny, then nothing\n            // is permitted.\n            throw new Meteor.Error(403, 'Access denied');\n          }\n        } catch (e) {\n          if (\n            e.name === 'MongoError' ||\n            // for old versions of MongoDB (probably not necessary but it's here just in case)\n            e.name === 'BulkWriteError' ||\n            // for newer versions of MongoDB (https://docs.mongodb.com/drivers/node/current/whats-new/#bulkwriteerror---mongobulkwriteerror)\n            e.name === 'MongoBulkWriteError' ||\n            e.name === 'MinimongoError'\n          ) {\n            throw new Meteor.Error(409, e.toString());\n          } else {\n            throw e;\n          }\n        }\n      };\n    });\n\n    self._connection.methods(m);\n  }\n};\n\nCollectionPrototype._updateFetch = function (fields) {\n  const self = this;\n\n  if (!self._validators.fetchAllFields) {\n    if (fields) {\n      const union = Object.create(null);\n      const add = names => names && names.forEach(name => union[name] = 1);\n      add(self._validators.fetch);\n      add(fields);\n      self._validators.fetch = Object.keys(union);\n    } else {\n      self._validators.fetchAllFields = true;\n      // clear fetch just to make sure we don't accidentally read it\n      self._validators.fetch = null;\n    }\n  }\n};\n\nCollectionPrototype._isInsecure = function () {\n  const self = this;\n  if (self._insecure === undefined)\n    return !!Package.insecure;\n  return self._insecure;\n};\n\nasync function asyncSome(array, predicate) {\n  for (let item of array) {\n    if (await predicate(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nasync function asyncEvery(array, predicate) {\n  for (let item of array) {\n    if (!await predicate(item)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nCollectionPrototype._validatedInsertAsync = async function(userId, doc,\n                                                           generatedId) {\n  const self = this;\n  // call user validators.\n  // Any deny returns true means denied.\n  if (await asyncSome(self._validators.insert.deny, async (validator) => {\n    const result = validator(userId, docToValidate(validator, doc, generatedId));\n    return Meteor._isPromise(result) ? await result : result;\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n\n  if (await asyncEvery(self._validators.insert.allow, async (validator) => {\n    const result = validator(userId, docToValidate(validator, doc, generatedId));\n    return !(Meteor._isPromise(result) ? await result : result);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // If we generated an ID above, insertAsync it now: after the validation, but\n  // before actually inserting.\n  if (generatedId !== null)\n    doc._id = generatedId;\n\n  return self._collection.insertAsync.call(self._collection, doc);\n};\n\n// Simulate a mongo `update` operation while validating that the access\n// control rules set by calls to `allow/deny` are satisfied. If all\n// pass, rewrite the mongo operation to use $in to set the list of\n// document ids to change ##ValidatedChange\nCollectionPrototype._validatedUpdateAsync = async function(\n    userId, selector, mutator, options) {\n  const self = this;\n\n  check(mutator, Object);\n\n  options = Object.assign(Object.create(null), options);\n\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\n    throw new Error(\"validated update should be of a single ID\");\n\n  // We don't support upserts because they don't fit nicely into allow/deny\n  // rules.\n  if (options.upsert)\n    throw new Meteor.Error(403, \"Access denied. Upserts not \" +\n                           \"allowed in a restricted collection.\");\n\n  const noReplaceError = \"Access denied. In a restricted collection you can only\" +\n        \" update documents, not replace them. Use a Mongo update operator, such \" +\n        \"as '$set'.\";\n\n  const mutatorKeys = Object.keys(mutator);\n\n  // compute modified fields\n  const modifiedFields = {};\n\n  if (mutatorKeys.length === 0) {\n    throw new Meteor.Error(403, noReplaceError);\n  }\n  mutatorKeys.forEach((op) => {\n    const params = mutator[op];\n    if (op.charAt(0) !== '$') {\n      throw new Meteor.Error(403, noReplaceError);\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\n      throw new Meteor.Error(\n        403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n    } else {\n      Object.keys(params).forEach((field) => {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        modifiedFields[field] = true;\n      });\n    }\n  });\n\n  const fields = Object.keys(modifiedFields);\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    self._validators.fetch.forEach((fieldName) => {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = await self._collection.findOneAsync(selector, findOptions);\n  if (!doc)  // none satisfied!\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (await asyncSome(self._validators.update.deny, async (validator) => {\n    const factoriedDoc = transformDoc(validator, doc);\n    const result = validator(userId,\n      factoriedDoc,\n      fields,\n      mutator);\n    return Meteor._isPromise(result) ? await result : result;\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (await asyncEvery(self._validators.update.allow, async (validator) => {\n    const factoriedDoc = transformDoc(validator, doc);\n    const result = validator(userId,\n      factoriedDoc,\n      fields,\n      mutator);\n    return !(Meteor._isPromise(result) ? await result : result);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  options._forbidReplace = true;\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to include an _id clause before passing to Mongo to\n  // avoid races, but since selector is guaranteed to already just be an ID, we\n  // don't have to any more.\n\n  return self._collection.updateAsync.call(\n    self._collection, selector, mutator, options);\n};\n\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nconst ALLOWED_UPDATE_OPERATIONS = {\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\n  $pushAll:1, $push:1, $bit:1\n};\n\n// Simulate a mongo `remove` operation while validating access control\n// rules. See #ValidatedChange\nCollectionPrototype._validatedRemoveAsync = async function(userId, selector) {\n  const self = this;\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    self._validators.fetch.forEach((fieldName) => {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = await self._collection.findOneAsync(selector, findOptions);\n  if (!doc)\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (await asyncSome(self._validators.remove.deny, async (validator) => {\n    const result = validator(userId, transformDoc(validator, doc));\n    return Meteor._isPromise(result) ? await result : result;\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (await asyncEvery(self._validators.remove.allow, async (validator) => {\n    const result = validator(userId, transformDoc(validator, doc));\n    return !(Meteor._isPromise(result) ? await result : result);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\n  // Mongo to avoid races, but since selector is guaranteed to already just be\n  // an ID, we don't have to any more.\n\n  return self._collection.removeAsync.call(self._collection, selector);\n};\n\nCollectionPrototype._callMutatorMethodAsync = function _callMutatorMethodAsync(name, args, options = {}) {\n\n  // For two out of three mutator methods, the first argument is a selector\n  const firstArgIsSelector = name === \"updateAsync\" || name === \"removeAsync\";\n  if (firstArgIsSelector && !alreadyInSimulation()) {\n    // If we're about to actually send an RPC, we should throw an error if\n    // this is a non-ID selector, because the mutation methods only allow\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\n    throwIfSelectorIsNotId(args[0], name);\n  }\n\n  const mutatorMethodName = this._prefix + name;\n  return this._connection.applyAsync(mutatorMethodName, args, {\n    returnStubValue: this.resolverType === 'stub' || this.resolverType == null,\n    // StubStream is only used for testing where you don't care about the server\n    returnServerResultPromise: !this._connection._stream._isStub && this.resolverType !== 'stub',\n    ...options,\n  });\n}\n\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n    // Client can't block, so it can't report errors by exception,\n    // only by callback. If they forget the callback, give them a\n    // default one that logs the error, so they aren't totally\n    // baffled if their writes don't work because their database is\n    // down.\n    // Don't give a default callback in simulation, because inside stubs we\n    // want to return the results from the local collection immediately and\n    // not force a callback.\n    callback = function (err) {\n      if (err)\n        Meteor._debug(name + \" failed\", err);\n    };\n  }\n\n  // For two out of three mutator methods, the first argument is a selector\n  const firstArgIsSelector = name === \"update\" || name === \"remove\";\n  if (firstArgIsSelector && !alreadyInSimulation()) {\n    // If we're about to actually send an RPC, we should throw an error if\n    // this is a non-ID selector, because the mutation methods only allow\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\n    throwIfSelectorIsNotId(args[0], name);\n  }\n\n  const mutatorMethodName = this._prefix + name;\n  return this._connection.apply(\n    mutatorMethodName, args, { returnStubValue: true }, callback);\n}\n\nfunction transformDoc(validator, doc) {\n  if (validator.transform)\n    return validator.transform(doc);\n  return doc;\n}\n\nfunction docToValidate(validator, doc, generatedId) {\n  let ret = doc;\n  if (validator.transform) {\n    ret = EJSON.clone(doc);\n    // If you set a server-side transform on your collection, then you don't get\n    // to tell the difference between \"client specified the ID\" and \"server\n    // generated the ID\", because transforms expect to get _id.  If you want to\n    // do that check, you can do it with a specific\n    // `C.allow({insertAsync: f, transform: null})` validator.\n    if (generatedId !== null) {\n      ret._id = generatedId;\n    }\n    ret = validator.transform(ret);\n  }\n  return ret;\n}\n\nfunction addValidator(collection, allowOrDeny, options) {\n  // validate keys\n  const validKeysRegEx = /^(?:insertAsync|updateAsync|removeAsync|insert|update|remove|fetch|transform)$/;\n  Object.keys(options).forEach((key) => {\n    if (!validKeysRegEx.test(key))\n      throw new Error(allowOrDeny + \": Invalid key: \" + key);\n\n    // TODO deprecated async config on future versions\n    const isAsyncKey = key.includes('Async');\n    if (isAsyncKey) {\n      const syncKey = key.replace('Async', '');\n      Meteor.deprecate(allowOrDeny + `: The \"${key}\" key is deprecated. Use \"${syncKey}\" instead.`);\n    }\n  });\n\n  collection._restricted = true;\n\n  [\n    'insertAsync',\n    'updateAsync',\n    'removeAsync',\n    'insert',\n    'update',\n    'remove',\n  ].forEach(name => {\n    if (hasOwn.call(options, name)) {\n      if (!(options[name] instanceof Function)) {\n        throw new Error(\n          allowOrDeny + ': Value for `' + name + '` must be a function'\n        );\n      }\n\n      // If the transform is specified at all (including as 'null') in this\n      // call, then take that; otherwise, take the transform from the\n      // collection.\n      if (options.transform === undefined) {\n        options[name].transform = collection._transform; // already wrapped\n      } else {\n        options[name].transform = LocalCollection.wrapTransform(\n          options.transform\n        );\n      }\n      const isAsyncName = name.includes('Async');\n      const validatorSyncName = isAsyncName ? name.replace('Async', '') : name;\n      collection._validators[validatorSyncName][allowOrDeny].push(options[name]);\n    }\n  });\n\n  // Only updateAsync the fetch fields if we're passed things that affect\n  // fetching. This way allow({}) and allow({insertAsync: f}) don't result in\n  // setting fetchAllFields\n  if (options.updateAsync || options.removeAsync || options.fetch) {\n    if (options.fetch && !(options.fetch instanceof Array)) {\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");\n    }\n    collection._updateFetch(options.fetch);\n  }\n}\n\nfunction throwIfSelectorIsNotId(selector, methodName) {\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    throw new Meteor.Error(\n      403, \"Not permitted. Untrusted code may only \" + methodName +\n        \" documents by ID.\");\n  }\n};\n\n// Determine if we are in a DDP method simulation\nfunction alreadyInSimulation() {\n  var CurrentInvocation =\n    DDP._CurrentMethodInvocation ||\n    // For backwards compatibility, as explained in this issue:\n    // https://github.com/meteor/meteor/issues/8947\n    DDP._CurrentInvocation;\n\n  const enclosing = CurrentInvocation.get();\n  return enclosing && enclosing.isSimulation;\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"3931b548322084763cf97c3e169b0ee27fb26ffc"}

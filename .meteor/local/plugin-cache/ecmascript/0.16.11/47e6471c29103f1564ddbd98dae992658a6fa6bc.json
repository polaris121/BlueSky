{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/mongo/collection/methods_replication.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/collection/methods_replication.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    module.export({\n      ReplicationMethods: () => ReplicationMethods\n    });\n    const ReplicationMethods = {\n      async _maybeSetUpReplication(name) {\n        var _registerStoreResult, _registerStoreResult$;\n        const self = this;\n        if (!(self._connection && self._connection.registerStoreClient && self._connection.registerStoreServer)) {\n          return;\n        }\n        const wrappedStoreCommon = {\n          // Called around method stub invocations to capture the original versions\n          // of modified documents.\n          saveOriginals() {\n            self._collection.saveOriginals();\n          },\n          retrieveOriginals() {\n            return self._collection.retrieveOriginals();\n          },\n          // To be able to get back to the collection from the store.\n          _getCollection() {\n            return self;\n          }\n        };\n        const wrappedStoreClient = _objectSpread({\n          // Called at the beginning of a batch of updates. batchSize is the number\n          // of update calls to expect.\n          //\n          // XXX This interface is pretty janky. reset probably ought to go back to\n          // being its own function, and callers shouldn't have to calculate\n          // batchSize. The optimization of not calling pause/remove should be\n          // delayed until later: the first call to update() should buffer its\n          // message, and then we can either directly apply it at endUpdate time if\n          // it was the only update, or do pauseObservers/apply/apply at the next\n          // update() if there's another one.\n          async beginUpdate(batchSize, reset) {\n            // pause observers so users don't see flicker when updating several\n            // objects at once (including the post-reconnect reset-and-reapply\n            // stage), and so that a re-sorting of a query can take advantage of the\n            // full _diffQuery moved calculation instead of applying change one at a\n            // time.\n            if (batchSize > 1 || reset) self._collection.pauseObservers();\n            if (reset) await self._collection.remove({});\n          },\n          // Apply an update.\n          // XXX better specify this interface (not in terms of a wire message)?\n          update(msg) {\n            var mongoId = MongoID.idParse(msg.id);\n            var doc = self._collection._docs.get(mongoId);\n\n            //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n            // *We receive an added message for a document that is already there. Instead, it will be changed\n            // *We reeive a change message for a document that is not there. Instead, it will be added\n            // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n            //Code is derived from client-side code originally in peerlibrary:control-mergebox\n            //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n            //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n            //https://github.com/meteor/meteor/pull/11151\n            if (Meteor.isClient) {\n              if (msg.msg === 'added' && doc) {\n                msg.msg = 'changed';\n              } else if (msg.msg === 'removed' && !doc) {\n                return;\n              } else if (msg.msg === 'changed' && !doc) {\n                msg.msg = 'added';\n                const _ref = msg.fields;\n                for (let field in _ref) {\n                  const value = _ref[field];\n                  if (value === void 0) {\n                    delete msg.fields[field];\n                  }\n                }\n              }\n            }\n            // Is this a \"replace the whole doc\" message coming from the quiescence\n            // of method writes to an object? (Note that 'undefined' is a valid\n            // value meaning \"remove it\".)\n            if (msg.msg === 'replace') {\n              var replace = msg.replace;\n              if (!replace) {\n                if (doc) self._collection.remove(mongoId);\n              } else if (!doc) {\n                self._collection.insert(replace);\n              } else {\n                // XXX check that replace has no $ ops\n                self._collection.update(mongoId, replace);\n              }\n              return;\n            } else if (msg.msg === 'added') {\n              if (doc) {\n                throw new Error('Expected not to find a document already present for an add');\n              }\n              self._collection.insert(_objectSpread({\n                _id: mongoId\n              }, msg.fields));\n            } else if (msg.msg === 'removed') {\n              if (!doc) throw new Error('Expected to find a document already present for removed');\n              self._collection.remove(mongoId);\n            } else if (msg.msg === 'changed') {\n              if (!doc) throw new Error('Expected to find a document to change');\n              const keys = Object.keys(msg.fields);\n              if (keys.length > 0) {\n                var modifier = {};\n                keys.forEach(key => {\n                  const value = msg.fields[key];\n                  if (EJSON.equals(doc[key], value)) {\n                    return;\n                  }\n                  if (typeof value === 'undefined') {\n                    if (!modifier.$unset) {\n                      modifier.$unset = {};\n                    }\n                    modifier.$unset[key] = 1;\n                  } else {\n                    if (!modifier.$set) {\n                      modifier.$set = {};\n                    }\n                    modifier.$set[key] = value;\n                  }\n                });\n                if (Object.keys(modifier).length > 0) {\n                  self._collection.update(mongoId, modifier);\n                }\n              }\n            } else {\n              throw new Error(\"I don't know how to deal with this message\");\n            }\n          },\n          // Called at the end of a batch of updates.livedata_connection.js:1287\n          endUpdate() {\n            self._collection.resumeObserversClient();\n          },\n          // Used to preserve current versions of documents across a store reset.\n          getDoc(id) {\n            return self.findOne(id);\n          }\n        }, wrappedStoreCommon);\n        const wrappedStoreServer = _objectSpread({\n          async beginUpdate(batchSize, reset) {\n            if (batchSize > 1 || reset) self._collection.pauseObservers();\n            if (reset) await self._collection.removeAsync({});\n          },\n          async update(msg) {\n            var mongoId = MongoID.idParse(msg.id);\n            var doc = self._collection._docs.get(mongoId);\n\n            // Is this a \"replace the whole doc\" message coming from the quiescence\n            // of method writes to an object? (Note that 'undefined' is a valid\n            // value meaning \"remove it\".)\n            if (msg.msg === 'replace') {\n              var replace = msg.replace;\n              if (!replace) {\n                if (doc) await self._collection.removeAsync(mongoId);\n              } else if (!doc) {\n                await self._collection.insertAsync(replace);\n              } else {\n                // XXX check that replace has no $ ops\n                await self._collection.updateAsync(mongoId, replace);\n              }\n              return;\n            } else if (msg.msg === 'added') {\n              if (doc) {\n                throw new Error('Expected not to find a document already present for an add');\n              }\n              await self._collection.insertAsync(_objectSpread({\n                _id: mongoId\n              }, msg.fields));\n            } else if (msg.msg === 'removed') {\n              if (!doc) throw new Error('Expected to find a document already present for removed');\n              await self._collection.removeAsync(mongoId);\n            } else if (msg.msg === 'changed') {\n              if (!doc) throw new Error('Expected to find a document to change');\n              const keys = Object.keys(msg.fields);\n              if (keys.length > 0) {\n                var modifier = {};\n                keys.forEach(key => {\n                  const value = msg.fields[key];\n                  if (EJSON.equals(doc[key], value)) {\n                    return;\n                  }\n                  if (typeof value === 'undefined') {\n                    if (!modifier.$unset) {\n                      modifier.$unset = {};\n                    }\n                    modifier.$unset[key] = 1;\n                  } else {\n                    if (!modifier.$set) {\n                      modifier.$set = {};\n                    }\n                    modifier.$set[key] = value;\n                  }\n                });\n                if (Object.keys(modifier).length > 0) {\n                  await self._collection.updateAsync(mongoId, modifier);\n                }\n              }\n            } else {\n              throw new Error(\"I don't know how to deal with this message\");\n            }\n          },\n          // Called at the end of a batch of updates.\n          async endUpdate() {\n            await self._collection.resumeObserversServer();\n          },\n          // Used to preserve current versions of documents across a store reset.\n          async getDoc(id) {\n            return self.findOneAsync(id);\n          }\n        }, wrappedStoreCommon);\n\n        // OK, we're going to be a slave, replicating some remote\n        // database, except possibly with some temporary divergence while\n        // we have unacknowledged RPC's.\n        let registerStoreResult;\n        if (Meteor.isClient) {\n          registerStoreResult = self._connection.registerStoreClient(name, wrappedStoreClient);\n        } else {\n          registerStoreResult = self._connection.registerStoreServer(name, wrappedStoreServer);\n        }\n        const message = \"There is already a collection named \\\"\".concat(name, \"\\\"\");\n        const logWarn = () => {\n          console.warn ? console.warn(message) : console.log(message);\n        };\n        if (!registerStoreResult) {\n          return logWarn();\n        }\n        return (_registerStoreResult = registerStoreResult) === null || _registerStoreResult === void 0 ? void 0 : (_registerStoreResult$ = _registerStoreResult.then) === null || _registerStoreResult$ === void 0 ? void 0 : _registerStoreResult$.call(_registerStoreResult, ok => {\n          if (!ok) {\n            logWarn();\n          }\n        });\n      }\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","__reifyWaitForDeps__","export","ReplicationMethods","_maybeSetUpReplication","name","_registerStoreResult","_registerStoreResult$","self","_connection","registerStoreClient","registerStoreServer","wrappedStoreCommon","saveOriginals","_collection","retrieveOriginals","_getCollection","wrappedStoreClient","beginUpdate","batchSize","reset","pauseObservers","remove","update","msg","mongoId","MongoID","idParse","id","doc","_docs","get","Meteor","isClient","_ref","fields","field","value","replace","insert","Error","_id","keys","Object","length","modifier","forEach","key","EJSON","equals","$unset","$set","endUpdate","resumeObserversClient","getDoc","findOne","wrappedStoreServer","removeAsync","insertAsync","updateAsync","resumeObserversServer","findOneAsync","registerStoreResult","message","concat","logWarn","console","warn","log","then","call","ok","__reify_async_result__","_reifyError","async"],"sources":["packages/mongo/collection/methods_replication.js"],"sourcesContent":["export const ReplicationMethods = {\n  async _maybeSetUpReplication(name) {\n    const self = this;\n    if (\n      !(\n        self._connection &&\n        self._connection.registerStoreClient &&\n        self._connection.registerStoreServer\n      )\n    ) {\n      return;\n    }\n\n\n    const wrappedStoreCommon = {\n      // Called around method stub invocations to capture the original versions\n      // of modified documents.\n      saveOriginals() {\n        self._collection.saveOriginals();\n      },\n      retrieveOriginals() {\n        return self._collection.retrieveOriginals();\n      },\n      // To be able to get back to the collection from the store.\n      _getCollection() {\n        return self;\n      },\n    };\n    const wrappedStoreClient = {\n      // Called at the beginning of a batch of updates. batchSize is the number\n      // of update calls to expect.\n      //\n      // XXX This interface is pretty janky. reset probably ought to go back to\n      // being its own function, and callers shouldn't have to calculate\n      // batchSize. The optimization of not calling pause/remove should be\n      // delayed until later: the first call to update() should buffer its\n      // message, and then we can either directly apply it at endUpdate time if\n      // it was the only update, or do pauseObservers/apply/apply at the next\n      // update() if there's another one.\n      async beginUpdate(batchSize, reset) {\n        // pause observers so users don't see flicker when updating several\n        // objects at once (including the post-reconnect reset-and-reapply\n        // stage), and so that a re-sorting of a query can take advantage of the\n        // full _diffQuery moved calculation instead of applying change one at a\n        // time.\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.remove({});\n      },\n\n      // Apply an update.\n      // XXX better specify this interface (not in terms of a wire message)?\n      update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n        // *We receive an added message for a document that is already there. Instead, it will be changed\n        // *We reeive a change message for a document that is not there. Instead, it will be added\n        // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n        //Code is derived from client-side code originally in peerlibrary:control-mergebox\n        //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n        //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n        //https://github.com/meteor/meteor/pull/11151\n        if (Meteor.isClient) {\n          if (msg.msg === 'added' && doc) {\n            msg.msg = 'changed';\n          } else if (msg.msg === 'removed' && !doc) {\n            return;\n          } else if (msg.msg === 'changed' && !doc) {\n            msg.msg = 'added';\n            const _ref = msg.fields;\n            for (let field in _ref) {\n              const value = _ref[field];\n              if (value === void 0) {\n                delete msg.fields[field];\n              }\n            }\n          }\n        }\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) self._collection.remove(mongoId);\n          } else if (!doc) {\n            self._collection.insert(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            self._collection.update(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          self._collection.insert({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          self._collection.remove(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              self._collection.update(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.livedata_connection.js:1287\n      endUpdate() {\n        self._collection.resumeObserversClient();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      getDoc(id) {\n        return self.findOne(id);\n      },\n\n      ...wrappedStoreCommon,\n    };\n    const wrappedStoreServer = {\n      async beginUpdate(batchSize, reset) {\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.removeAsync({});\n      },\n\n      async update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) await self._collection.removeAsync(mongoId);\n          } else if (!doc) {\n            await self._collection.insertAsync(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            await self._collection.updateAsync(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          await self._collection.insertAsync({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          await self._collection.removeAsync(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              await self._collection.updateAsync(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.\n      async endUpdate() {\n        await self._collection.resumeObserversServer();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      async getDoc(id) {\n        return self.findOneAsync(id);\n      },\n      ...wrappedStoreCommon,\n    };\n\n\n    // OK, we're going to be a slave, replicating some remote\n    // database, except possibly with some temporary divergence while\n    // we have unacknowledged RPC's.\n    let registerStoreResult;\n    if (Meteor.isClient) {\n      registerStoreResult = self._connection.registerStoreClient(\n        name,\n        wrappedStoreClient\n      );\n    } else {\n      registerStoreResult = self._connection.registerStoreServer(\n        name,\n        wrappedStoreServer\n      );\n    }\n\n    const message = `There is already a collection named \"${name}\"`;\n    const logWarn = () => {\n      console.warn ? console.warn(message) : console.log(message);\n    };\n\n    if (!registerStoreResult) {\n      return logWarn();\n    }\n\n    return registerStoreResult?.then?.(ok => {\n      if (!ok) {\n        logWarn();\n      }\n    });\n  },\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"47e6471c29103f1564ddbd98dae992658a6fa6bc"}

{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/mongo/collection/methods_replication.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/collection/methods_replication.js"}},"code":"let _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n}, 0);\nmodule.export({\n  ReplicationMethods: () => ReplicationMethods\n});\nconst ReplicationMethods = {\n  async _maybeSetUpReplication(name) {\n    var _registerStoreResult, _registerStoreResult$;\n    const self = this;\n    if (!(self._connection && self._connection.registerStoreClient && self._connection.registerStoreServer)) {\n      return;\n    }\n    const wrappedStoreCommon = {\n      // Called around method stub invocations to capture the original versions\n      // of modified documents.\n      saveOriginals() {\n        self._collection.saveOriginals();\n      },\n      retrieveOriginals() {\n        return self._collection.retrieveOriginals();\n      },\n      // To be able to get back to the collection from the store.\n      _getCollection() {\n        return self;\n      }\n    };\n    const wrappedStoreClient = _objectSpread({\n      // Called at the beginning of a batch of updates. batchSize is the number\n      // of update calls to expect.\n      //\n      // XXX This interface is pretty janky. reset probably ought to go back to\n      // being its own function, and callers shouldn't have to calculate\n      // batchSize. The optimization of not calling pause/remove should be\n      // delayed until later: the first call to update() should buffer its\n      // message, and then we can either directly apply it at endUpdate time if\n      // it was the only update, or do pauseObservers/apply/apply at the next\n      // update() if there's another one.\n      async beginUpdate(batchSize, reset) {\n        // pause observers so users don't see flicker when updating several\n        // objects at once (including the post-reconnect reset-and-reapply\n        // stage), and so that a re-sorting of a query can take advantage of the\n        // full _diffQuery moved calculation instead of applying change one at a\n        // time.\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n        if (reset) await self._collection.remove({});\n      },\n      // Apply an update.\n      // XXX better specify this interface (not in terms of a wire message)?\n      update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n        // *We receive an added message for a document that is already there. Instead, it will be changed\n        // *We reeive a change message for a document that is not there. Instead, it will be added\n        // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n        //Code is derived from client-side code originally in peerlibrary:control-mergebox\n        //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n        //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n        //https://github.com/meteor/meteor/pull/11151\n        if (Meteor.isClient) {\n          if (msg.msg === 'added' && doc) {\n            msg.msg = 'changed';\n          } else if (msg.msg === 'removed' && !doc) {\n            return;\n          } else if (msg.msg === 'changed' && !doc) {\n            msg.msg = 'added';\n            const _ref = msg.fields;\n            for (let field in _ref) {\n              const value = _ref[field];\n              if (value === void 0) {\n                delete msg.fields[field];\n              }\n            }\n          }\n        }\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) self._collection.remove(mongoId);\n          } else if (!doc) {\n            self._collection.insert(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            self._collection.update(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error('Expected not to find a document already present for an add');\n          }\n          self._collection.insert(_objectSpread({\n            _id: mongoId\n          }, msg.fields));\n        } else if (msg.msg === 'removed') {\n          if (!doc) throw new Error('Expected to find a document already present for removed');\n          self._collection.remove(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              self._collection.update(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n      // Called at the end of a batch of updates.livedata_connection.js:1287\n      endUpdate() {\n        self._collection.resumeObserversClient();\n      },\n      // Used to preserve current versions of documents across a store reset.\n      getDoc(id) {\n        return self.findOne(id);\n      }\n    }, wrappedStoreCommon);\n    const wrappedStoreServer = _objectSpread({\n      async beginUpdate(batchSize, reset) {\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n        if (reset) await self._collection.removeAsync({});\n      },\n      async update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) await self._collection.removeAsync(mongoId);\n          } else if (!doc) {\n            await self._collection.insertAsync(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            await self._collection.updateAsync(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error('Expected not to find a document already present for an add');\n          }\n          await self._collection.insertAsync(_objectSpread({\n            _id: mongoId\n          }, msg.fields));\n        } else if (msg.msg === 'removed') {\n          if (!doc) throw new Error('Expected to find a document already present for removed');\n          await self._collection.removeAsync(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              await self._collection.updateAsync(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n      // Called at the end of a batch of updates.\n      async endUpdate() {\n        await self._collection.resumeObserversServer();\n      },\n      // Used to preserve current versions of documents across a store reset.\n      async getDoc(id) {\n        return self.findOneAsync(id);\n      }\n    }, wrappedStoreCommon);\n\n    // OK, we're going to be a slave, replicating some remote\n    // database, except possibly with some temporary divergence while\n    // we have unacknowledged RPC's.\n    let registerStoreResult;\n    if (Meteor.isClient) {\n      registerStoreResult = self._connection.registerStoreClient(name, wrappedStoreClient);\n    } else {\n      registerStoreResult = self._connection.registerStoreServer(name, wrappedStoreServer);\n    }\n    const message = \"There is already a collection named \\\"\".concat(name, \"\\\"\");\n    const logWarn = () => {\n      console.warn ? console.warn(message) : console.log(message);\n    };\n    if (!registerStoreResult) {\n      return logWarn();\n    }\n    return (_registerStoreResult = registerStoreResult) === null || _registerStoreResult === void 0 ? void 0 : (_registerStoreResult$ = _registerStoreResult.then) === null || _registerStoreResult$ === void 0 ? void 0 : _registerStoreResult$.call(_registerStoreResult, ok => {\n      if (!ok) {\n        logWarn();\n      }\n    });\n  }\n};","map":{"version":3,"names":["_objectSpread","module","link","default","v","export","ReplicationMethods","_maybeSetUpReplication","name","_registerStoreResult","_registerStoreResult$","self","_connection","registerStoreClient","registerStoreServer","wrappedStoreCommon","saveOriginals","_collection","retrieveOriginals","_getCollection","wrappedStoreClient","beginUpdate","batchSize","reset","pauseObservers","remove","update","msg","mongoId","MongoID","idParse","id","doc","_docs","get","Meteor","isClient","_ref","fields","field","value","replace","insert","Error","_id","keys","Object","length","modifier","forEach","key","EJSON","equals","$unset","$set","endUpdate","resumeObserversClient","getDoc","findOne","wrappedStoreServer","removeAsync","insertAsync","updateAsync","resumeObserversServer","findOneAsync","registerStoreResult","message","concat","logWarn","console","warn","log","then","call","ok"],"sources":["packages/mongo/collection/methods_replication.js"],"sourcesContent":["export const ReplicationMethods = {\n  async _maybeSetUpReplication(name) {\n    const self = this;\n    if (\n      !(\n        self._connection &&\n        self._connection.registerStoreClient &&\n        self._connection.registerStoreServer\n      )\n    ) {\n      return;\n    }\n\n\n    const wrappedStoreCommon = {\n      // Called around method stub invocations to capture the original versions\n      // of modified documents.\n      saveOriginals() {\n        self._collection.saveOriginals();\n      },\n      retrieveOriginals() {\n        return self._collection.retrieveOriginals();\n      },\n      // To be able to get back to the collection from the store.\n      _getCollection() {\n        return self;\n      },\n    };\n    const wrappedStoreClient = {\n      // Called at the beginning of a batch of updates. batchSize is the number\n      // of update calls to expect.\n      //\n      // XXX This interface is pretty janky. reset probably ought to go back to\n      // being its own function, and callers shouldn't have to calculate\n      // batchSize. The optimization of not calling pause/remove should be\n      // delayed until later: the first call to update() should buffer its\n      // message, and then we can either directly apply it at endUpdate time if\n      // it was the only update, or do pauseObservers/apply/apply at the next\n      // update() if there's another one.\n      async beginUpdate(batchSize, reset) {\n        // pause observers so users don't see flicker when updating several\n        // objects at once (including the post-reconnect reset-and-reapply\n        // stage), and so that a re-sorting of a query can take advantage of the\n        // full _diffQuery moved calculation instead of applying change one at a\n        // time.\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.remove({});\n      },\n\n      // Apply an update.\n      // XXX better specify this interface (not in terms of a wire message)?\n      update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n        // *We receive an added message for a document that is already there. Instead, it will be changed\n        // *We reeive a change message for a document that is not there. Instead, it will be added\n        // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n        //Code is derived from client-side code originally in peerlibrary:control-mergebox\n        //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n        //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n        //https://github.com/meteor/meteor/pull/11151\n        if (Meteor.isClient) {\n          if (msg.msg === 'added' && doc) {\n            msg.msg = 'changed';\n          } else if (msg.msg === 'removed' && !doc) {\n            return;\n          } else if (msg.msg === 'changed' && !doc) {\n            msg.msg = 'added';\n            const _ref = msg.fields;\n            for (let field in _ref) {\n              const value = _ref[field];\n              if (value === void 0) {\n                delete msg.fields[field];\n              }\n            }\n          }\n        }\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) self._collection.remove(mongoId);\n          } else if (!doc) {\n            self._collection.insert(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            self._collection.update(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          self._collection.insert({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          self._collection.remove(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              self._collection.update(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.livedata_connection.js:1287\n      endUpdate() {\n        self._collection.resumeObserversClient();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      getDoc(id) {\n        return self.findOne(id);\n      },\n\n      ...wrappedStoreCommon,\n    };\n    const wrappedStoreServer = {\n      async beginUpdate(batchSize, reset) {\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.removeAsync({});\n      },\n\n      async update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) await self._collection.removeAsync(mongoId);\n          } else if (!doc) {\n            await self._collection.insertAsync(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            await self._collection.updateAsync(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          await self._collection.insertAsync({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          await self._collection.removeAsync(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              await self._collection.updateAsync(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.\n      async endUpdate() {\n        await self._collection.resumeObserversServer();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      async getDoc(id) {\n        return self.findOneAsync(id);\n      },\n      ...wrappedStoreCommon,\n    };\n\n\n    // OK, we're going to be a slave, replicating some remote\n    // database, except possibly with some temporary divergence while\n    // we have unacknowledged RPC's.\n    let registerStoreResult;\n    if (Meteor.isClient) {\n      registerStoreResult = self._connection.registerStoreClient(\n        name,\n        wrappedStoreClient\n      );\n    } else {\n      registerStoreResult = self._connection.registerStoreServer(\n        name,\n        wrappedStoreServer\n      );\n    }\n\n    const message = `There is already a collection named \"${name}\"`;\n    const logWarn = () => {\n      console.warn ? console.warn(message) : console.log(message);\n    };\n\n    if (!registerStoreResult) {\n      return logWarn();\n    }\n\n    return registerStoreResult?.then?.(ok => {\n      if (!ok) {\n        logWarn();\n      }\n    });\n  },\n}"],"mappings":"AAAA,IAAIA,aAAa;AAACC,MAAM,CAACC,IAAI,CAAC,sCAAsC,EAAC;EAACC,OAAOA,CAACC,CAAC,EAAC;IAACJ,aAAa,GAACI,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAArGH,MAAM,CAACI,MAAM,CAAC;EAACC,kBAAkB,EAACA,CAAA,KAAIA;AAAkB,CAAC,CAAC;AAAnD,MAAMA,kBAAkB,GAAG;EAChC,MAAMC,sBAAsBA,CAACC,IAAI,EAAE;IAAA,IAAAC,oBAAA,EAAAC,qBAAA;IACjC,MAAMC,IAAI,GAAG,IAAI;IACjB,IACE,EACEA,IAAI,CAACC,WAAW,IAChBD,IAAI,CAACC,WAAW,CAACC,mBAAmB,IACpCF,IAAI,CAACC,WAAW,CAACE,mBAAmB,CACrC,EACD;MACA;IACF;IAGA,MAAMC,kBAAkB,GAAG;MACzB;MACA;MACAC,aAAaA,CAAA,EAAG;QACdL,IAAI,CAACM,WAAW,CAACD,aAAa,CAAC,CAAC;MAClC,CAAC;MACDE,iBAAiBA,CAAA,EAAG;QAClB,OAAOP,IAAI,CAACM,WAAW,CAACC,iBAAiB,CAAC,CAAC;MAC7C,CAAC;MACD;MACAC,cAAcA,CAAA,EAAG;QACf,OAAOR,IAAI;MACb;IACF,CAAC;IACD,MAAMS,kBAAkB,GAAApB,aAAA;MACtB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMqB,WAAWA,CAACC,SAAS,EAAEC,KAAK,EAAE;QAClC;QACA;QACA;QACA;QACA;QACA,IAAID,SAAS,GAAG,CAAC,IAAIC,KAAK,EAAEZ,IAAI,CAACM,WAAW,CAACO,cAAc,CAAC,CAAC;QAE7D,IAAID,KAAK,EAAE,MAAMZ,IAAI,CAACM,WAAW,CAACQ,MAAM,CAAC,CAAC,CAAC,CAAC;MAC9C,CAAC;MAED;MACA;MACAC,MAAMA,CAACC,GAAG,EAAE;QACV,IAAIC,OAAO,GAAGC,OAAO,CAACC,OAAO,CAACH,GAAG,CAACI,EAAE,CAAC;QACrC,IAAIC,GAAG,GAAGrB,IAAI,CAACM,WAAW,CAACgB,KAAK,CAACC,GAAG,CAACN,OAAO,CAAC;;QAE7C;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;QACA,IAAIO,MAAM,CAACC,QAAQ,EAAE;UACnB,IAAIT,GAAG,CAACA,GAAG,KAAK,OAAO,IAAIK,GAAG,EAAE;YAC9BL,GAAG,CAACA,GAAG,GAAG,SAAS;UACrB,CAAC,MAAM,IAAIA,GAAG,CAACA,GAAG,KAAK,SAAS,IAAI,CAACK,GAAG,EAAE;YACxC;UACF,CAAC,MAAM,IAAIL,GAAG,CAACA,GAAG,KAAK,SAAS,IAAI,CAACK,GAAG,EAAE;YACxCL,GAAG,CAACA,GAAG,GAAG,OAAO;YACjB,MAAMU,IAAI,GAAGV,GAAG,CAACW,MAAM;YACvB,KAAK,IAAIC,KAAK,IAAIF,IAAI,EAAE;cACtB,MAAMG,KAAK,GAAGH,IAAI,CAACE,KAAK,CAAC;cACzB,IAAIC,KAAK,KAAK,KAAK,CAAC,EAAE;gBACpB,OAAOb,GAAG,CAACW,MAAM,CAACC,KAAK,CAAC;cAC1B;YACF;UACF;QACF;QACA;QACA;QACA;QACA,IAAIZ,GAAG,CAACA,GAAG,KAAK,SAAS,EAAE;UACzB,IAAIc,OAAO,GAAGd,GAAG,CAACc,OAAO;UACzB,IAAI,CAACA,OAAO,EAAE;YACZ,IAAIT,GAAG,EAAErB,IAAI,CAACM,WAAW,CAACQ,MAAM,CAACG,OAAO,CAAC;UAC3C,CAAC,MAAM,IAAI,CAACI,GAAG,EAAE;YACfrB,IAAI,CAACM,WAAW,CAACyB,MAAM,CAACD,OAAO,CAAC;UAClC,CAAC,MAAM;YACL;YACA9B,IAAI,CAACM,WAAW,CAACS,MAAM,CAACE,OAAO,EAAEa,OAAO,CAAC;UAC3C;UACA;QACF,CAAC,MAAM,IAAId,GAAG,CAACA,GAAG,KAAK,OAAO,EAAE;UAC9B,IAAIK,GAAG,EAAE;YACP,MAAM,IAAIW,KAAK,CACb,4DACF,CAAC;UACH;UACAhC,IAAI,CAACM,WAAW,CAACyB,MAAM,CAAA1C,aAAA;YAAG4C,GAAG,EAAEhB;UAAO,GAAKD,GAAG,CAACW,MAAM,CAAE,CAAC;QAC1D,CAAC,MAAM,IAAIX,GAAG,CAACA,GAAG,KAAK,SAAS,EAAE;UAChC,IAAI,CAACK,GAAG,EACN,MAAM,IAAIW,KAAK,CACb,yDACF,CAAC;UACHhC,IAAI,CAACM,WAAW,CAACQ,MAAM,CAACG,OAAO,CAAC;QAClC,CAAC,MAAM,IAAID,GAAG,CAACA,GAAG,KAAK,SAAS,EAAE;UAChC,IAAI,CAACK,GAAG,EAAE,MAAM,IAAIW,KAAK,CAAC,uCAAuC,CAAC;UAClE,MAAME,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAClB,GAAG,CAACW,MAAM,CAAC;UACpC,IAAIO,IAAI,CAACE,MAAM,GAAG,CAAC,EAAE;YACnB,IAAIC,QAAQ,GAAG,CAAC,CAAC;YACjBH,IAAI,CAACI,OAAO,CAACC,GAAG,IAAI;cAClB,MAAMV,KAAK,GAAGb,GAAG,CAACW,MAAM,CAACY,GAAG,CAAC;cAC7B,IAAIC,KAAK,CAACC,MAAM,CAACpB,GAAG,CAACkB,GAAG,CAAC,EAAEV,KAAK,CAAC,EAAE;gBACjC;cACF;cACA,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;gBAChC,IAAI,CAACQ,QAAQ,CAACK,MAAM,EAAE;kBACpBL,QAAQ,CAACK,MAAM,GAAG,CAAC,CAAC;gBACtB;gBACAL,QAAQ,CAACK,MAAM,CAACH,GAAG,CAAC,GAAG,CAAC;cAC1B,CAAC,MAAM;gBACL,IAAI,CAACF,QAAQ,CAACM,IAAI,EAAE;kBAClBN,QAAQ,CAACM,IAAI,GAAG,CAAC,CAAC;gBACpB;gBACAN,QAAQ,CAACM,IAAI,CAACJ,GAAG,CAAC,GAAGV,KAAK;cAC5B;YACF,CAAC,CAAC;YACF,IAAIM,MAAM,CAACD,IAAI,CAACG,QAAQ,CAAC,CAACD,MAAM,GAAG,CAAC,EAAE;cACpCpC,IAAI,CAACM,WAAW,CAACS,MAAM,CAACE,OAAO,EAAEoB,QAAQ,CAAC;YAC5C;UACF;QACF,CAAC,MAAM;UACL,MAAM,IAAIL,KAAK,CAAC,4CAA4C,CAAC;QAC/D;MACF,CAAC;MAED;MACAY,SAASA,CAAA,EAAG;QACV5C,IAAI,CAACM,WAAW,CAACuC,qBAAqB,CAAC,CAAC;MAC1C,CAAC;MAED;MACAC,MAAMA,CAAC1B,EAAE,EAAE;QACT,OAAOpB,IAAI,CAAC+C,OAAO,CAAC3B,EAAE,CAAC;MACzB;IAAC,GAEEhB,kBAAkB,CACtB;IACD,MAAM4C,kBAAkB,GAAA3D,aAAA;MACtB,MAAMqB,WAAWA,CAACC,SAAS,EAAEC,KAAK,EAAE;QAClC,IAAID,SAAS,GAAG,CAAC,IAAIC,KAAK,EAAEZ,IAAI,CAACM,WAAW,CAACO,cAAc,CAAC,CAAC;QAE7D,IAAID,KAAK,EAAE,MAAMZ,IAAI,CAACM,WAAW,CAAC2C,WAAW,CAAC,CAAC,CAAC,CAAC;MACnD,CAAC;MAED,MAAMlC,MAAMA,CAACC,GAAG,EAAE;QAChB,IAAIC,OAAO,GAAGC,OAAO,CAACC,OAAO,CAACH,GAAG,CAACI,EAAE,CAAC;QACrC,IAAIC,GAAG,GAAGrB,IAAI,CAACM,WAAW,CAACgB,KAAK,CAACC,GAAG,CAACN,OAAO,CAAC;;QAE7C;QACA;QACA;QACA,IAAID,GAAG,CAACA,GAAG,KAAK,SAAS,EAAE;UACzB,IAAIc,OAAO,GAAGd,GAAG,CAACc,OAAO;UACzB,IAAI,CAACA,OAAO,EAAE;YACZ,IAAIT,GAAG,EAAE,MAAMrB,IAAI,CAACM,WAAW,CAAC2C,WAAW,CAAChC,OAAO,CAAC;UACtD,CAAC,MAAM,IAAI,CAACI,GAAG,EAAE;YACf,MAAMrB,IAAI,CAACM,WAAW,CAAC4C,WAAW,CAACpB,OAAO,CAAC;UAC7C,CAAC,MAAM;YACL;YACA,MAAM9B,IAAI,CAACM,WAAW,CAAC6C,WAAW,CAAClC,OAAO,EAAEa,OAAO,CAAC;UACtD;UACA;QACF,CAAC,MAAM,IAAId,GAAG,CAACA,GAAG,KAAK,OAAO,EAAE;UAC9B,IAAIK,GAAG,EAAE;YACP,MAAM,IAAIW,KAAK,CACb,4DACF,CAAC;UACH;UACA,MAAMhC,IAAI,CAACM,WAAW,CAAC4C,WAAW,CAAA7D,aAAA;YAAG4C,GAAG,EAAEhB;UAAO,GAAKD,GAAG,CAACW,MAAM,CAAE,CAAC;QACrE,CAAC,MAAM,IAAIX,GAAG,CAACA,GAAG,KAAK,SAAS,EAAE;UAChC,IAAI,CAACK,GAAG,EACN,MAAM,IAAIW,KAAK,CACb,yDACF,CAAC;UACH,MAAMhC,IAAI,CAACM,WAAW,CAAC2C,WAAW,CAAChC,OAAO,CAAC;QAC7C,CAAC,MAAM,IAAID,GAAG,CAACA,GAAG,KAAK,SAAS,EAAE;UAChC,IAAI,CAACK,GAAG,EAAE,MAAM,IAAIW,KAAK,CAAC,uCAAuC,CAAC;UAClE,MAAME,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAClB,GAAG,CAACW,MAAM,CAAC;UACpC,IAAIO,IAAI,CAACE,MAAM,GAAG,CAAC,EAAE;YACnB,IAAIC,QAAQ,GAAG,CAAC,CAAC;YACjBH,IAAI,CAACI,OAAO,CAACC,GAAG,IAAI;cAClB,MAAMV,KAAK,GAAGb,GAAG,CAACW,MAAM,CAACY,GAAG,CAAC;cAC7B,IAAIC,KAAK,CAACC,MAAM,CAACpB,GAAG,CAACkB,GAAG,CAAC,EAAEV,KAAK,CAAC,EAAE;gBACjC;cACF;cACA,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;gBAChC,IAAI,CAACQ,QAAQ,CAACK,MAAM,EAAE;kBACpBL,QAAQ,CAACK,MAAM,GAAG,CAAC,CAAC;gBACtB;gBACAL,QAAQ,CAACK,MAAM,CAACH,GAAG,CAAC,GAAG,CAAC;cAC1B,CAAC,MAAM;gBACL,IAAI,CAACF,QAAQ,CAACM,IAAI,EAAE;kBAClBN,QAAQ,CAACM,IAAI,GAAG,CAAC,CAAC;gBACpB;gBACAN,QAAQ,CAACM,IAAI,CAACJ,GAAG,CAAC,GAAGV,KAAK;cAC5B;YACF,CAAC,CAAC;YACF,IAAIM,MAAM,CAACD,IAAI,CAACG,QAAQ,CAAC,CAACD,MAAM,GAAG,CAAC,EAAE;cACpC,MAAMpC,IAAI,CAACM,WAAW,CAAC6C,WAAW,CAAClC,OAAO,EAAEoB,QAAQ,CAAC;YACvD;UACF;QACF,CAAC,MAAM;UACL,MAAM,IAAIL,KAAK,CAAC,4CAA4C,CAAC;QAC/D;MACF,CAAC;MAED;MACA,MAAMY,SAASA,CAAA,EAAG;QAChB,MAAM5C,IAAI,CAACM,WAAW,CAAC8C,qBAAqB,CAAC,CAAC;MAChD,CAAC;MAED;MACA,MAAMN,MAAMA,CAAC1B,EAAE,EAAE;QACf,OAAOpB,IAAI,CAACqD,YAAY,CAACjC,EAAE,CAAC;MAC9B;IAAC,GACEhB,kBAAkB,CACtB;;IAGD;IACA;IACA;IACA,IAAIkD,mBAAmB;IACvB,IAAI9B,MAAM,CAACC,QAAQ,EAAE;MACnB6B,mBAAmB,GAAGtD,IAAI,CAACC,WAAW,CAACC,mBAAmB,CACxDL,IAAI,EACJY,kBACF,CAAC;IACH,CAAC,MAAM;MACL6C,mBAAmB,GAAGtD,IAAI,CAACC,WAAW,CAACE,mBAAmB,CACxDN,IAAI,EACJmD,kBACF,CAAC;IACH;IAEA,MAAMO,OAAO,4CAAAC,MAAA,CAA2C3D,IAAI,OAAG;IAC/D,MAAM4D,OAAO,GAAGA,CAAA,KAAM;MACpBC,OAAO,CAACC,IAAI,GAAGD,OAAO,CAACC,IAAI,CAACJ,OAAO,CAAC,GAAGG,OAAO,CAACE,GAAG,CAACL,OAAO,CAAC;IAC7D,CAAC;IAED,IAAI,CAACD,mBAAmB,EAAE;MACxB,OAAOG,OAAO,CAAC,CAAC;IAClB;IAEA,QAAA3D,oBAAA,GAAOwD,mBAAmB,cAAAxD,oBAAA,wBAAAC,qBAAA,GAAnBD,oBAAA,CAAqB+D,IAAI,cAAA9D,qBAAA,uBAAzBA,qBAAA,CAAA+D,IAAA,CAAAhE,oBAAA,EAA4BiE,EAAE,IAAI;MACvC,IAAI,CAACA,EAAE,EAAE;QACPN,OAAO,CAAC,CAAC;MACX;IACF,CAAC,CAAC;EACJ;AACF,CAAC","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"b0125e3a665c1fd12e7ad8f9a7074644de9f7e17"}

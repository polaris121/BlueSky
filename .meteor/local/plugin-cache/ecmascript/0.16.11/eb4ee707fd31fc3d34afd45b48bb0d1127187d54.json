{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/mongo/collection/methods_replication.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\collection\\methods_replication.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/collection/methods_replication.js"}},"code":"var _regeneratorRuntime;\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 0);\nvar _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default: function (v) {\n    _objectSpread = v;\n  }\n}, 1);\nmodule.export({\n  ReplicationMethods: function () {\n    return ReplicationMethods;\n  }\n});\nvar ReplicationMethods = {\n  _maybeSetUpReplication: function () {\n    function _callee6(name) {\n      var _registerStoreResult, _registerStoreResult$;\n      var self, wrappedStoreCommon, wrappedStoreClient, wrappedStoreServer, registerStoreResult, message, logWarn;\n      return _regeneratorRuntime.async(function (_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            self = this;\n            if (self._connection && self._connection.registerStoreClient && self._connection.registerStoreServer) {\n              _context6.next = 1;\n              break;\n            }\n            return _context6.abrupt(\"return\");\n          case 1:\n            wrappedStoreCommon = {\n              // Called around method stub invocations to capture the original versions\n              // of modified documents.\n              saveOriginals: function () {\n                self._collection.saveOriginals();\n              },\n              retrieveOriginals: function () {\n                return self._collection.retrieveOriginals();\n              },\n              // To be able to get back to the collection from the store.\n              _getCollection: function () {\n                return self;\n              }\n            };\n            wrappedStoreClient = _objectSpread({\n              // Called at the beginning of a batch of updates. batchSize is the number\n              // of update calls to expect.\n              //\n              // XXX This interface is pretty janky. reset probably ought to go back to\n              // being its own function, and callers shouldn't have to calculate\n              // batchSize. The optimization of not calling pause/remove should be\n              // delayed until later: the first call to update() should buffer its\n              // message, and then we can either directly apply it at endUpdate time if\n              // it was the only update, or do pauseObservers/apply/apply at the next\n              // update() if there's another one.\n              beginUpdate: function () {\n                function _callee(batchSize, reset) {\n                  return _regeneratorRuntime.async(function (_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        // pause observers so users don't see flicker when updating several\n                        // objects at once (including the post-reconnect reset-and-reapply\n                        // stage), and so that a re-sorting of a query can take advantage of the\n                        // full _diffQuery moved calculation instead of applying change one at a\n                        // time.\n                        if (batchSize > 1 || reset) self._collection.pauseObservers();\n                        if (!reset) {\n                          _context.next = 1;\n                          break;\n                        }\n                        _context.next = 1;\n                        return _regeneratorRuntime.awrap(self._collection.remove({}));\n                      case 1:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, null, null, null, Promise);\n                }\n                return _callee;\n              }(),\n              // Apply an update.\n              // XXX better specify this interface (not in terms of a wire message)?\n              update: function (msg) {\n                var mongoId = MongoID.idParse(msg.id);\n                var doc = self._collection._docs.get(mongoId);\n\n                //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n                // *We receive an added message for a document that is already there. Instead, it will be changed\n                // *We reeive a change message for a document that is not there. Instead, it will be added\n                // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n                //Code is derived from client-side code originally in peerlibrary:control-mergebox\n                //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n                //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n                //https://github.com/meteor/meteor/pull/11151\n                if (Meteor.isClient) {\n                  if (msg.msg === 'added' && doc) {\n                    msg.msg = 'changed';\n                  } else if (msg.msg === 'removed' && !doc) {\n                    return;\n                  } else if (msg.msg === 'changed' && !doc) {\n                    msg.msg = 'added';\n                    var _ref = msg.fields;\n                    for (var field in meteorBabelHelpers.sanitizeForInObject(_ref)) {\n                      var value = _ref[field];\n                      if (value === void 0) {\n                        delete msg.fields[field];\n                      }\n                    }\n                  }\n                }\n                // Is this a \"replace the whole doc\" message coming from the quiescence\n                // of method writes to an object? (Note that 'undefined' is a valid\n                // value meaning \"remove it\".)\n                if (msg.msg === 'replace') {\n                  var replace = msg.replace;\n                  if (!replace) {\n                    if (doc) self._collection.remove(mongoId);\n                  } else if (!doc) {\n                    self._collection.insert(replace);\n                  } else {\n                    // XXX check that replace has no $ ops\n                    self._collection.update(mongoId, replace);\n                  }\n                  return;\n                } else if (msg.msg === 'added') {\n                  if (doc) {\n                    throw new Error('Expected not to find a document already present for an add');\n                  }\n                  self._collection.insert(_objectSpread({\n                    _id: mongoId\n                  }, msg.fields));\n                } else if (msg.msg === 'removed') {\n                  if (!doc) throw new Error('Expected to find a document already present for removed');\n                  self._collection.remove(mongoId);\n                } else if (msg.msg === 'changed') {\n                  if (!doc) throw new Error('Expected to find a document to change');\n                  var keys = Object.keys(msg.fields);\n                  if (keys.length > 0) {\n                    var modifier = {};\n                    keys.forEach(function (key) {\n                      var value = msg.fields[key];\n                      if (EJSON.equals(doc[key], value)) {\n                        return;\n                      }\n                      if (typeof value === 'undefined') {\n                        if (!modifier.$unset) {\n                          modifier.$unset = {};\n                        }\n                        modifier.$unset[key] = 1;\n                      } else {\n                        if (!modifier.$set) {\n                          modifier.$set = {};\n                        }\n                        modifier.$set[key] = value;\n                      }\n                    });\n                    if (Object.keys(modifier).length > 0) {\n                      self._collection.update(mongoId, modifier);\n                    }\n                  }\n                } else {\n                  throw new Error(\"I don't know how to deal with this message\");\n                }\n              },\n              // Called at the end of a batch of updates.livedata_connection.js:1287\n              endUpdate: function () {\n                self._collection.resumeObserversClient();\n              },\n              // Used to preserve current versions of documents across a store reset.\n              getDoc: function (id) {\n                return self.findOne(id);\n              }\n            }, wrappedStoreCommon);\n            wrappedStoreServer = _objectSpread({\n              beginUpdate: function () {\n                function _callee2(batchSize, reset) {\n                  return _regeneratorRuntime.async(function (_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        if (batchSize > 1 || reset) self._collection.pauseObservers();\n                        if (!reset) {\n                          _context2.next = 1;\n                          break;\n                        }\n                        _context2.next = 1;\n                        return _regeneratorRuntime.awrap(self._collection.removeAsync({}));\n                      case 1:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, null, null, null, Promise);\n                }\n                return _callee2;\n              }(),\n              update: function () {\n                function _callee3(msg) {\n                  var mongoId, doc, replace, keys, modifier;\n                  return _regeneratorRuntime.async(function (_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        mongoId = MongoID.idParse(msg.id);\n                        doc = self._collection._docs.get(mongoId); // Is this a \"replace the whole doc\" message coming from the quiescence\n                        // of method writes to an object? (Note that 'undefined' is a valid\n                        // value meaning \"remove it\".)\n                        if (!(msg.msg === 'replace')) {\n                          _context3.next = 6;\n                          break;\n                        }\n                        replace = msg.replace;\n                        if (replace) {\n                          _context3.next = 2;\n                          break;\n                        }\n                        if (!doc) {\n                          _context3.next = 1;\n                          break;\n                        }\n                        _context3.next = 1;\n                        return _regeneratorRuntime.awrap(self._collection.removeAsync(mongoId));\n                      case 1:\n                        _context3.next = 5;\n                        break;\n                      case 2:\n                        if (doc) {\n                          _context3.next = 4;\n                          break;\n                        }\n                        _context3.next = 3;\n                        return _regeneratorRuntime.awrap(self._collection.insertAsync(replace));\n                      case 3:\n                        _context3.next = 5;\n                        break;\n                      case 4:\n                        _context3.next = 5;\n                        return _regeneratorRuntime.awrap(self._collection.updateAsync(mongoId, replace));\n                      case 5:\n                        return _context3.abrupt(\"return\");\n                      case 6:\n                        if (!(msg.msg === 'added')) {\n                          _context3.next = 9;\n                          break;\n                        }\n                        if (!doc) {\n                          _context3.next = 7;\n                          break;\n                        }\n                        throw new Error('Expected not to find a document already present for an add');\n                      case 7:\n                        _context3.next = 8;\n                        return _regeneratorRuntime.awrap(self._collection.insertAsync(_objectSpread({\n                          _id: mongoId\n                        }, msg.fields)));\n                      case 8:\n                        _context3.next = 16;\n                        break;\n                      case 9:\n                        if (!(msg.msg === 'removed')) {\n                          _context3.next = 12;\n                          break;\n                        }\n                        if (doc) {\n                          _context3.next = 10;\n                          break;\n                        }\n                        throw new Error('Expected to find a document already present for removed');\n                      case 10:\n                        _context3.next = 11;\n                        return _regeneratorRuntime.awrap(self._collection.removeAsync(mongoId));\n                      case 11:\n                        _context3.next = 16;\n                        break;\n                      case 12:\n                        if (!(msg.msg === 'changed')) {\n                          _context3.next = 15;\n                          break;\n                        }\n                        if (doc) {\n                          _context3.next = 13;\n                          break;\n                        }\n                        throw new Error('Expected to find a document to change');\n                      case 13:\n                        keys = Object.keys(msg.fields);\n                        if (!(keys.length > 0)) {\n                          _context3.next = 14;\n                          break;\n                        }\n                        modifier = {};\n                        keys.forEach(function (key) {\n                          var value = msg.fields[key];\n                          if (EJSON.equals(doc[key], value)) {\n                            return;\n                          }\n                          if (typeof value === 'undefined') {\n                            if (!modifier.$unset) {\n                              modifier.$unset = {};\n                            }\n                            modifier.$unset[key] = 1;\n                          } else {\n                            if (!modifier.$set) {\n                              modifier.$set = {};\n                            }\n                            modifier.$set[key] = value;\n                          }\n                        });\n                        if (!(Object.keys(modifier).length > 0)) {\n                          _context3.next = 14;\n                          break;\n                        }\n                        _context3.next = 14;\n                        return _regeneratorRuntime.awrap(self._collection.updateAsync(mongoId, modifier));\n                      case 14:\n                        _context3.next = 16;\n                        break;\n                      case 15:\n                        throw new Error(\"I don't know how to deal with this message\");\n                      case 16:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, null, null, null, Promise);\n                }\n                return _callee3;\n              }(),\n              // Called at the end of a batch of updates.\n              endUpdate: function () {\n                function _callee4() {\n                  return _regeneratorRuntime.async(function (_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.next = 1;\n                        return _regeneratorRuntime.awrap(self._collection.resumeObserversServer());\n                      case 1:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, null, null, null, Promise);\n                }\n                return _callee4;\n              }(),\n              // Used to preserve current versions of documents across a store reset.\n              getDoc: function () {\n                function _callee5(id) {\n                  return _regeneratorRuntime.async(function (_context5) {\n                    while (1) switch (_context5.prev = _context5.next) {\n                      case 0:\n                        return _context5.abrupt(\"return\", self.findOneAsync(id));\n                      case 1:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }, null, null, null, Promise);\n                }\n                return _callee5;\n              }()\n            }, wrappedStoreCommon); // OK, we're going to be a slave, replicating some remote\n            // database, except possibly with some temporary divergence while\n            // we have unacknowledged RPC's.\n            if (Meteor.isClient) {\n              registerStoreResult = self._connection.registerStoreClient(name, wrappedStoreClient);\n            } else {\n              registerStoreResult = self._connection.registerStoreServer(name, wrappedStoreServer);\n            }\n            message = \"There is already a collection named \\\"\" + name + \"\\\"\";\n            logWarn = function () {\n              console.warn ? console.warn(message) : console.log(message);\n            };\n            if (registerStoreResult) {\n              _context6.next = 2;\n              break;\n            }\n            return _context6.abrupt(\"return\", logWarn());\n          case 2:\n            return _context6.abrupt(\"return\", (_registerStoreResult = registerStoreResult) === null || _registerStoreResult === void 0 ? void 0 : (_registerStoreResult$ = _registerStoreResult.then) === null || _registerStoreResult$ === void 0 ? void 0 : _registerStoreResult$.call(_registerStoreResult, function (ok) {\n              if (!ok) {\n                logWarn();\n              }\n            }));\n          case 3:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, null, this, null, Promise);\n    }\n    return _callee6;\n  }()\n};","map":{"version":3,"names":["_regeneratorRuntime","module","link","default","v","_objectSpread","export","ReplicationMethods","_maybeSetUpReplication","_callee6","name","_registerStoreResult","_registerStoreResult$","self","wrappedStoreCommon","wrappedStoreClient","wrappedStoreServer","registerStoreResult","message","logWarn","async","_context6","prev","next","_connection","registerStoreClient","registerStoreServer","abrupt","saveOriginals","_collection","retrieveOriginals","_getCollection","beginUpdate","_callee","batchSize","reset","_context","pauseObservers","awrap","remove","stop","Promise","update","msg","mongoId","MongoID","idParse","id","doc","_docs","get","Meteor","isClient","_ref","fields","field","meteorBabelHelpers","sanitizeForInObject","value","replace","insert","Error","_id","keys","Object","length","modifier","forEach","key","EJSON","equals","$unset","$set","endUpdate","resumeObserversClient","getDoc","findOne","_callee2","_context2","removeAsync","_callee3","_context3","insertAsync","updateAsync","_callee4","_context4","resumeObserversServer","_callee5","_context5","findOneAsync","console","warn","log","then","call","ok"],"sources":["packages/mongo/collection/methods_replication.js"],"sourcesContent":["export const ReplicationMethods = {\n  async _maybeSetUpReplication(name) {\n    const self = this;\n    if (\n      !(\n        self._connection &&\n        self._connection.registerStoreClient &&\n        self._connection.registerStoreServer\n      )\n    ) {\n      return;\n    }\n\n\n    const wrappedStoreCommon = {\n      // Called around method stub invocations to capture the original versions\n      // of modified documents.\n      saveOriginals() {\n        self._collection.saveOriginals();\n      },\n      retrieveOriginals() {\n        return self._collection.retrieveOriginals();\n      },\n      // To be able to get back to the collection from the store.\n      _getCollection() {\n        return self;\n      },\n    };\n    const wrappedStoreClient = {\n      // Called at the beginning of a batch of updates. batchSize is the number\n      // of update calls to expect.\n      //\n      // XXX This interface is pretty janky. reset probably ought to go back to\n      // being its own function, and callers shouldn't have to calculate\n      // batchSize. The optimization of not calling pause/remove should be\n      // delayed until later: the first call to update() should buffer its\n      // message, and then we can either directly apply it at endUpdate time if\n      // it was the only update, or do pauseObservers/apply/apply at the next\n      // update() if there's another one.\n      async beginUpdate(batchSize, reset) {\n        // pause observers so users don't see flicker when updating several\n        // objects at once (including the post-reconnect reset-and-reapply\n        // stage), and so that a re-sorting of a query can take advantage of the\n        // full _diffQuery moved calculation instead of applying change one at a\n        // time.\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.remove({});\n      },\n\n      // Apply an update.\n      // XXX better specify this interface (not in terms of a wire message)?\n      update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n        // *We receive an added message for a document that is already there. Instead, it will be changed\n        // *We reeive a change message for a document that is not there. Instead, it will be added\n        // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n        //Code is derived from client-side code originally in peerlibrary:control-mergebox\n        //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n        //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n        //https://github.com/meteor/meteor/pull/11151\n        if (Meteor.isClient) {\n          if (msg.msg === 'added' && doc) {\n            msg.msg = 'changed';\n          } else if (msg.msg === 'removed' && !doc) {\n            return;\n          } else if (msg.msg === 'changed' && !doc) {\n            msg.msg = 'added';\n            const _ref = msg.fields;\n            for (let field in _ref) {\n              const value = _ref[field];\n              if (value === void 0) {\n                delete msg.fields[field];\n              }\n            }\n          }\n        }\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) self._collection.remove(mongoId);\n          } else if (!doc) {\n            self._collection.insert(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            self._collection.update(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          self._collection.insert({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          self._collection.remove(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              self._collection.update(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.livedata_connection.js:1287\n      endUpdate() {\n        self._collection.resumeObserversClient();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      getDoc(id) {\n        return self.findOne(id);\n      },\n\n      ...wrappedStoreCommon,\n    };\n    const wrappedStoreServer = {\n      async beginUpdate(batchSize, reset) {\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.removeAsync({});\n      },\n\n      async update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) await self._collection.removeAsync(mongoId);\n          } else if (!doc) {\n            await self._collection.insertAsync(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            await self._collection.updateAsync(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          await self._collection.insertAsync({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          await self._collection.removeAsync(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              await self._collection.updateAsync(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.\n      async endUpdate() {\n        await self._collection.resumeObserversServer();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      async getDoc(id) {\n        return self.findOneAsync(id);\n      },\n      ...wrappedStoreCommon,\n    };\n\n\n    // OK, we're going to be a slave, replicating some remote\n    // database, except possibly with some temporary divergence while\n    // we have unacknowledged RPC's.\n    let registerStoreResult;\n    if (Meteor.isClient) {\n      registerStoreResult = self._connection.registerStoreClient(\n        name,\n        wrappedStoreClient\n      );\n    } else {\n      registerStoreResult = self._connection.registerStoreServer(\n        name,\n        wrappedStoreServer\n      );\n    }\n\n    const message = `There is already a collection named \"${name}\"`;\n    const logWarn = () => {\n      console.warn ? console.warn(message) : console.log(message);\n    };\n\n    if (!registerStoreResult) {\n      return logWarn();\n    }\n\n    return registerStoreResult?.then?.(ok => {\n      if (!ok) {\n        logWarn();\n      }\n    });\n  },\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"eb4ee707fd31fc3d34afd45b48bb0d1127187d54"}

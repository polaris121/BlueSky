{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/ddp-client/common/message_processors.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\message_processors.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-client/common/message_processors.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      MessageProcessors: () => MessageProcessors\n    });\n    let DDPCommon;\n    module.link(\"meteor/ddp-common\", {\n      DDPCommon(v) {\n        DDPCommon = v;\n      }\n    }, 0);\n    let Meteor;\n    module.link(\"meteor/meteor\", {\n      Meteor(v) {\n        Meteor = v;\n      }\n    }, 1);\n    let DDP;\n    module.link(\"./namespace.js\", {\n      DDP(v) {\n        DDP = v;\n      }\n    }, 2);\n    let EJSON;\n    module.link(\"meteor/ejson\", {\n      EJSON(v) {\n        EJSON = v;\n      }\n    }, 3);\n    let isEmpty, hasOwn;\n    module.link(\"meteor/ddp-common/utils\", {\n      isEmpty(v) {\n        isEmpty = v;\n      },\n      hasOwn(v) {\n        hasOwn = v;\n      }\n    }, 4);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class MessageProcessors {\n      constructor(connection) {\n        this._connection = connection;\n      }\n\n      /**\n       * @summary Process the connection message and set up the session\n       * @param {Object} msg The connection message\n       */\n      async _livedata_connected(msg) {\n        const self = this._connection;\n        if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n          self._heartbeat = new DDPCommon.Heartbeat({\n            heartbeatInterval: self._heartbeatInterval,\n            heartbeatTimeout: self._heartbeatTimeout,\n            onTimeout() {\n              self._lostConnection(new DDP.ConnectionError('DDP heartbeat timed out'));\n            },\n            sendPing() {\n              self._send({\n                msg: 'ping'\n              });\n            }\n          });\n          self._heartbeat.start();\n        }\n\n        // If this is a reconnect, we'll have to reset all stores.\n        if (self._lastSessionId) self._resetStores = true;\n        let reconnectedToPreviousSession;\n        if (typeof msg.session === 'string') {\n          reconnectedToPreviousSession = self._lastSessionId === msg.session;\n          self._lastSessionId = msg.session;\n        }\n        if (reconnectedToPreviousSession) {\n          // Successful reconnection -- pick up where we left off.\n          return;\n        }\n\n        // Server doesn't have our data anymore. Re-sync a new session.\n\n        // Forget about messages we were buffering for unknown collections. They'll\n        // be resent if still relevant.\n        self._updatesForUnknownStores = Object.create(null);\n        if (self._resetStores) {\n          // Forget about the effects of stubs. We'll be resetting all collections\n          // anyway.\n          self._documentsWrittenByStub = Object.create(null);\n          self._serverDocuments = Object.create(null);\n        }\n\n        // Clear _afterUpdateCallbacks.\n        self._afterUpdateCallbacks = [];\n\n        // Mark all named subscriptions which are ready as needing to be revived.\n        self._subsBeingRevived = Object.create(null);\n        Object.entries(self._subscriptions).forEach(_ref => {\n          let [id, sub] = _ref;\n          if (sub.ready) {\n            self._subsBeingRevived[id] = true;\n          }\n        });\n\n        // Arrange for \"half-finished\" methods to have their callbacks run, and\n        // track methods that were sent on this connection so that we don't\n        // quiesce until they are all done.\n        //\n        // Start by clearing _methodsBlockingQuiescence: methods sent before\n        // reconnect don't matter, and any \"wait\" methods sent on the new connection\n        // that we drop here will be restored by the loop below.\n        self._methodsBlockingQuiescence = Object.create(null);\n        if (self._resetStores) {\n          const invokers = self._methodInvokers;\n          Object.keys(invokers).forEach(id => {\n            const invoker = invokers[id];\n            if (invoker.gotResult()) {\n              // This method already got its result, but it didn't call its callback\n              // because its data didn't become visible. We did not resend the\n              // method RPC. We'll call its callback when we get a full quiesce,\n              // since that's as close as we'll get to \"data must be visible\".\n              self._afterUpdateCallbacks.push(function () {\n                return invoker.dataVisible(...arguments);\n              });\n            } else if (invoker.sentMessage) {\n              // This method has been sent on this connection (maybe as a resend\n              // from the last connection, maybe from onReconnect, maybe just very\n              // quickly before processing the connected message).\n              //\n              // We don't need to do anything special to ensure its callbacks get\n              // called, but we'll count it as a method which is preventing\n              // reconnect quiescence. (eg, it might be a login method that was run\n              // from onReconnect, and we don't want to see flicker by seeing a\n              // logged-out state.)\n              self._methodsBlockingQuiescence[invoker.methodId] = true;\n            }\n          });\n        }\n        self._messagesBufferedUntilQuiescence = [];\n\n        // If we're not waiting on any methods or subs, we can reset the stores and\n        // call the callbacks immediately.\n        if (!self._waitingForQuiescence()) {\n          if (self._resetStores) {\n            for (const store of Object.values(self._stores)) {\n              await store.beginUpdate(0, true);\n              await store.endUpdate();\n            }\n            self._resetStores = false;\n          }\n          self._runAfterUpdateCallbacks();\n        }\n      }\n\n      /**\n       * @summary Process various data messages from the server\n       * @param {Object} msg The data message\n       */\n      async _livedata_data(msg) {\n        const self = this._connection;\n        if (self._waitingForQuiescence()) {\n          self._messagesBufferedUntilQuiescence.push(msg);\n          if (msg.msg === 'nosub') {\n            delete self._subsBeingRevived[msg.id];\n          }\n          if (msg.subs) {\n            msg.subs.forEach(subId => {\n              delete self._subsBeingRevived[subId];\n            });\n          }\n          if (msg.methods) {\n            msg.methods.forEach(methodId => {\n              delete self._methodsBlockingQuiescence[methodId];\n            });\n          }\n          if (self._waitingForQuiescence()) {\n            return;\n          }\n\n          // No methods or subs are blocking quiescence!\n          // We'll now process and all of our buffered messages, reset all stores,\n          // and apply them all at once.\n          const bufferedMessages = self._messagesBufferedUntilQuiescence;\n          for (const bufferedMessage of Object.values(bufferedMessages)) {\n            await this._processOneDataMessage(bufferedMessage, self._bufferedWrites);\n          }\n          self._messagesBufferedUntilQuiescence = [];\n        } else {\n          await this._processOneDataMessage(msg, self._bufferedWrites);\n        }\n\n        // Immediately flush writes when:\n        //  1. Buffering is disabled. Or;\n        //  2. any non-(added/changed/removed) message arrives.\n        const standardWrite = msg.msg === \"added\" || msg.msg === \"changed\" || msg.msg === \"removed\";\n        if (self._bufferedWritesInterval === 0 || !standardWrite) {\n          await self._flushBufferedWrites();\n          return;\n        }\n        if (self._bufferedWritesFlushAt === null) {\n          self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n        } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n          await self._flushBufferedWrites();\n          return;\n        }\n        if (self._bufferedWritesFlushHandle) {\n          clearTimeout(self._bufferedWritesFlushHandle);\n        }\n        self._bufferedWritesFlushHandle = setTimeout(() => {\n          self._liveDataWritesPromise = self._flushBufferedWrites();\n          if (Meteor._isPromise(self._liveDataWritesPromise)) {\n            self._liveDataWritesPromise.finally(() => self._liveDataWritesPromise = undefined);\n          }\n        }, self._bufferedWritesInterval);\n      }\n\n      /**\n       * @summary Process individual data messages by type\n       * @private\n       */\n      async _processOneDataMessage(msg, updates) {\n        const messageType = msg.msg;\n        switch (messageType) {\n          case 'added':\n            await this._connection._process_added(msg, updates);\n            break;\n          case 'changed':\n            this._connection._process_changed(msg, updates);\n            break;\n          case 'removed':\n            this._connection._process_removed(msg, updates);\n            break;\n          case 'ready':\n            this._connection._process_ready(msg, updates);\n            break;\n          case 'updated':\n            this._connection._process_updated(msg, updates);\n            break;\n          case 'nosub':\n            // ignore this\n            break;\n          default:\n            Meteor._debug('discarding unknown livedata data message type', msg);\n        }\n      }\n\n      /**\n       * @summary Handle method results arriving from the server\n       * @param {Object} msg The method result message\n       */\n      async _livedata_result(msg) {\n        const self = this._connection;\n\n        // Lets make sure there are no buffered writes before returning result.\n        if (!isEmpty(self._bufferedWrites)) {\n          await self._flushBufferedWrites();\n        }\n\n        // find the outstanding request\n        // should be O(1) in nearly all realistic use cases\n        if (isEmpty(self._outstandingMethodBlocks)) {\n          Meteor._debug('Received method result but no methods outstanding');\n          return;\n        }\n        const currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n        let i;\n        const m = currentMethodBlock.find((method, idx) => {\n          const found = method.methodId === msg.id;\n          if (found) i = idx;\n          return found;\n        });\n        if (!m) {\n          Meteor._debug(\"Can't match method response to original method call\", msg);\n          return;\n        }\n\n        // Remove from current method block. This may leave the block empty, but we\n        // don't move on to the next block until the callback has been delivered, in\n        // _outstandingMethodFinished.\n        currentMethodBlock.splice(i, 1);\n        if (hasOwn.call(msg, 'error')) {\n          m.receiveResult(new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details));\n        } else {\n          // msg.result may be undefined if the method didn't return a value\n          m.receiveResult(undefined, msg.result);\n        }\n      }\n\n      /**\n       * @summary Handle \"nosub\" messages arriving from the server\n       * @param {Object} msg The nosub message\n       */\n      async _livedata_nosub(msg) {\n        const self = this._connection;\n\n        // First pass it through _livedata_data, which only uses it to help get\n        // towards quiescence.\n        await this._livedata_data(msg);\n\n        // Do the rest of our processing immediately, with no\n        // buffering-until-quiescence.\n\n        // we weren't subbed anyway, or we initiated the unsub.\n        if (!hasOwn.call(self._subscriptions, msg.id)) {\n          return;\n        }\n\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        const errorCallback = self._subscriptions[msg.id].errorCallback;\n        const stopCallback = self._subscriptions[msg.id].stopCallback;\n        self._subscriptions[msg.id].remove();\n        const meteorErrorFromMsg = msgArg => {\n          return msgArg && msgArg.error && new Meteor.Error(msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n        };\n\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        if (errorCallback && msg.error) {\n          errorCallback(meteorErrorFromMsg(msg));\n        }\n        if (stopCallback) {\n          stopCallback(meteorErrorFromMsg(msg));\n        }\n      }\n\n      /**\n       * @summary Handle errors from the server\n       * @param {Object} msg The error message\n       */\n      _livedata_error(msg) {\n        Meteor._debug('Received error from server: ', msg.reason);\n        if (msg.offendingMessage) Meteor._debug('For: ', msg.offendingMessage);\n      }\n\n      // Document change message processors will be defined in a separate class\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","MessageProcessors","DDPCommon","link","v","Meteor","DDP","EJSON","isEmpty","hasOwn","__reifyWaitForDeps__","constructor","connection","_connection","_livedata_connected","msg","self","_version","_heartbeatInterval","_heartbeat","Heartbeat","heartbeatInterval","heartbeatTimeout","_heartbeatTimeout","onTimeout","_lostConnection","ConnectionError","sendPing","_send","start","_lastSessionId","_resetStores","reconnectedToPreviousSession","session","_updatesForUnknownStores","Object","create","_documentsWrittenByStub","_serverDocuments","_afterUpdateCallbacks","_subsBeingRevived","entries","_subscriptions","forEach","_ref","id","sub","ready","_methodsBlockingQuiescence","invokers","_methodInvokers","keys","invoker","gotResult","push","dataVisible","arguments","sentMessage","methodId","_messagesBufferedUntilQuiescence","_waitingForQuiescence","store","values","_stores","beginUpdate","endUpdate","_runAfterUpdateCallbacks","_livedata_data","subs","subId","methods","bufferedMessages","bufferedMessage","_processOneDataMessage","_bufferedWrites","standardWrite","_bufferedWritesInterval","_flushBufferedWrites","_bufferedWritesFlushAt","Date","valueOf","_bufferedWritesMaxAge","_bufferedWritesFlushHandle","clearTimeout","setTimeout","_liveDataWritesPromise","_isPromise","finally","undefined","updates","messageType","_process_added","_process_changed","_process_removed","_process_ready","_process_updated","_debug","_livedata_result","_outstandingMethodBlocks","currentMethodBlock","i","m","find","method","idx","found","splice","call","receiveResult","Error","error","reason","details","result","_livedata_nosub","errorCallback","stopCallback","remove","meteorErrorFromMsg","msgArg","_livedata_error","offendingMessage","__reify_async_result__","_reifyError","async"],"sources":["packages/ddp-client/common/message_processors.js"],"sourcesContent":["import { DDPCommon } from 'meteor/ddp-common';\nimport { Meteor } from 'meteor/meteor';\nimport { DDP } from './namespace.js';\nimport { EJSON } from 'meteor/ejson';\nimport { isEmpty, hasOwn } from \"meteor/ddp-common/utils\";\n\nexport class MessageProcessors {\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process the connection message and set up the session\n   * @param {Object} msg The connection message\n   */\n  async _livedata_connected(msg) {\n    const self = this._connection;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout() {\n          self._lostConnection(\n            new DDP.ConnectionError('DDP heartbeat timed out')\n          );\n        },\n        sendPing() {\n          self._send({ msg: 'ping' });\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId) self._resetStores = true;\n\n    let reconnectedToPreviousSession;\n    if (typeof msg.session === 'string') {\n      reconnectedToPreviousSession = self._lastSessionId === msg.session;\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.\n      return;\n    }\n\n    // Server doesn't have our data anymore. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = Object.create(null);\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = Object.create(null);\n      self._serverDocuments = Object.create(null);\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready as needing to be revived.\n    self._subsBeingRevived = Object.create(null);\n    Object.entries(self._subscriptions).forEach(([id, sub]) => {\n      if (sub.ready) {\n        self._subsBeingRevived[id] = true;\n      }\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = Object.create(null);\n    if (self._resetStores) {\n      const invokers = self._methodInvokers;\n      Object.keys(invokers).forEach(id => {\n        const invoker = invokers[id];\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(\n            (...args) => invoker.dataVisible(...args)\n          );\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        for (const store of Object.values(self._stores)) {\n          await store.beginUpdate(0, true);\n          await store.endUpdate();\n        }\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  }\n\n  /**\n   * @summary Process various data messages from the server\n   * @param {Object} msg The data message\n   */\n  async _livedata_data(msg) {\n    const self = this._connection;\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === 'nosub') {\n        delete self._subsBeingRevived[msg.id];\n      }\n\n      if (msg.subs) {\n        msg.subs.forEach(subId => {\n          delete self._subsBeingRevived[subId];\n        });\n      }\n\n      if (msg.methods) {\n        msg.methods.forEach(methodId => {\n          delete self._methodsBlockingQuiescence[methodId];\n        });\n      }\n\n      if (self._waitingForQuiescence()) {\n        return;\n      }\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      const bufferedMessages = self._messagesBufferedUntilQuiescence;\n      for (const bufferedMessage of Object.values(bufferedMessages)) {\n        await this._processOneDataMessage(\n          bufferedMessage,\n          self._bufferedWrites\n        );\n      }\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      await this._processOneDataMessage(msg, self._bufferedWrites);\n    }\n\n    // Immediately flush writes when:\n    //  1. Buffering is disabled. Or;\n    //  2. any non-(added/changed/removed) message arrives.\n    const standardWrite =\n      msg.msg === \"added\" ||\n      msg.msg === \"changed\" ||\n      msg.msg === \"removed\";\n\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n      await self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushAt === null) {\n      self._bufferedWritesFlushAt =\n        new Date().valueOf() + self._bufferedWritesMaxAge;\n    } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n      await self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n    }\n    self._bufferedWritesFlushHandle = setTimeout(() => {\n      self._liveDataWritesPromise = self._flushBufferedWrites();\n      if (Meteor._isPromise(self._liveDataWritesPromise)) {\n        self._liveDataWritesPromise.finally(\n          () => (self._liveDataWritesPromise = undefined)\n        );\n      }\n    }, self._bufferedWritesInterval);\n  }\n\n  /**\n   * @summary Process individual data messages by type\n   * @private\n   */\n  async _processOneDataMessage(msg, updates) {\n    const messageType = msg.msg;\n\n    switch (messageType) {\n      case 'added':\n        await this._connection._process_added(msg, updates);\n        break;\n      case 'changed':\n        this._connection._process_changed(msg, updates);\n        break;\n      case 'removed':\n        this._connection._process_removed(msg, updates);\n        break;\n      case 'ready':\n        this._connection._process_ready(msg, updates);\n        break;\n      case 'updated':\n        this._connection._process_updated(msg, updates);\n        break;\n      case 'nosub':\n        // ignore this\n        break;\n      default:\n        Meteor._debug('discarding unknown livedata data message type', msg);\n    }\n  }\n\n  /**\n   * @summary Handle method results arriving from the server\n   * @param {Object} msg The method result message\n   */\n  async _livedata_result(msg) {\n    const self = this._connection;\n\n    // Lets make sure there are no buffered writes before returning result.\n    if (!isEmpty(self._bufferedWrites)) {\n      await self._flushBufferedWrites();\n    }\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug('Received method result but no methods outstanding');\n      return;\n    }\n    const currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    let i;\n    const m = currentMethodBlock.find((method, idx) => {\n      const found = method.methodId === msg.id;\n      if (found) i = idx;\n      return found;\n    });\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n\n    if (hasOwn.call(msg, 'error')) {\n      m.receiveResult(\n        new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details)\n      );\n    } else {\n      // msg.result may be undefined if the method didn't return a value\n      m.receiveResult(undefined, msg.result);\n    }\n  }\n\n  /**\n   * @summary Handle \"nosub\" messages arriving from the server\n   * @param {Object} msg The nosub message\n   */\n  async _livedata_nosub(msg) {\n    const self = this._connection;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    await this._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!hasOwn.call(self._subscriptions, msg.id)) {\n      return;\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    const errorCallback = self._subscriptions[msg.id].errorCallback;\n    const stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    const meteorErrorFromMsg = msgArg => {\n      return (\n        msgArg &&\n        msgArg.error &&\n        new Meteor.Error(\n          msgArg.error.error,\n          msgArg.error.reason,\n          msgArg.error.details\n        )\n      );\n    };\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  }\n\n  /**\n   * @summary Handle errors from the server\n   * @param {Object} msg The error message\n   */\n  _livedata_error(msg) {\n    Meteor._debug('Received error from server: ', msg.reason);\n    if (msg.offendingMessage) Meteor._debug('For: ', msg.offendingMessage);\n  }\n\n  // Document change message processors will be defined in a separate class\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"a3c318791f3be08182b745f5b866b3d972a60aea"}

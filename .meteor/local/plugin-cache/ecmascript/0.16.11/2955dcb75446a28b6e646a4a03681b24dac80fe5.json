{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/ddp-client/common/document_processors.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-client/common/document_processors.js"}},"code":"var _regeneratorRuntime;\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 0);\nmodule.export({\n  DocumentProcessors: function () {\n    return DocumentProcessors;\n  }\n});\nvar MongoID;\nmodule.link(\"meteor/mongo-id\", {\n  MongoID: function (v) {\n    MongoID = v;\n  }\n}, 0);\nvar DiffSequence;\nmodule.link(\"meteor/diff-sequence\", {\n  DiffSequence: function (v) {\n    DiffSequence = v;\n  }\n}, 1);\nvar hasOwn;\nmodule.link(\"meteor/ddp-common/utils\", {\n  hasOwn: function (v) {\n    hasOwn = v;\n  }\n}, 2);\nvar isEmpty;\nmodule.link(\"meteor/ddp-common/utils\", {\n  isEmpty: function (v) {\n    isEmpty = v;\n  }\n}, 3);\nvar DocumentProcessors = /*#__PURE__*/function () {\n  function DocumentProcessors(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process an 'added' message from the server\n   * @param {Object} msg The added message\n   * @param {Object} updates The updates accumulator\n   */\n  var _proto = DocumentProcessors.prototype;\n  _proto._process_added = function () {\n    function _process_added(msg, updates) {\n      var self, id, serverDoc, isExisting, currentDoc;\n      return _regeneratorRuntime.async(function (_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            self = this._connection;\n            id = MongoID.idParse(msg.id);\n            serverDoc = self._getServerDoc(msg.collection, id);\n            if (!serverDoc) {\n              _context.next = 4;\n              break;\n            }\n            // Some outstanding stub wrote here.\n            isExisting = serverDoc.document !== undefined;\n            serverDoc.document = msg.fields || Object.create(null);\n            serverDoc.document._id = id;\n            if (!self._resetStores) {\n              _context.next = 2;\n              break;\n            }\n            _context.next = 1;\n            return _regeneratorRuntime.awrap(self._stores[msg.collection].getDoc(msg.id));\n          case 1:\n            currentDoc = _context.sent;\n            if (currentDoc !== undefined) msg.fields = currentDoc;\n            self._pushUpdate(updates, msg.collection, msg);\n            _context.next = 3;\n            break;\n          case 2:\n            if (!isExisting) {\n              _context.next = 3;\n              break;\n            }\n            throw new Error('Server sent add for existing id: ' + msg.id);\n          case 3:\n            _context.next = 5;\n            break;\n          case 4:\n            self._pushUpdate(updates, msg.collection, msg);\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }, null, this, null, Promise);\n    }\n    return _process_added;\n  }()\n  /**\n   * @summary Process a 'changed' message from the server\n   * @param {Object} msg The changed message\n   * @param {Object} updates The updates accumulator\n   */\n  ;\n  _proto._process_changed = function () {\n    function _process_changed(msg, updates) {\n      var self = this._connection;\n      var serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n      if (serverDoc) {\n        if (serverDoc.document === undefined) {\n          throw new Error('Server sent changed for nonexisting id: ' + msg.id);\n        }\n        DiffSequence.applyChanges(serverDoc.document, msg.fields);\n      } else {\n        self._pushUpdate(updates, msg.collection, msg);\n      }\n    }\n    return _process_changed;\n  }()\n  /**\n   * @summary Process a 'removed' message from the server\n   * @param {Object} msg The removed message\n   * @param {Object} updates The updates accumulator\n   */\n  ;\n  _proto._process_removed = function () {\n    function _process_removed(msg, updates) {\n      var self = this._connection;\n      var serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n      if (serverDoc) {\n        // Some outstanding stub wrote here.\n        if (serverDoc.document === undefined) {\n          throw new Error('Server sent removed for nonexisting id:' + msg.id);\n        }\n        serverDoc.document = undefined;\n      } else {\n        self._pushUpdate(updates, msg.collection, {\n          msg: 'removed',\n          collection: msg.collection,\n          id: msg.id\n        });\n      }\n    }\n    return _process_removed;\n  }()\n  /**\n   * @summary Process a 'ready' message from the server\n   * @param {Object} msg The ready message\n   * @param {Object} updates The updates accumulator\n   */\n  ;\n  _proto._process_ready = function () {\n    function _process_ready(msg, updates) {\n      var self = this._connection;\n\n      // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n      // until all current server documents have been flushed to the local\n      // database. We can use a write fence to implement this.\n      msg.subs.forEach(function (subId) {\n        self._runWhenAllServerDocsAreFlushed(function () {\n          var subRecord = self._subscriptions[subId];\n          // Did we already unsubscribe?\n          if (!subRecord) return;\n          // Did we already receive a ready message? (Oops!)\n          if (subRecord.ready) return;\n          subRecord.ready = true;\n          subRecord.readyCallback && subRecord.readyCallback();\n          subRecord.readyDeps.changed();\n        });\n      });\n    }\n    return _process_ready;\n  }()\n  /**\n   * @summary Process an 'updated' message from the server\n   * @param {Object} msg The updated message\n   * @param {Object} updates The updates accumulator\n   */\n  ;\n  _proto._process_updated = function () {\n    function _process_updated(msg, updates) {\n      var self = this._connection;\n      // Process \"method done\" messages.\n      msg.methods.forEach(function (methodId) {\n        var docs = self._documentsWrittenByStub[methodId] || {};\n        Object.values(docs).forEach(function (written) {\n          var serverDoc = self._getServerDoc(written.collection, written.id);\n          if (!serverDoc) {\n            throw new Error('Lost serverDoc for ' + JSON.stringify(written));\n          }\n          if (!serverDoc.writtenByStubs[methodId]) {\n            throw new Error('Doc ' + JSON.stringify(written) + ' not written by method ' + methodId);\n          }\n          delete serverDoc.writtenByStubs[methodId];\n          if (isEmpty(serverDoc.writtenByStubs)) {\n            // All methods whose stubs wrote this method have completed! We can\n            // now copy the saved document to the database (reverting the stub's\n            // change if the server did not write to this object, or applying the\n            // server's writes if it did).\n\n            // This is a fake ddp 'replace' message.  It's just for talking\n            // between livedata connections and minimongo.  (We have to stringify\n            // the ID because it's supposed to look like a wire message.)\n            self._pushUpdate(updates, written.collection, {\n              msg: 'replace',\n              id: MongoID.idStringify(written.id),\n              replace: serverDoc.document\n            });\n            // Call all flush callbacks.\n            serverDoc.flushCallbacks.forEach(function (c) {\n              c();\n            });\n\n            // Delete this completed serverDocument. Don't bother to GC empty\n            // IdMaps inside self._serverDocuments, since there probably aren't\n            // many collections and they'll be written repeatedly.\n            self._serverDocuments[written.collection].remove(written.id);\n          }\n        });\n        delete self._documentsWrittenByStub[methodId];\n\n        // We want to call the data-written callback, but we can't do so until all\n        // currently buffered messages are flushed.\n        var callbackInvoker = self._methodInvokers[methodId];\n        if (!callbackInvoker) {\n          throw new Error('No callback invoker for method ' + methodId);\n        }\n        self._runWhenAllServerDocsAreFlushed(function () {\n          return callbackInvoker.dataVisible.apply(callbackInvoker, arguments);\n        });\n      });\n    }\n    return _process_updated;\n  }()\n  /**\n   * @summary Push an update to the buffer\n   * @private\n   * @param {Object} updates The updates accumulator\n   * @param {String} collection The collection name\n   * @param {Object} msg The update message\n   */\n  ;\n  _proto._pushUpdate = function () {\n    function _pushUpdate(updates, collection, msg) {\n      if (!hasOwn.call(updates, collection)) {\n        updates[collection] = [];\n      }\n      updates[collection].push(msg);\n    }\n    return _pushUpdate;\n  }()\n  /**\n   * @summary Get a server document by collection and id\n   * @private\n   * @param {String} collection The collection name\n   * @param {String} id The document id\n   * @returns {Object|null} The server document or null\n   */\n  ;\n  _proto._getServerDoc = function () {\n    function _getServerDoc(collection, id) {\n      var self = this._connection;\n      if (!hasOwn.call(self._serverDocuments, collection)) {\n        return null;\n      }\n      var serverDocsForCollection = self._serverDocuments[collection];\n      return serverDocsForCollection.get(id) || null;\n    }\n    return _getServerDoc;\n  }();\n  return DocumentProcessors;\n}();","map":{"version":3,"names":["_regeneratorRuntime","module","link","default","v","export","DocumentProcessors","MongoID","DiffSequence","hasOwn","isEmpty","connection","_connection","_proto","prototype","_process_added","msg","updates","self","id","serverDoc","isExisting","currentDoc","async","_context","prev","next","idParse","_getServerDoc","collection","document","undefined","fields","Object","create","_id","_resetStores","awrap","_stores","getDoc","sent","_pushUpdate","Error","stop","Promise","_process_changed","applyChanges","_process_removed","_process_ready","subs","forEach","subId","_runWhenAllServerDocsAreFlushed","subRecord","_subscriptions","ready","readyCallback","readyDeps","changed","_process_updated","methods","methodId","docs","_documentsWrittenByStub","values","written","JSON","stringify","writtenByStubs","idStringify","replace","flushCallbacks","c","_serverDocuments","remove","callbackInvoker","_methodInvokers","dataVisible","apply","arguments","call","push","serverDocsForCollection","get"],"sources":["packages/ddp-client/common/document_processors.js"],"sourcesContent":["import { MongoID } from 'meteor/mongo-id';\nimport { DiffSequence } from 'meteor/diff-sequence';\nimport { hasOwn } from \"meteor/ddp-common/utils\";\nimport { isEmpty } from \"meteor/ddp-common/utils\";\n\nexport class DocumentProcessors {\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process an 'added' message from the server\n   * @param {Object} msg The added message\n   * @param {Object} updates The updates accumulator\n   */\n  async _process_added(msg, updates) {\n    const self = this._connection;\n    const id = MongoID.idParse(msg.id);\n    const serverDoc = self._getServerDoc(msg.collection, id);\n\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      const isExisting = serverDoc.document !== undefined;\n\n      serverDoc.document = msg.fields || Object.create(null);\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        const currentDoc = await self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined) msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error('Server sent add for existing id: ' + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  }\n\n  /**\n   * @summary Process a 'changed' message from the server\n   * @param {Object} msg The changed message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_changed(msg, updates) {\n    const self = this._connection;\n    const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n\n    if (serverDoc) {\n      if (serverDoc.document === undefined) {\n        throw new Error('Server sent changed for nonexisting id: ' + msg.id);\n      }\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  }\n\n  /**\n   * @summary Process a 'removed' message from the server\n   * @param {Object} msg The removed message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_removed(msg, updates) {\n    const self = this._connection;\n    const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined) {\n        throw new Error('Server sent removed for nonexisting id:' + msg.id);\n      }\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  }\n\n  /**\n   * @summary Process a 'ready' message from the server\n   * @param {Object} msg The ready message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_ready(msg, updates) {\n    const self = this._connection;\n\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    msg.subs.forEach((subId) => {\n      self._runWhenAllServerDocsAreFlushed(() => {\n        const subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord) return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready) return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  }\n\n  /**\n   * @summary Process an 'updated' message from the server\n   * @param {Object} msg The updated message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_updated(msg, updates) {\n    const self = this._connection;\n    // Process \"method done\" messages.\n    msg.methods.forEach((methodId) => {\n      const docs = self._documentsWrittenByStub[methodId] || {};\n      Object.values(docs).forEach((written) => {\n        const serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc) {\n          throw new Error('Lost serverDoc for ' + JSON.stringify(written));\n        }\n        if (!serverDoc.writtenByStubs[methodId]) {\n          throw new Error(\n            'Doc ' +\n            JSON.stringify(written) +\n            ' not written by method ' +\n            methodId\n          );\n        }\n        delete serverDoc.writtenByStubs[methodId];\n        if (isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          serverDoc.flushCallbacks.forEach((c) => {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      const callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker) {\n        throw new Error('No callback invoker for method ' + methodId);\n      }\n\n      self._runWhenAllServerDocsAreFlushed(\n        (...args) => callbackInvoker.dataVisible(...args)\n      );\n    });\n  }\n\n  /**\n   * @summary Push an update to the buffer\n   * @private\n   * @param {Object} updates The updates accumulator\n   * @param {String} collection The collection name\n   * @param {Object} msg The update message\n   */\n  _pushUpdate(updates, collection, msg) {\n    if (!hasOwn.call(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  }\n\n  /**\n   * @summary Get a server document by collection and id\n   * @private\n   * @param {String} collection The collection name\n   * @param {String} id The document id\n   * @returns {Object|null} The server document or null\n   */\n  _getServerDoc(collection, id) {\n    const self = this._connection;\n    if (!hasOwn.call(self._serverDocuments, collection)) {\n      return null;\n    }\n    const serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  }\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"2955dcb75446a28b6e646a4a03681b24dac80fe5"}

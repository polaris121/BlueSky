{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\mongo_connection.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mongo/mongo_connection.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\mongo_connection.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"production","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\mongo\\mongo_connection.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/mongo_connection.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    module.export({\n      MongoConnection: () => MongoConnection\n    });\n    let Meteor;\n    module.link(\"meteor/meteor\", {\n      Meteor(v) {\n        Meteor = v;\n      }\n    }, 0);\n    let CLIENT_ONLY_METHODS, getAsyncMethodName;\n    module.link(\"meteor/minimongo/constants\", {\n      CLIENT_ONLY_METHODS(v) {\n        CLIENT_ONLY_METHODS = v;\n      },\n      getAsyncMethodName(v) {\n        getAsyncMethodName = v;\n      }\n    }, 1);\n    let path;\n    module.link(\"path\", {\n      default(v) {\n        path = v;\n      }\n    }, 2);\n    let AsynchronousCursor;\n    module.link(\"./asynchronous_cursor\", {\n      AsynchronousCursor(v) {\n        AsynchronousCursor = v;\n      }\n    }, 3);\n    let Cursor;\n    module.link(\"./cursor\", {\n      Cursor(v) {\n        Cursor = v;\n      }\n    }, 4);\n    let CursorDescription;\n    module.link(\"./cursor_description\", {\n      CursorDescription(v) {\n        CursorDescription = v;\n      }\n    }, 5);\n    let DocFetcher;\n    module.link(\"./doc_fetcher\", {\n      DocFetcher(v) {\n        DocFetcher = v;\n      }\n    }, 6);\n    let MongoDB, replaceMeteorAtomWithMongo, replaceTypes, transformResult;\n    module.link(\"./mongo_common\", {\n      MongoDB(v) {\n        MongoDB = v;\n      },\n      replaceMeteorAtomWithMongo(v) {\n        replaceMeteorAtomWithMongo = v;\n      },\n      replaceTypes(v) {\n        replaceTypes = v;\n      },\n      transformResult(v) {\n        transformResult = v;\n      }\n    }, 7);\n    let ObserveHandle;\n    module.link(\"./observe_handle\", {\n      ObserveHandle(v) {\n        ObserveHandle = v;\n      }\n    }, 8);\n    let ObserveMultiplexer;\n    module.link(\"./observe_multiplex\", {\n      ObserveMultiplexer(v) {\n        ObserveMultiplexer = v;\n      }\n    }, 9);\n    let OplogObserveDriver;\n    module.link(\"./oplog_observe_driver\", {\n      OplogObserveDriver(v) {\n        OplogObserveDriver = v;\n      }\n    }, 10);\n    let OPLOG_COLLECTION, OplogHandle;\n    module.link(\"./oplog_tailing\", {\n      OPLOG_COLLECTION(v) {\n        OPLOG_COLLECTION = v;\n      },\n      OplogHandle(v) {\n        OplogHandle = v;\n      }\n    }, 11);\n    let PollingObserveDriver;\n    module.link(\"./polling_observe_driver\", {\n      PollingObserveDriver(v) {\n        PollingObserveDriver = v;\n      }\n    }, 12);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    const FILE_ASSET_SUFFIX = 'Asset';\n    const ASSETS_FOLDER = 'assets';\n    const APP_FOLDER = 'app';\n    const oplogCollectionWarnings = [];\n    const MongoConnection = function (url, options) {\n      var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2;\n      var self = this;\n      options = options || {};\n      self._observeMultiplexers = {};\n      self._onFailoverHook = new Hook();\n      const userOptions = _objectSpread(_objectSpread({}, Mongo._connectionOptions || {}), ((_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : (_Meteor$settings$pack2 = _Meteor$settings$pack.mongo) === null || _Meteor$settings$pack2 === void 0 ? void 0 : _Meteor$settings$pack2.options) || {});\n      var mongoOptions = Object.assign({\n        ignoreUndefined: true\n      }, userOptions);\n\n      // Internally the oplog connections specify their own maxPoolSize\n      // which we don't want to overwrite with any user defined value\n      if ('maxPoolSize' in options) {\n        // If we just set this for \"server\", replSet will override it. If we just\n        // set it for replSet, it will be ignored if we're not using a replSet.\n        mongoOptions.maxPoolSize = options.maxPoolSize;\n      }\n      if ('minPoolSize' in options) {\n        mongoOptions.minPoolSize = options.minPoolSize;\n      }\n\n      // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n      // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n      Object.entries(mongoOptions || {}).filter(_ref => {\n        let [key] = _ref;\n        return key && key.endsWith(FILE_ASSET_SUFFIX);\n      }).forEach(_ref2 => {\n        let [key, value] = _ref2;\n        const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n        mongoOptions[optionName] = path.join(Assets.getServerDir(), ASSETS_FOLDER, APP_FOLDER, value);\n        delete mongoOptions[key];\n      });\n      self.db = null;\n      self._oplogHandle = null;\n      self._docFetcher = null;\n      mongoOptions.driverInfo = {\n        name: 'Meteor',\n        version: Meteor.release\n      };\n      self.client = new MongoDB.MongoClient(url, mongoOptions);\n      self.db = self.client.db();\n      self.client.on('serverDescriptionChanged', Meteor.bindEnvironment(event => {\n        // When the connection is no longer against the primary node, execute all\n        // failover hooks. This is important for the driver as it has to re-pool the\n        // query when it happens.\n        if (event.previousDescription.type !== 'RSPrimary' && event.newDescription.type === 'RSPrimary') {\n          self._onFailoverHook.each(callback => {\n            callback();\n            return true;\n          });\n        }\n      }));\n      if (options.oplogUrl && !Package['disable-oplog']) {\n        self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n        self._docFetcher = new DocFetcher(self);\n      }\n    };\n    MongoConnection.prototype._close = async function () {\n      var self = this;\n      if (!self.db) throw Error(\"close called before Connection created?\");\n\n      // XXX probably untested\n      var oplogHandle = self._oplogHandle;\n      self._oplogHandle = null;\n      if (oplogHandle) await oplogHandle.stop();\n\n      // Use Future.wrap so that errors get thrown. This happens to\n      // work even outside a fiber since the 'close' method is not\n      // actually asynchronous.\n      await self.client.close();\n    };\n    MongoConnection.prototype.close = function () {\n      return this._close();\n    };\n    MongoConnection.prototype._setOplogHandle = function (oplogHandle) {\n      this._oplogHandle = oplogHandle;\n      return this;\n    };\n\n    // Returns the Mongo Collection object; may yield.\n    MongoConnection.prototype.rawCollection = function (collectionName) {\n      var self = this;\n      if (!self.db) throw Error(\"rawCollection called before Connection created?\");\n      return self.db.collection(collectionName);\n    };\n    MongoConnection.prototype.createCappedCollectionAsync = async function (collectionName, byteSize, maxDocuments) {\n      var self = this;\n      if (!self.db) throw Error(\"createCappedCollectionAsync called before Connection created?\");\n      await self.db.createCollection(collectionName, {\n        capped: true,\n        size: byteSize,\n        max: maxDocuments\n      });\n    };\n\n    // This should be called synchronously with a write, to create a\n    // transaction on the current write fence, if any. After we can read\n    // the write, and after observers have been notified (or at least,\n    // after the observer notifiers have added themselves to the write\n    // fence), you should call 'committed()' on the object returned.\n    MongoConnection.prototype._maybeBeginWrite = function () {\n      const fence = DDPServer._getCurrentFence();\n      if (fence) {\n        return fence.beginWrite();\n      } else {\n        return {\n          committed: function () {}\n        };\n      }\n    };\n\n    // Internal interface: adds a callback which is called when the Mongo primary\n    // changes. Returns a stop handle.\n    MongoConnection.prototype._onFailover = function (callback) {\n      return this._onFailoverHook.register(callback);\n    };\n    MongoConnection.prototype.insertAsync = async function (collection_name, document) {\n      const self = this;\n      if (collection_name === \"___meteor_failure_test_collection\") {\n        const e = new Error(\"Failure test\");\n        e._expectedByTest = true;\n        throw e;\n      }\n      if (!(LocalCollection._isPlainObject(document) && !EJSON._isCustomType(document))) {\n        throw new Error(\"Only plain objects may be inserted into MongoDB\");\n      }\n      var write = self._maybeBeginWrite();\n      var refresh = async function () {\n        await Meteor.refresh({\n          collection: collection_name,\n          id: document._id\n        });\n      };\n      return self.rawCollection(collection_name).insertOne(replaceTypes(document, replaceMeteorAtomWithMongo), {\n        safe: true\n      }).then(async _ref3 => {\n        let {\n          insertedId\n        } = _ref3;\n        await refresh();\n        await write.committed();\n        return insertedId;\n      }).catch(async e => {\n        await write.committed();\n        throw e;\n      });\n    };\n\n    // Cause queries that may be affected by the selector to poll in this write\n    // fence.\n    MongoConnection.prototype._refresh = async function (collectionName, selector) {\n      var refreshKey = {\n        collection: collectionName\n      };\n      // If we know which documents we're removing, don't poll queries that are\n      // specific to other documents. (Note that multiple notifications here should\n      // not cause multiple polls, since all our listener is doing is enqueueing a\n      // poll.)\n      var specificIds = LocalCollection._idsMatchedBySelector(selector);\n      if (specificIds) {\n        for (const id of specificIds) {\n          await Meteor.refresh(Object.assign({\n            id: id\n          }, refreshKey));\n        }\n        ;\n      } else {\n        await Meteor.refresh(refreshKey);\n      }\n    };\n    MongoConnection.prototype.removeAsync = async function (collection_name, selector) {\n      var self = this;\n      if (collection_name === \"___meteor_failure_test_collection\") {\n        var e = new Error(\"Failure test\");\n        e._expectedByTest = true;\n        throw e;\n      }\n      var write = self._maybeBeginWrite();\n      var refresh = async function () {\n        await self._refresh(collection_name, selector);\n      };\n      return self.rawCollection(collection_name).deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n        safe: true\n      }).then(async _ref4 => {\n        let {\n          deletedCount\n        } = _ref4;\n        await refresh();\n        await write.committed();\n        return transformResult({\n          result: {\n            modifiedCount: deletedCount\n          }\n        }).numberAffected;\n      }).catch(async err => {\n        await write.committed();\n        throw err;\n      });\n    };\n    MongoConnection.prototype.dropCollectionAsync = async function (collectionName) {\n      var self = this;\n      var write = self._maybeBeginWrite();\n      var refresh = function () {\n        return Meteor.refresh({\n          collection: collectionName,\n          id: null,\n          dropCollection: true\n        });\n      };\n      return self.rawCollection(collectionName).drop().then(async result => {\n        await refresh();\n        await write.committed();\n        return result;\n      }).catch(async e => {\n        await write.committed();\n        throw e;\n      });\n    };\n\n    // For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n    // because it lets the test's fence wait for it to be complete.\n    MongoConnection.prototype.dropDatabaseAsync = async function () {\n      var self = this;\n      var write = self._maybeBeginWrite();\n      var refresh = async function () {\n        await Meteor.refresh({\n          dropDatabase: true\n        });\n      };\n      try {\n        await self.db._dropDatabase();\n        await refresh();\n        await write.committed();\n      } catch (e) {\n        await write.committed();\n        throw e;\n      }\n    };\n    MongoConnection.prototype.updateAsync = async function (collection_name, selector, mod, options) {\n      var self = this;\n      if (collection_name === \"___meteor_failure_test_collection\") {\n        var e = new Error(\"Failure test\");\n        e._expectedByTest = true;\n        throw e;\n      }\n\n      // explicit safety check. null and undefined can crash the mongo\n      // driver. Although the node driver and minimongo do 'support'\n      // non-object modifier in that they don't crash, they are not\n      // meaningful operations and do not do anything. Defensively throw an\n      // error here.\n      if (!mod || typeof mod !== 'object') {\n        const error = new Error(\"Invalid modifier. Modifier must be an object.\");\n        throw error;\n      }\n      if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n        const error = new Error(\"Only plain objects may be used as replacement\" + \" documents in MongoDB\");\n        throw error;\n      }\n      if (!options) options = {};\n      var write = self._maybeBeginWrite();\n      var refresh = async function () {\n        await self._refresh(collection_name, selector);\n      };\n      var collection = self.rawCollection(collection_name);\n      var mongoOpts = {\n        safe: true\n      };\n      // Add support for filtered positional operator\n      if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters;\n      // explictly enumerate options that minimongo supports\n      if (options.upsert) mongoOpts.upsert = true;\n      if (options.multi) mongoOpts.multi = true;\n      // Lets you get a more more full result from MongoDB. Use with caution:\n      // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n      // with simulated upsert.\n      if (options.fullResult) mongoOpts.fullResult = true;\n      var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n      var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n      var isModify = LocalCollection._isModificationMod(mongoMod);\n      if (options._forbidReplace && !isModify) {\n        var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n        throw err;\n      }\n\n      // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n      // selector and mod.  We assume it doesn't matter, as far as\n      // the behavior of modifiers is concerned, whether `_modify`\n      // is run on EJSON or on mongo-converted EJSON.\n\n      // Run this code up front so that it fails fast if someone uses\n      // a Mongo update operator we don't support.\n      let knownId;\n      if (options.upsert) {\n        try {\n          let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n          knownId = newDoc._id;\n        } catch (err) {\n          throw err;\n        }\n      }\n      if (options.upsert && !isModify && !knownId && options.insertedId && !(options.insertedId instanceof Mongo.ObjectID && options.generatedId)) {\n        // In case of an upsert with a replacement, where there is no _id defined\n        // in either the query or the replacement doc, mongo will generate an id itself.\n        // Therefore we need this special strategy if we want to control the id ourselves.\n\n        // We don't need to do this when:\n        // - This is not a replacement, so we can add an _id to $setOnInsert\n        // - The id is defined by query or mod we can just add it to the replacement doc\n        // - The user did not specify any id preference and the id is a Mongo ObjectId,\n        //     then we can just let Mongo generate the id\n        return await simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, options).then(async result => {\n          await refresh();\n          await write.committed();\n          if (result && !options._returnObject) {\n            return result.numberAffected;\n          } else {\n            return result;\n          }\n        });\n      } else {\n        if (options.upsert && !knownId && options.insertedId && isModify) {\n          if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n            mongoMod.$setOnInsert = {};\n          }\n          knownId = options.insertedId;\n          Object.assign(mongoMod.$setOnInsert, replaceTypes({\n            _id: options.insertedId\n          }, replaceMeteorAtomWithMongo));\n        }\n        const strings = Object.keys(mongoMod).filter(key => !key.startsWith(\"$\"));\n        let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n        updateMethod = updateMethod === 'updateMany' && !mongoOpts.multi ? 'updateOne' : updateMethod;\n        return collection[updateMethod].bind(collection)(mongoSelector, mongoMod, mongoOpts).then(async result => {\n          var meteorResult = transformResult({\n            result\n          });\n          if (meteorResult && options._returnObject) {\n            // If this was an upsertAsync() call, and we ended up\n            // inserting a new doc and we know its id, then\n            // return that id as well.\n            if (options.upsert && meteorResult.insertedId) {\n              if (knownId) {\n                meteorResult.insertedId = knownId;\n              } else if (meteorResult.insertedId instanceof MongoDB.ObjectId) {\n                meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n              }\n            }\n            await refresh();\n            await write.committed();\n            return meteorResult;\n          } else {\n            await refresh();\n            await write.committed();\n            return meteorResult.numberAffected;\n          }\n        }).catch(async err => {\n          await write.committed();\n          throw err;\n        });\n      }\n    };\n\n    // exposed for testing\n    MongoConnection._isCannotChangeIdError = function (err) {\n      // Mongo 3.2.* returns error as next Object:\n      // {name: String, code: Number, errmsg: String}\n      // Older Mongo returns:\n      // {name: String, code: Number, err: String}\n      var error = err.errmsg || err.err;\n\n      // We don't use the error code here\n      // because the error code we observed it producing (16837) appears to be\n      // a far more generic error code based on examining the source.\n      if (error.indexOf('The _id field cannot be changed') === 0 || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n        return true;\n      }\n      return false;\n    };\n\n    // XXX MongoConnection.upsertAsync() does not return the id of the inserted document\n    // unless you set it explicitly in the selector or modifier (as a replacement\n    // doc).\n    MongoConnection.prototype.upsertAsync = async function (collectionName, selector, mod, options) {\n      var self = this;\n      if (typeof options === \"function\" && !callback) {\n        callback = options;\n        options = {};\n      }\n      return self.updateAsync(collectionName, selector, mod, Object.assign({}, options, {\n        upsert: true,\n        _returnObject: true\n      }));\n    };\n    MongoConnection.prototype.find = function (collectionName, selector, options) {\n      var self = this;\n      if (arguments.length === 1) selector = {};\n      return new Cursor(self, new CursorDescription(collectionName, selector, options));\n    };\n    MongoConnection.prototype.findOneAsync = async function (collection_name, selector, options) {\n      var self = this;\n      if (arguments.length === 1) {\n        selector = {};\n      }\n      options = options || {};\n      options.limit = 1;\n      const results = await self.find(collection_name, selector, options).fetch();\n      return results[0];\n    };\n\n    // We'll actually design an index API later. For now, we just pass through to\n    // Mongo's, but make it synchronous.\n    MongoConnection.prototype.createIndexAsync = async function (collectionName, index, options) {\n      var self = this;\n\n      // We expect this function to be called at startup, not from within a method,\n      // so we don't interact with the write fence.\n      var collection = self.rawCollection(collectionName);\n      await collection.createIndex(index, options);\n    };\n\n    // just to be consistent with the other methods\n    MongoConnection.prototype.createIndex = MongoConnection.prototype.createIndexAsync;\n    MongoConnection.prototype.countDocuments = function (collectionName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n      const collection = this.rawCollection(collectionName);\n      return collection.countDocuments(...args);\n    };\n    MongoConnection.prototype.estimatedDocumentCount = function (collectionName) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n      const collection = this.rawCollection(collectionName);\n      return collection.estimatedDocumentCount(...args);\n    };\n    MongoConnection.prototype.ensureIndexAsync = MongoConnection.prototype.createIndexAsync;\n    MongoConnection.prototype.dropIndexAsync = async function (collectionName, index) {\n      var self = this;\n\n      // This function is only used by test code, not within a method, so we don't\n      // interact with the write fence.\n      var collection = self.rawCollection(collectionName);\n      var indexName = await collection.dropIndex(index);\n    };\n    CLIENT_ONLY_METHODS.forEach(function (m) {\n      MongoConnection.prototype[m] = function () {\n        throw new Error(\"\".concat(m, \" +  is not available on the server. Please use \").concat(getAsyncMethodName(m), \"() instead.\"));\n      };\n    });\n    var NUM_OPTIMISTIC_TRIES = 3;\n    var simulateUpsertWithInsertedId = async function (collection, selector, mod, options) {\n      // STRATEGY: First try doing an upsert with a generated ID.\n      // If this throws an error about changing the ID on an existing document\n      // then without affecting the database, we know we should probably try\n      // an update without the generated ID. If it affected 0 documents,\n      // then without affecting the database, we the document that first\n      // gave the error is probably removed and we need to try an insert again\n      // We go back to step one and repeat.\n      // Like all \"optimistic write\" schemes, we rely on the fact that it's\n      // unlikely our writes will continue to be interfered with under normal\n      // circumstances (though sufficiently heavy contention with writers\n      // disagreeing on the existence of an object will cause writes to fail\n      // in theory).\n\n      var insertedId = options.insertedId; // must exist\n      var mongoOptsForUpdate = {\n        safe: true,\n        multi: options.multi\n      };\n      var mongoOptsForInsert = {\n        safe: true,\n        upsert: true\n      };\n      var replacementWithId = Object.assign(replaceTypes({\n        _id: insertedId\n      }, replaceMeteorAtomWithMongo), mod);\n      var tries = NUM_OPTIMISTIC_TRIES;\n      var doUpdate = async function () {\n        tries--;\n        if (!tries) {\n          throw new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\");\n        } else {\n          let method = collection.updateMany;\n          if (!Object.keys(mod).some(key => key.startsWith(\"$\"))) {\n            method = collection.replaceOne.bind(collection);\n          }\n          return method(selector, mod, mongoOptsForUpdate).then(result => {\n            if (result && (result.modifiedCount || result.upsertedCount)) {\n              return {\n                numberAffected: result.modifiedCount || result.upsertedCount,\n                insertedId: result.upsertedId || undefined\n              };\n            } else {\n              return doConditionalInsert();\n            }\n          });\n        }\n      };\n      var doConditionalInsert = function () {\n        return collection.replaceOne(selector, replacementWithId, mongoOptsForInsert).then(result => ({\n          numberAffected: result.upsertedCount,\n          insertedId: result.upsertedId\n        })).catch(err => {\n          if (MongoConnection._isCannotChangeIdError(err)) {\n            return doUpdate();\n          } else {\n            throw err;\n          }\n        });\n      };\n      return doUpdate();\n    };\n\n    // observeChanges for tailable cursors on capped collections.\n    //\n    // Some differences from normal cursors:\n    //   - Will never produce anything other than 'added' or 'addedBefore'. If you\n    //     do update a document that has already been produced, this will not notice\n    //     it.\n    //   - If you disconnect and reconnect from Mongo, it will essentially restart\n    //     the query, which will lead to duplicate results. This is pretty bad,\n    //     but if you include a field called 'ts' which is inserted as\n    //     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n    //     current Mongo-style timestamp), we'll be able to find the place to\n    //     restart properly. (This field is specifically understood by Mongo with an\n    //     optimization which allows it to find the right place to start without\n    //     an index on ts. It's how the oplog works.)\n    //   - No callbacks are triggered synchronously with the call (there's no\n    //     differentiation between \"initial data\" and \"later changes\"; everything\n    //     that matches the query gets sent asynchronously).\n    //   - De-duplication is not implemented.\n    //   - Does not yet interact with the write fence. Probably, this should work by\n    //     ignoring removes (which don't work on capped collections) and updates\n    //     (which don't affect tailable cursors), and just keeping track of the ID\n    //     of the inserted object, and closing the write fence once you get to that\n    //     ID (or timestamp?).  This doesn't work well if the document doesn't match\n    //     the query, though.  On the other hand, the write fence can close\n    //     immediately if it does not match the query. So if we trust minimongo\n    //     enough to accurately evaluate the query against the write fence, we\n    //     should be able to do this...  Of course, minimongo doesn't even support\n    //     Mongo Timestamps yet.\n    MongoConnection.prototype._observeChangesTailable = function (cursorDescription, ordered, callbacks) {\n      var self = this;\n\n      // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n      // error if you didn't provide them.\n      if (ordered && !callbacks.addedBefore || !ordered && !callbacks.added) {\n        throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\") + \" tailable cursor without a \" + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n      }\n      return self.tail(cursorDescription, function (doc) {\n        var id = doc._id;\n        delete doc._id;\n        // The ts is an implementation detail. Hide it.\n        delete doc.ts;\n        if (ordered) {\n          callbacks.addedBefore(id, doc, null);\n        } else {\n          callbacks.added(id, doc);\n        }\n      });\n    };\n    MongoConnection.prototype._createAsynchronousCursor = function (cursorDescription) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var self = this;\n      const {\n        selfForIteration,\n        useTransform\n      } = options;\n      options = {\n        selfForIteration,\n        useTransform\n      };\n      var collection = self.rawCollection(cursorDescription.collectionName);\n      var cursorOptions = cursorDescription.options;\n      var mongoOptions = {\n        sort: cursorOptions.sort,\n        limit: cursorOptions.limit,\n        skip: cursorOptions.skip,\n        projection: cursorOptions.fields || cursorOptions.projection,\n        readPreference: cursorOptions.readPreference\n      };\n\n      // Do we want a tailable cursor (which only works on capped collections)?\n      if (cursorOptions.tailable) {\n        mongoOptions.numberOfRetries = -1;\n      }\n      var dbCursor = collection.find(replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), mongoOptions);\n\n      // Do we want a tailable cursor (which only works on capped collections)?\n      if (cursorOptions.tailable) {\n        // We want a tailable cursor...\n        dbCursor.addCursorFlag(\"tailable\", true);\n        // ... and for the server to wait a bit if any getMore has no data (rather\n        // than making us put the relevant sleeps in the client)...\n        dbCursor.addCursorFlag(\"awaitData\", true);\n\n        // And if this is on the oplog collection and the cursor specifies a 'ts',\n        // then set the undocumented oplog replay flag, which does a special scan to\n        // find the first document (instead of creating an index on ts). This is a\n        // very hard-coded Mongo flag which only works on the oplog collection and\n        // only works with the ts field.\n        if (cursorDescription.collectionName === OPLOG_COLLECTION && cursorDescription.selector.ts) {\n          dbCursor.addCursorFlag(\"oplogReplay\", true);\n        }\n      }\n      if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n        dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n      }\n      if (typeof cursorOptions.hint !== 'undefined') {\n        dbCursor = dbCursor.hint(cursorOptions.hint);\n      }\n      return new AsynchronousCursor(dbCursor, cursorDescription, options, collection);\n    };\n\n    // Tails the cursor described by cursorDescription, most likely on the\n    // oplog. Calls docCallback with each document found. Ignores errors and just\n    // restarts the tail on error.\n    //\n    // If timeoutMS is set, then if we don't get a new document every timeoutMS,\n    // kill and restart the cursor. This is primarily a workaround for #8598.\n    MongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n      var self = this;\n      if (!cursorDescription.options.tailable) throw new Error(\"Can only tail a tailable cursor\");\n      var cursor = self._createAsynchronousCursor(cursorDescription);\n      var stopped = false;\n      var lastTS;\n      Meteor.defer(async function loop() {\n        var doc = null;\n        while (true) {\n          if (stopped) return;\n          try {\n            doc = await cursor._nextObjectPromiseWithTimeout(timeoutMS);\n          } catch (err) {\n            // We should not ignore errors here unless we want to spend a lot of time debugging\n            console.error(err);\n            // There's no good way to figure out if this was actually an error from\n            // Mongo, or just client-side (including our own timeout error). Ah\n            // well. But either way, we need to retry the cursor (unless the failure\n            // was because the observe got stopped).\n            doc = null;\n          }\n          // Since we awaited a promise above, we need to check again to see if\n          // we've been stopped before calling the callback.\n          if (stopped) return;\n          if (doc) {\n            // If a tailable cursor contains a \"ts\" field, use it to recreate the\n            // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n            // the oplog, and there's a special flag that lets you do binary search\n            // on it instead of needing to use an index.)\n            lastTS = doc.ts;\n            docCallback(doc);\n          } else {\n            var newSelector = Object.assign({}, cursorDescription.selector);\n            if (lastTS) {\n              newSelector.ts = {\n                $gt: lastTS\n              };\n            }\n            cursor = self._createAsynchronousCursor(new CursorDescription(cursorDescription.collectionName, newSelector, cursorDescription.options));\n            // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n            // setTimeout, we peg the CPU at 100% and never notice the actual\n            // failover.\n            setTimeout(loop, 100);\n            break;\n          }\n        }\n      });\n      return {\n        stop: function () {\n          stopped = true;\n          cursor.close();\n        }\n      };\n    };\n    Object.assign(MongoConnection.prototype, {\n      _observeChanges: async function (cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n        var _self$_oplogHandle;\n        var self = this;\n        const collectionName = cursorDescription.collectionName;\n        if (cursorDescription.options.tailable) {\n          return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n        }\n\n        // You may not filter out _id when observing changes, because the id is a core\n        // part of the observeChanges API.\n        const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n        if (fieldsOptions && (fieldsOptions._id === 0 || fieldsOptions._id === false)) {\n          throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n        }\n        var observeKey = EJSON.stringify(Object.assign({\n          ordered: ordered\n        }, cursorDescription));\n        var multiplexer, observeDriver;\n        var firstHandle = false;\n\n        // Find a matching ObserveMultiplexer, or create a new one. This next block is\n        // guaranteed to not yield (and it doesn't call anything that can observe a\n        // new query), so no other calls to this function can interleave with it.\n        if (observeKey in self._observeMultiplexers) {\n          multiplexer = self._observeMultiplexers[observeKey];\n        } else {\n          firstHandle = true;\n          // Create a new ObserveMultiplexer.\n          multiplexer = new ObserveMultiplexer({\n            ordered: ordered,\n            onStop: function () {\n              delete self._observeMultiplexers[observeKey];\n              return observeDriver.stop();\n            }\n          });\n        }\n        var observeHandle = new ObserveHandle(multiplexer, callbacks, nonMutatingCallbacks);\n        const oplogOptions = (self === null || self === void 0 ? void 0 : (_self$_oplogHandle = self._oplogHandle) === null || _self$_oplogHandle === void 0 ? void 0 : _self$_oplogHandle._oplogOptions) || {};\n        const {\n          includeCollections,\n          excludeCollections\n        } = oplogOptions;\n        if (firstHandle) {\n          var matcher, sorter;\n          var canUseOplog = [function () {\n            // At a bare minimum, using the oplog requires us to have an oplog, to\n            // want unordered callbacks, and to not want a callback on the polls\n            // that won't happen.\n            return self._oplogHandle && !ordered && !callbacks._testOnlyPollCallback;\n          }, function () {\n            // We also need to check, if the collection of this Cursor is actually being \"watched\" by the Oplog handle\n            // if not, we have to fallback to long polling\n            if (excludeCollections !== null && excludeCollections !== void 0 && excludeCollections.length && excludeCollections.includes(collectionName)) {\n              if (!oplogCollectionWarnings.includes(collectionName)) {\n                console.warn(\"Meteor.settings.packages.mongo.oplogExcludeCollections includes the collection \".concat(collectionName, \" - your subscriptions will only use long polling!\"));\n                oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n              }\n              return false;\n            }\n            if (includeCollections !== null && includeCollections !== void 0 && includeCollections.length && !includeCollections.includes(collectionName)) {\n              if (!oplogCollectionWarnings.includes(collectionName)) {\n                console.warn(\"Meteor.settings.packages.mongo.oplogIncludeCollections does not include the collection \".concat(collectionName, \" - your subscriptions will only use long polling!\"));\n                oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n              }\n              return false;\n            }\n            return true;\n          }, function () {\n            // We need to be able to compile the selector. Fall back to polling for\n            // some newfangled $selector that minimongo doesn't support yet.\n            try {\n              matcher = new Minimongo.Matcher(cursorDescription.selector);\n              return true;\n            } catch (e) {\n              // XXX make all compilation errors MinimongoError or something\n              //     so that this doesn't ignore unrelated exceptions\n              return false;\n            }\n          }, function () {\n            // ... and the selector itself needs to support oplog.\n            return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n          }, function () {\n            // And we need to be able to compile the sort, if any.  eg, can't be\n            // {$natural: 1}.\n            if (!cursorDescription.options.sort) return true;\n            try {\n              sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n              return true;\n            } catch (e) {\n              // XXX make all compilation errors MinimongoError or something\n              //     so that this doesn't ignore unrelated exceptions\n              return false;\n            }\n          }].every(f => f()); // invoke each function and check if all return true\n\n          var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n          observeDriver = new driverClass({\n            cursorDescription: cursorDescription,\n            mongoHandle: self,\n            multiplexer: multiplexer,\n            ordered: ordered,\n            matcher: matcher,\n            // ignored by polling\n            sorter: sorter,\n            // ignored by polling\n            _testOnlyPollCallback: callbacks._testOnlyPollCallback\n          });\n          if (observeDriver._init) {\n            await observeDriver._init();\n          }\n\n          // This field is only set for use in tests.\n          multiplexer._observeDriver = observeDriver;\n        }\n        self._observeMultiplexers[observeKey] = multiplexer;\n        // Blocks until the initial adds have been sent.\n        await multiplexer.addHandleAndSendInitialAdds(observeHandle);\n        return observeHandle;\n      }\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","export","MongoConnection","Meteor","CLIENT_ONLY_METHODS","getAsyncMethodName","path","AsynchronousCursor","Cursor","CursorDescription","DocFetcher","MongoDB","replaceMeteorAtomWithMongo","replaceTypes","transformResult","ObserveHandle","ObserveMultiplexer","OplogObserveDriver","OPLOG_COLLECTION","OplogHandle","PollingObserveDriver","__reifyWaitForDeps__","FILE_ASSET_SUFFIX","ASSETS_FOLDER","APP_FOLDER","oplogCollectionWarnings","url","options","_Meteor$settings","_Meteor$settings$pack","_Meteor$settings$pack2","self","_observeMultiplexers","_onFailoverHook","Hook","userOptions","Mongo","_connectionOptions","settings","packages","mongo","mongoOptions","Object","assign","ignoreUndefined","maxPoolSize","minPoolSize","entries","filter","_ref","key","endsWith","forEach","_ref2","value","optionName","replace","join","Assets","getServerDir","db","_oplogHandle","_docFetcher","driverInfo","name","version","release","client","MongoClient","on","bindEnvironment","event","previousDescription","type","newDescription","each","callback","oplogUrl","Package","databaseName","prototype","_close","Error","oplogHandle","stop","close","_setOplogHandle","rawCollection","collectionName","collection","createCappedCollectionAsync","byteSize","maxDocuments","createCollection","capped","size","max","_maybeBeginWrite","fence","DDPServer","_getCurrentFence","beginWrite","committed","_onFailover","register","insertAsync","collection_name","document","e","_expectedByTest","LocalCollection","_isPlainObject","EJSON","_isCustomType","write","refresh","id","_id","insertOne","safe","then","_ref3","insertedId","catch","_refresh","selector","refreshKey","specificIds","_idsMatchedBySelector","removeAsync","deleteMany","_ref4","deletedCount","result","modifiedCount","numberAffected","err","dropCollectionAsync","dropCollection","drop","dropDatabaseAsync","dropDatabase","_dropDatabase","updateAsync","mod","error","mongoOpts","arrayFilters","undefined","upsert","multi","fullResult","mongoSelector","mongoMod","isModify","_isModificationMod","_forbidReplace","knownId","newDoc","_createUpsertDocument","ObjectID","generatedId","simulateUpsertWithInsertedId","_returnObject","hasOwnProperty","$setOnInsert","strings","keys","startsWith","updateMethod","length","bind","meteorResult","ObjectId","toHexString","_isCannotChangeIdError","errmsg","indexOf","upsertAsync","find","arguments","findOneAsync","limit","results","fetch","createIndexAsync","index","createIndex","countDocuments","_len","args","Array","_key","map","arg","estimatedDocumentCount","_len2","_key2","ensureIndexAsync","dropIndexAsync","indexName","dropIndex","m","concat","NUM_OPTIMISTIC_TRIES","mongoOptsForUpdate","mongoOptsForInsert","replacementWithId","tries","doUpdate","method","updateMany","some","replaceOne","upsertedCount","upsertedId","doConditionalInsert","_observeChangesTailable","cursorDescription","ordered","callbacks","addedBefore","added","tail","doc","ts","_createAsynchronousCursor","selfForIteration","useTransform","cursorOptions","sort","skip","projection","fields","readPreference","tailable","numberOfRetries","dbCursor","addCursorFlag","maxTimeMs","maxTimeMS","hint","docCallback","timeoutMS","cursor","stopped","lastTS","defer","loop","_nextObjectPromiseWithTimeout","console","newSelector","$gt","setTimeout","_observeChanges","nonMutatingCallbacks","_self$_oplogHandle","fieldsOptions","observeKey","stringify","multiplexer","observeDriver","firstHandle","onStop","observeHandle","oplogOptions","_oplogOptions","includeCollections","excludeCollections","matcher","sorter","canUseOplog","_testOnlyPollCallback","includes","warn","push","Minimongo","Matcher","cursorSupported","Sorter","every","f","driverClass","mongoHandle","_init","_observeDriver","addHandleAndSendInitialAdds","__reify_async_result__","_reifyError","async"],"sources":["packages/mongo/mongo_connection.js"],"sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { CLIENT_ONLY_METHODS, getAsyncMethodName } from 'meteor/minimongo/constants';\nimport path from 'path';\nimport { AsynchronousCursor } from './asynchronous_cursor';\nimport { Cursor } from './cursor';\nimport { CursorDescription } from './cursor_description';\nimport { DocFetcher } from './doc_fetcher';\nimport { MongoDB, replaceMeteorAtomWithMongo, replaceTypes, transformResult } from './mongo_common';\nimport { ObserveHandle } from './observe_handle';\nimport { ObserveMultiplexer } from './observe_multiplex';\nimport { OplogObserveDriver } from './oplog_observe_driver';\nimport { OPLOG_COLLECTION, OplogHandle } from './oplog_tailing';\nimport { PollingObserveDriver } from './polling_observe_driver';\n\nconst FILE_ASSET_SUFFIX = 'Asset';\nconst ASSETS_FOLDER = 'assets';\nconst APP_FOLDER = 'app';\n\nconst oplogCollectionWarnings = [];\n\nexport const MongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook;\n\n  const userOptions = {\n    ...(Mongo._connectionOptions || {}),\n    ...(Meteor.settings?.packages?.mongo?.options || {})\n  };\n\n  var mongoOptions = Object.assign({\n    ignoreUndefined: true,\n  }, userOptions);\n\n\n\n  // Internally the oplog connections specify their own maxPoolSize\n  // which we don't want to overwrite with any user defined value\n  if ('maxPoolSize' in options) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.maxPoolSize = options.maxPoolSize;\n  }\n  if ('minPoolSize' in options) {\n    mongoOptions.minPoolSize = options.minPoolSize;\n  }\n\n  // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n  // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n  Object.entries(mongoOptions || {})\n    .filter(([key]) => key && key.endsWith(FILE_ASSET_SUFFIX))\n    .forEach(([key, value]) => {\n      const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n      mongoOptions[optionName] = path.join(Assets.getServerDir(),\n        ASSETS_FOLDER, APP_FOLDER, value);\n      delete mongoOptions[key];\n    });\n\n  self.db = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n\n  mongoOptions.driverInfo = {\n    name: 'Meteor',\n    version: Meteor.release\n  }\n\n  self.client = new MongoDB.MongoClient(url, mongoOptions);\n  self.db = self.client.db();\n\n  self.client.on('serverDescriptionChanged', Meteor.bindEnvironment(event => {\n    // When the connection is no longer against the primary node, execute all\n    // failover hooks. This is important for the driver as it has to re-pool the\n    // query when it happens.\n    if (\n      event.previousDescription.type !== 'RSPrimary' &&\n      event.newDescription.type === 'RSPrimary'\n    ) {\n      self._onFailoverHook.each(callback => {\n        callback();\n        return true;\n      });\n    }\n  }));\n\n  if (options.oplogUrl && ! Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n\n};\n\nMongoConnection.prototype._close = async function() {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"close called before Connection created?\");\n\n  // XXX probably untested\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle)\n    await oplogHandle.stop();\n\n  // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n  await self.client.close();\n};\n\nMongoConnection.prototype.close = function () {\n  return this._close();\n};\n\nMongoConnection.prototype._setOplogHandle = function(oplogHandle) {\n  this._oplogHandle = oplogHandle;\n  return this;\n};\n\n// Returns the Mongo Collection object; may yield.\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"rawCollection called before Connection created?\");\n\n  return self.db.collection(collectionName);\n};\n\nMongoConnection.prototype.createCappedCollectionAsync = async function (\n  collectionName, byteSize, maxDocuments) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"createCappedCollectionAsync called before Connection created?\");\n\n\n  await self.db.createCollection(collectionName,\n    { capped: true, size: byteSize, max: maxDocuments });\n};\n\n// This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\nMongoConnection.prototype._maybeBeginWrite = function () {\n  const fence = DDPServer._getCurrentFence();\n  if (fence) {\n    return fence.beginWrite();\n  } else {\n    return {committed: function () {}};\n  }\n};\n\n// Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n};\n\nMongoConnection.prototype.insertAsync = async function (collection_name, document) {\n  const self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    const e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) &&\n    !EJSON._isCustomType(document))) {\n    throw new Error(\"Only plain objects may be inserted into MongoDB\");\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await Meteor.refresh({collection: collection_name, id: document._id });\n  };\n  return self.rawCollection(collection_name).insertOne(\n    replaceTypes(document, replaceMeteorAtomWithMongo),\n    {\n      safe: true,\n    }\n  ).then(async ({insertedId}) => {\n    await refresh();\n    await write.committed();\n    return insertedId;\n  }).catch(async e => {\n    await write.committed();\n    throw e;\n  });\n};\n\n\n// Cause queries that may be affected by the selector to poll in this write\n// fence.\nMongoConnection.prototype._refresh = async function (collectionName, selector) {\n  var refreshKey = {collection: collectionName};\n  // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    for (const id of specificIds) {\n      await Meteor.refresh(Object.assign({id: id}, refreshKey));\n    };\n  } else {\n    await Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype.removeAsync = async function (collection_name, selector) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await self._refresh(collection_name, selector);\n  };\n\n  return self.rawCollection(collection_name)\n    .deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n      safe: true,\n    })\n    .then(async ({ deletedCount }) => {\n      await refresh();\n      await write.committed();\n      return transformResult({ result : {modifiedCount : deletedCount} }).numberAffected;\n    }).catch(async (err) => {\n      await write.committed();\n      throw err;\n    });\n};\n\nMongoConnection.prototype.dropCollectionAsync = async function(collectionName) {\n  var self = this;\n\n\n  var write = self._maybeBeginWrite();\n  var refresh = function() {\n    return Meteor.refresh({\n      collection: collectionName,\n      id: null,\n      dropCollection: true,\n    });\n  };\n\n  return self\n    .rawCollection(collectionName)\n    .drop()\n    .then(async result => {\n      await refresh();\n      await write.committed();\n      return result;\n    })\n    .catch(async e => {\n      await write.committed();\n      throw e;\n    });\n};\n\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\nMongoConnection.prototype.dropDatabaseAsync = async function () {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await Meteor.refresh({ dropDatabase: true });\n  };\n\n  try {\n    await self.db._dropDatabase();\n    await refresh();\n    await write.committed();\n  } catch (e) {\n    await write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype.updateAsync = async function (collection_name, selector, mod, options) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n  if (!mod || typeof mod !== 'object') {\n    const error = new Error(\"Invalid modifier. Modifier must be an object.\");\n\n    throw error;\n  }\n\n  if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n    const error = new Error(\n      \"Only plain objects may be used as replacement\" +\n      \" documents in MongoDB\");\n\n    throw error;\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await self._refresh(collection_name, selector);\n  };\n\n  var collection = self.rawCollection(collection_name);\n  var mongoOpts = {safe: true};\n  // Add support for filtered positional operator\n  if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters;\n  // explictly enumerate options that minimongo supports\n  if (options.upsert) mongoOpts.upsert = true;\n  if (options.multi) mongoOpts.multi = true;\n  // Lets you get a more more full result from MongoDB. Use with caution:\n  // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n  // with simulated upsert.\n  if (options.fullResult) mongoOpts.fullResult = true;\n\n  var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n  var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n  var isModify = LocalCollection._isModificationMod(mongoMod);\n\n  if (options._forbidReplace && !isModify) {\n    var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n    throw err;\n  }\n\n  // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n  // selector and mod.  We assume it doesn't matter, as far as\n  // the behavior of modifiers is concerned, whether `_modify`\n  // is run on EJSON or on mongo-converted EJSON.\n\n  // Run this code up front so that it fails fast if someone uses\n  // a Mongo update operator we don't support.\n  let knownId;\n  if (options.upsert) {\n    try {\n      let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n      knownId = newDoc._id;\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (options.upsert &&\n    ! isModify &&\n    ! knownId &&\n    options.insertedId &&\n    ! (options.insertedId instanceof Mongo.ObjectID &&\n      options.generatedId)) {\n    // In case of an upsert with a replacement, where there is no _id defined\n    // in either the query or the replacement doc, mongo will generate an id itself.\n    // Therefore we need this special strategy if we want to control the id ourselves.\n\n    // We don't need to do this when:\n    // - This is not a replacement, so we can add an _id to $setOnInsert\n    // - The id is defined by query or mod we can just add it to the replacement doc\n    // - The user did not specify any id preference and the id is a Mongo ObjectId,\n    //     then we can just let Mongo generate the id\n    return await simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, options)\n      .then(async result => {\n        await refresh();\n        await write.committed();\n        if (result && ! options._returnObject) {\n          return result.numberAffected;\n        } else {\n          return result;\n        }\n      });\n  } else {\n    if (options.upsert && !knownId && options.insertedId && isModify) {\n      if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n        mongoMod.$setOnInsert = {};\n      }\n      knownId = options.insertedId;\n      Object.assign(mongoMod.$setOnInsert, replaceTypes({_id: options.insertedId}, replaceMeteorAtomWithMongo));\n    }\n\n    const strings = Object.keys(mongoMod).filter((key) => !key.startsWith(\"$\"));\n    let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n    updateMethod =\n      updateMethod === 'updateMany' && !mongoOpts.multi\n        ? 'updateOne'\n        : updateMethod;\n    return collection[updateMethod]\n      .bind(collection)(mongoSelector, mongoMod, mongoOpts)\n      .then(async result => {\n        var meteorResult = transformResult({result});\n        if (meteorResult && options._returnObject) {\n          // If this was an upsertAsync() call, and we ended up\n          // inserting a new doc and we know its id, then\n          // return that id as well.\n          if (options.upsert && meteorResult.insertedId) {\n            if (knownId) {\n              meteorResult.insertedId = knownId;\n            } else if (meteorResult.insertedId instanceof MongoDB.ObjectId) {\n              meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n            }\n          }\n          await refresh();\n          await write.committed();\n          return meteorResult;\n        } else {\n          await refresh();\n          await write.committed();\n          return meteorResult.numberAffected;\n        }\n      }).catch(async (err) => {\n        await write.committed();\n        throw err;\n      });\n  }\n};\n\n// exposed for testing\nMongoConnection._isCannotChangeIdError = function (err) {\n\n  // Mongo 3.2.* returns error as next Object:\n  // {name: String, code: Number, errmsg: String}\n  // Older Mongo returns:\n  // {name: String, code: Number, err: String}\n  var error = err.errmsg || err.err;\n\n  // We don't use the error code here\n  // because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n  if (error.indexOf('The _id field cannot be changed') === 0\n    || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\n// XXX MongoConnection.upsertAsync() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\nMongoConnection.prototype.upsertAsync = async function (collectionName, selector, mod, options) {\n  var self = this;\n\n\n\n  if (typeof options === \"function\" && ! callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.updateAsync(collectionName, selector, mod,\n    Object.assign({}, options, {\n      upsert: true,\n      _returnObject: true\n    }));\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n\n  if (arguments.length === 1)\n    selector = {};\n\n  return new Cursor(\n    self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOneAsync = async function (collection_name, selector, options) {\n  var self = this;\n  if (arguments.length === 1) {\n    selector = {};\n  }\n\n  options = options || {};\n  options.limit = 1;\n\n  const results = await self.find(collection_name, selector, options).fetch();\n\n  return results[0];\n};\n\n// We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\nMongoConnection.prototype.createIndexAsync = async function (collectionName, index,\n                                                             options) {\n  var self = this;\n\n  // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  await collection.createIndex(index, options);\n};\n\n// just to be consistent with the other methods\nMongoConnection.prototype.createIndex =\n  MongoConnection.prototype.createIndexAsync;\n\nMongoConnection.prototype.countDocuments = function (collectionName, ...args) {\n  args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n  const collection = this.rawCollection(collectionName);\n  return collection.countDocuments(...args);\n};\n\nMongoConnection.prototype.estimatedDocumentCount = function (collectionName, ...args) {\n  args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n  const collection = this.rawCollection(collectionName);\n  return collection.estimatedDocumentCount(...args);\n};\n\nMongoConnection.prototype.ensureIndexAsync = MongoConnection.prototype.createIndexAsync;\n\nMongoConnection.prototype.dropIndexAsync = async function (collectionName, index) {\n  var self = this;\n\n\n  // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var indexName =  await collection.dropIndex(index);\n};\n\n\nCLIENT_ONLY_METHODS.forEach(function (m) {\n  MongoConnection.prototype[m] = function () {\n    throw new Error(\n      `${m} +  is not available on the server. Please use ${getAsyncMethodName(\n        m\n      )}() instead.`\n    );\n  };\n});\n\n\nvar NUM_OPTIMISTIC_TRIES = 3;\n\n\n\nvar simulateUpsertWithInsertedId = async function (collection, selector, mod, options) {\n  // STRATEGY: First try doing an upsert with a generated ID.\n  // If this throws an error about changing the ID on an existing document\n  // then without affecting the database, we know we should probably try\n  // an update without the generated ID. If it affected 0 documents,\n  // then without affecting the database, we the document that first\n  // gave the error is probably removed and we need to try an insert again\n  // We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n\n  var insertedId = options.insertedId; // must exist\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n\n  var replacementWithId = Object.assign(\n    replaceTypes({_id: insertedId}, replaceMeteorAtomWithMongo),\n    mod);\n\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = async function () {\n    tries--;\n    if (! tries) {\n      throw new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\");\n    } else {\n      let method = collection.updateMany;\n      if(!Object.keys(mod).some(key => key.startsWith(\"$\"))){\n        method = collection.replaceOne.bind(collection);\n      }\n      return method(\n        selector,\n        mod,\n        mongoOptsForUpdate).then(result => {\n        if (result && (result.modifiedCount || result.upsertedCount)) {\n          return {\n            numberAffected: result.modifiedCount || result.upsertedCount,\n            insertedId: result.upsertedId || undefined,\n          };\n        } else {\n          return doConditionalInsert();\n        }\n      });\n    }\n  };\n\n  var doConditionalInsert = function() {\n    return collection.replaceOne(selector, replacementWithId, mongoOptsForInsert)\n      .then(result => ({\n        numberAffected: result.upsertedCount,\n        insertedId: result.upsertedId,\n      })).catch(err => {\n        if (MongoConnection._isCannotChangeIdError(err)) {\n          return doUpdate();\n        } else {\n          throw err;\n        }\n      });\n\n  };\n  return doUpdate();\n};\n\n// observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\nMongoConnection.prototype._observeChangesTailable = function (\n  cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n  if ((ordered && !callbacks.addedBefore) ||\n    (!ordered && !callbacks.added)) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\")\n      + \" tailable cursor without a \"\n      + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id;\n    // The ts is an implementation detail. Hide it.\n    delete doc.ts;\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n};\n\nMongoConnection.prototype._createAsynchronousCursor = function(\n  cursorDescription, options = {}) {\n  var self = this;\n  const { selfForIteration, useTransform } = options;\n  options = { selfForIteration, useTransform };\n\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip,\n    projection: cursorOptions.fields || cursorOptions.projection,\n    readPreference: cursorOptions.readPreference,\n  };\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    mongoOptions.numberOfRetries = -1;\n  }\n\n  var dbCursor = collection.find(\n    replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n    mongoOptions);\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    dbCursor.addCursorFlag(\"tailable\", true)\n    // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n    dbCursor.addCursorFlag(\"awaitData\", true)\n\n    // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n    if (cursorDescription.collectionName === OPLOG_COLLECTION &&\n      cursorDescription.selector.ts) {\n      dbCursor.addCursorFlag(\"oplogReplay\", true)\n    }\n  }\n\n  if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n    dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n  }\n  if (typeof cursorOptions.hint !== 'undefined') {\n    dbCursor = dbCursor.hint(cursorOptions.hint);\n  }\n\n  return new AsynchronousCursor(dbCursor, cursorDescription, options, collection);\n};\n\n// Tails the cursor described by cursorDescription, most likely on the\n// oplog. Calls docCallback with each document found. Ignores errors and just\n// restarts the tail on error.\n//\n// If timeoutMS is set, then if we don't get a new document every timeoutMS,\n// kill and restart the cursor. This is primarily a workaround for #8598.\nMongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n  var self = this;\n  if (!cursorDescription.options.tailable)\n    throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createAsynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS;\n\n  Meteor.defer(async function loop() {\n    var doc = null;\n    while (true) {\n      if (stopped)\n        return;\n      try {\n        doc = await cursor._nextObjectPromiseWithTimeout(timeoutMS);\n      } catch (err) {\n        // We should not ignore errors here unless we want to spend a lot of time debugging\n        console.error(err);\n        // There's no good way to figure out if this was actually an error from\n        // Mongo, or just client-side (including our own timeout error). Ah\n        // well. But either way, we need to retry the cursor (unless the failure\n        // was because the observe got stopped).\n        doc = null;\n      }\n      // Since we awaited a promise above, we need to check again to see if\n      // we've been stopped before calling the callback.\n      if (stopped)\n        return;\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = Object.assign({}, cursorDescription.selector);\n        if (lastTS) {\n          newSelector.ts = {$gt: lastTS};\n        }\n        cursor = self._createAsynchronousCursor(new CursorDescription(\n          cursorDescription.collectionName,\n          newSelector,\n          cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n        setTimeout(loop, 100);\n        break;\n      }\n    }\n  });\n\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nObject.assign(MongoConnection.prototype, {\n  _observeChanges: async function (\n    cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n    var self = this;\n    const collectionName = cursorDescription.collectionName;\n\n    if (cursorDescription.options.tailable) {\n      return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n    }\n\n    // You may not filter out _id when observing changes, because the id is a core\n    // part of the observeChanges API.\n    const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n    if (fieldsOptions &&\n      (fieldsOptions._id === 0 ||\n        fieldsOptions._id === false)) {\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    }\n\n    var observeKey = EJSON.stringify(\n      Object.assign({ordered: ordered}, cursorDescription));\n\n    var multiplexer, observeDriver;\n    var firstHandle = false;\n\n    // Find a matching ObserveMultiplexer, or create a new one. This next block is\n    // guaranteed to not yield (and it doesn't call anything that can observe a\n    // new query), so no other calls to this function can interleave with it.\n    if (observeKey in self._observeMultiplexers) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true;\n      // Create a new ObserveMultiplexer.\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          return observeDriver.stop();\n        }\n      });\n    }\n\n    var observeHandle = new ObserveHandle(multiplexer,\n      callbacks,\n      nonMutatingCallbacks,\n    );\n\n    const oplogOptions = self?._oplogHandle?._oplogOptions || {};\n    const { includeCollections, excludeCollections } = oplogOptions;\n    if (firstHandle) {\n      var matcher, sorter;\n      var canUseOplog = [\n        function () {\n          // At a bare minimum, using the oplog requires us to have an oplog, to\n          // want unordered callbacks, and to not want a callback on the polls\n          // that won't happen.\n          return self._oplogHandle && !ordered &&\n            !callbacks._testOnlyPollCallback;\n        },\n        function () {\n          // We also need to check, if the collection of this Cursor is actually being \"watched\" by the Oplog handle\n          // if not, we have to fallback to long polling\n          if (excludeCollections?.length && excludeCollections.includes(collectionName)) {\n            if (!oplogCollectionWarnings.includes(collectionName)) {\n              console.warn(`Meteor.settings.packages.mongo.oplogExcludeCollections includes the collection ${collectionName} - your subscriptions will only use long polling!`);\n              oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n            }\n            return false;\n          }\n          if (includeCollections?.length && !includeCollections.includes(collectionName)) {\n            if (!oplogCollectionWarnings.includes(collectionName)) {\n              console.warn(`Meteor.settings.packages.mongo.oplogIncludeCollections does not include the collection ${collectionName} - your subscriptions will only use long polling!`);\n              oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n            }\n            return false;\n          }\n          return true;\n        },\n        function () {\n          // We need to be able to compile the selector. Fall back to polling for\n          // some newfangled $selector that minimongo doesn't support yet.\n          try {\n            matcher = new Minimongo.Matcher(cursorDescription.selector);\n            return true;\n          } catch (e) {\n            // XXX make all compilation errors MinimongoError or something\n            //     so that this doesn't ignore unrelated exceptions\n            return false;\n          }\n        },\n        function () {\n          // ... and the selector itself needs to support oplog.\n          return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n        },\n        function () {\n          // And we need to be able to compile the sort, if any.  eg, can't be\n          // {$natural: 1}.\n          if (!cursorDescription.options.sort)\n            return true;\n          try {\n            sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n            return true;\n          } catch (e) {\n            // XXX make all compilation errors MinimongoError or something\n            //     so that this doesn't ignore unrelated exceptions\n            return false;\n          }\n        }\n      ].every(f => f());  // invoke each function and check if all return true\n\n      var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n      observeDriver = new driverClass({\n        cursorDescription: cursorDescription,\n        mongoHandle: self,\n        multiplexer: multiplexer,\n        ordered: ordered,\n        matcher: matcher,  // ignored by polling\n        sorter: sorter,  // ignored by polling\n        _testOnlyPollCallback: callbacks._testOnlyPollCallback\n      });\n\n      if (observeDriver._init) {\n        await observeDriver._init();\n      }\n\n      // This field is only set for use in tests.\n      multiplexer._observeDriver = observeDriver;\n    }\n    self._observeMultiplexers[observeKey] = multiplexer;\n    // Blocks until the initial adds have been sent.\n    await multiplexer.addHandleAndSendInitialAdds(observeHandle);\n\n    return observeHandle;\n  },\n\n});\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"9af666fb18593ec9c023e768d8e4ab7d8278612a"}

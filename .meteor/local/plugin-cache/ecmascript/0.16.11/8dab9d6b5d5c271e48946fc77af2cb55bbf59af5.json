{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/ddp-client/common/document_processors.js","filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","root":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\snntv\\OneDrive\\Documents\\AI Agent\\projects\\Meteor\\BlueSky\\packages\\ddp-client\\common\\document_processors.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-client/common/document_processors.js"}},"code":"module.export({\n  DocumentProcessors: () => DocumentProcessors\n});\nlet MongoID;\nmodule.link(\"meteor/mongo-id\", {\n  MongoID(v) {\n    MongoID = v;\n  }\n}, 0);\nlet DiffSequence;\nmodule.link(\"meteor/diff-sequence\", {\n  DiffSequence(v) {\n    DiffSequence = v;\n  }\n}, 1);\nlet hasOwn;\nmodule.link(\"meteor/ddp-common/utils\", {\n  hasOwn(v) {\n    hasOwn = v;\n  }\n}, 2);\nlet isEmpty;\nmodule.link(\"meteor/ddp-common/utils\", {\n  isEmpty(v) {\n    isEmpty = v;\n  }\n}, 3);\nclass DocumentProcessors {\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process an 'added' message from the server\n   * @param {Object} msg The added message\n   * @param {Object} updates The updates accumulator\n   */\n  async _process_added(msg, updates) {\n    const self = this._connection;\n    const id = MongoID.idParse(msg.id);\n    const serverDoc = self._getServerDoc(msg.collection, id);\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      const isExisting = serverDoc.document !== undefined;\n      serverDoc.document = msg.fields || Object.create(null);\n      serverDoc.document._id = id;\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        const currentDoc = await self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined) msg.fields = currentDoc;\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error('Server sent add for existing id: ' + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  }\n\n  /**\n   * @summary Process a 'changed' message from the server\n   * @param {Object} msg The changed message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_changed(msg, updates) {\n    const self = this._connection;\n    const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      if (serverDoc.document === undefined) {\n        throw new Error('Server sent changed for nonexisting id: ' + msg.id);\n      }\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  }\n\n  /**\n   * @summary Process a 'removed' message from the server\n   * @param {Object} msg The removed message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_removed(msg, updates) {\n    const self = this._connection;\n    const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined) {\n        throw new Error('Server sent removed for nonexisting id:' + msg.id);\n      }\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  }\n\n  /**\n   * @summary Process a 'ready' message from the server\n   * @param {Object} msg The ready message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_ready(msg, updates) {\n    const self = this._connection;\n\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    msg.subs.forEach(subId => {\n      self._runWhenAllServerDocsAreFlushed(() => {\n        const subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord) return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready) return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  }\n\n  /**\n   * @summary Process an 'updated' message from the server\n   * @param {Object} msg The updated message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_updated(msg, updates) {\n    const self = this._connection;\n    // Process \"method done\" messages.\n    msg.methods.forEach(methodId => {\n      const docs = self._documentsWrittenByStub[methodId] || {};\n      Object.values(docs).forEach(written => {\n        const serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc) {\n          throw new Error('Lost serverDoc for ' + JSON.stringify(written));\n        }\n        if (!serverDoc.writtenByStubs[methodId]) {\n          throw new Error('Doc ' + JSON.stringify(written) + ' not written by method ' + methodId);\n        }\n        delete serverDoc.writtenByStubs[methodId];\n        if (isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          serverDoc.flushCallbacks.forEach(c => {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      const callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker) {\n        throw new Error('No callback invoker for method ' + methodId);\n      }\n      self._runWhenAllServerDocsAreFlushed(function () {\n        return callbackInvoker.dataVisible(...arguments);\n      });\n    });\n  }\n\n  /**\n   * @summary Push an update to the buffer\n   * @private\n   * @param {Object} updates The updates accumulator\n   * @param {String} collection The collection name\n   * @param {Object} msg The update message\n   */\n  _pushUpdate(updates, collection, msg) {\n    if (!hasOwn.call(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  }\n\n  /**\n   * @summary Get a server document by collection and id\n   * @private\n   * @param {String} collection The collection name\n   * @param {String} id The document id\n   * @returns {Object|null} The server document or null\n   */\n  _getServerDoc(collection, id) {\n    const self = this._connection;\n    if (!hasOwn.call(self._serverDocuments, collection)) {\n      return null;\n    }\n    const serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  }\n}","map":{"version":3,"names":["module","export","DocumentProcessors","MongoID","link","v","DiffSequence","hasOwn","isEmpty","constructor","connection","_connection","_process_added","msg","updates","self","id","idParse","serverDoc","_getServerDoc","collection","isExisting","document","undefined","fields","Object","create","_id","_resetStores","currentDoc","_stores","getDoc","_pushUpdate","Error","_process_changed","applyChanges","_process_removed","_process_ready","subs","forEach","subId","_runWhenAllServerDocsAreFlushed","subRecord","_subscriptions","ready","readyCallback","readyDeps","changed","_process_updated","methods","methodId","docs","_documentsWrittenByStub","values","written","JSON","stringify","writtenByStubs","idStringify","replace","flushCallbacks","c","_serverDocuments","remove","callbackInvoker","_methodInvokers","dataVisible","arguments","call","push","serverDocsForCollection","get"],"sources":["packages/ddp-client/common/document_processors.js"],"sourcesContent":["import { MongoID } from 'meteor/mongo-id';\nimport { DiffSequence } from 'meteor/diff-sequence';\nimport { hasOwn } from \"meteor/ddp-common/utils\";\nimport { isEmpty } from \"meteor/ddp-common/utils\";\n\nexport class DocumentProcessors {\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * @summary Process an 'added' message from the server\n   * @param {Object} msg The added message\n   * @param {Object} updates The updates accumulator\n   */\n  async _process_added(msg, updates) {\n    const self = this._connection;\n    const id = MongoID.idParse(msg.id);\n    const serverDoc = self._getServerDoc(msg.collection, id);\n\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      const isExisting = serverDoc.document !== undefined;\n\n      serverDoc.document = msg.fields || Object.create(null);\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        const currentDoc = await self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined) msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error('Server sent add for existing id: ' + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  }\n\n  /**\n   * @summary Process a 'changed' message from the server\n   * @param {Object} msg The changed message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_changed(msg, updates) {\n    const self = this._connection;\n    const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n\n    if (serverDoc) {\n      if (serverDoc.document === undefined) {\n        throw new Error('Server sent changed for nonexisting id: ' + msg.id);\n      }\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  }\n\n  /**\n   * @summary Process a 'removed' message from the server\n   * @param {Object} msg The removed message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_removed(msg, updates) {\n    const self = this._connection;\n    const serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined) {\n        throw new Error('Server sent removed for nonexisting id:' + msg.id);\n      }\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  }\n\n  /**\n   * @summary Process a 'ready' message from the server\n   * @param {Object} msg The ready message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_ready(msg, updates) {\n    const self = this._connection;\n\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    msg.subs.forEach((subId) => {\n      self._runWhenAllServerDocsAreFlushed(() => {\n        const subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord) return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready) return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  }\n\n  /**\n   * @summary Process an 'updated' message from the server\n   * @param {Object} msg The updated message\n   * @param {Object} updates The updates accumulator\n   */\n  _process_updated(msg, updates) {\n    const self = this._connection;\n    // Process \"method done\" messages.\n    msg.methods.forEach((methodId) => {\n      const docs = self._documentsWrittenByStub[methodId] || {};\n      Object.values(docs).forEach((written) => {\n        const serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc) {\n          throw new Error('Lost serverDoc for ' + JSON.stringify(written));\n        }\n        if (!serverDoc.writtenByStubs[methodId]) {\n          throw new Error(\n            'Doc ' +\n            JSON.stringify(written) +\n            ' not written by method ' +\n            methodId\n          );\n        }\n        delete serverDoc.writtenByStubs[methodId];\n        if (isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          serverDoc.flushCallbacks.forEach((c) => {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      const callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker) {\n        throw new Error('No callback invoker for method ' + methodId);\n      }\n\n      self._runWhenAllServerDocsAreFlushed(\n        (...args) => callbackInvoker.dataVisible(...args)\n      );\n    });\n  }\n\n  /**\n   * @summary Push an update to the buffer\n   * @private\n   * @param {Object} updates The updates accumulator\n   * @param {String} collection The collection name\n   * @param {Object} msg The update message\n   */\n  _pushUpdate(updates, collection, msg) {\n    if (!hasOwn.call(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  }\n\n  /**\n   * @summary Get a server document by collection and id\n   * @private\n   * @param {String} collection The collection name\n   * @param {String} id The document id\n   * @returns {Object|null} The server document or null\n   */\n  _getServerDoc(collection, id) {\n    const self = this._connection;\n    if (!hasOwn.call(self._serverDocuments, collection)) {\n      return null;\n    }\n    const serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  }\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"8dab9d6b5d5c271e48946fc77af2cb55bbf59af5"}

[{"type":"js","data":"Package[\"core-runtime\"].queue(\"modern-browsers\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\nvar meteorInstall = Package.modules.meteorInstall;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modern-browsers\":{\"modern.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/modern-browsers/modern.js                                                                               //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nconst minimumVersions = Object.create(null);\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// This map defines aliasing behavior in a generic way which still permits\n// minimum versions to be specified for a specific browser family.\nconst browserAliases = {\n  chrome: [\n    // chromeMobile*, per https://github.com/meteor/meteor/pull/9793,\n    'chromeMobile',\n    'chromeMobileIOS',\n    'chromeMobileWebView',\n\n    // The major version number of Chromium and Headless Chrome track with the\n    // releases of Chrome Dev, Canary and Stable, so we should be okay to\n    // alias them to Chrome in a generic sense.\n    // https://www.chromium.org/developers/version-numbers\n    //\n    // Chromium is particularly important to list here since, unlike macOS\n    // builds, Linux builds list Chromium in the userAgent along with Chrome:\n    //   e.g. Chromium/70.0.3538.77 Chrome/70.0.3538.77\n    'chromium',\n    'headlesschrome',\n  ],\n\n  edge: [\n    // If a call to setMinimumBrowserVersions specifies Edge 12 as a minimum\n    // version, that means no version of Internet Explorer pre-Edge should\n    // be classified as modern. This edge:[\"ie\"] alias effectively enforces\n    // that logic, because there is no IE12. #9818 #9839\n    'ie',\n    // Detected by recent useragent-ng as a new browser family when it sees EdgiOS or EdgA in the user agent #13592\n    'edgeMobile',\n  ],\n\n  firefox: ['firefoxMobile'],\n\n  // The webapp package converts browser names to camel case, so\n  // mobile_safari and mobileSafari should be synonymous.\n  mobile_safari: ['mobileSafari', 'mobileSafariUI', 'mobileSafariUI/WKWebView'],\n\n  // Embedded WebViews on iPads will be reported as Apple Mail\n  safari: ['appleMail'],\n};\n\n/**\n * Expand the given minimum versions by reusing chrome versions for\n * chromeMobile (according to browserAliases above).\n * @param versions {object}\n * @return {any}\n */\nfunction applyAliases(versions) {\n  const lowerCaseVersions = Object.create(null);\n\n  for (const browser of Object.keys(versions)) {\n    lowerCaseVersions[browser.toLowerCase()] = versions[browser];\n  }\n\n  for (let original of Object.keys(browserAliases)) {\n    const aliases = browserAliases[original];\n    original = original.toLowerCase();\n\n    if (hasOwn.call(lowerCaseVersions, original)) {\n      for (let alias of aliases) {\n        alias = alias.toLowerCase();\n        if (!hasOwn.call(lowerCaseVersions, alias)) {\n          lowerCaseVersions[alias] = lowerCaseVersions[original];\n        }\n      }\n    }\n  }\n\n  return lowerCaseVersions;\n}\n\n// TODO Should it be possible for callers to setMinimumBrowserVersions to\n// forbid any version of a particular browser?\n\n/**\n * @name ModernBrowsers.isModern\n * @summary Given a { name, major, minor, patch } object like the one provided by\n * webapp via request.browser, return true if that browser qualifies as\n * \"modern\" according to all requested version constraints.\n * @locus server\n * @param [browser] {object} { name: string, major: number, minor?: number, patch?: number }\n * @return {boolean}\n */\nfunction isModern(browser) {\n  const lowerCaseName =\n    browser && typeof browser.name === 'string' && browser.name.toLowerCase();\n  if (!lowerCaseName) {\n    return false;\n  }\n  const entry = hasOwn.call(minimumVersions, lowerCaseName)\n    ? minimumVersions[lowerCaseName]\n    : undefined;\n    if (\n      !entry ||\n      // When all version numbers are 0, this typically comes from in-app WebView UAs (e.g., iOS WKWebView).\n      // We can let users decide whether to treat it as a modern browser\n      // via the packageSettings.unknownBrowsersAssumedModern option.\n      (browser.major === 0 && browser.minor === 0 && browser.patch === 0)\n    ) {\n    const packageSettings = Meteor.settings.packages\n      ? Meteor.settings.packages['modern-browsers']\n      : undefined;\n    // false if no package setting exists\n    return !!(packageSettings && packageSettings.unknownBrowsersAssumedModern);\n  }\n  return greaterThanOrEqualTo(\n    [~~browser.major, ~~browser.minor, ~~browser.patch],\n    entry.version,\n  );\n}\n\n/**\n * @name ModernBrowsers.setMinimumBrowserVersions\n * @summary Any package that depends on the modern-browsers package can call this\n * function to communicate its expectations for the minimum browser\n * versions that qualify as \"modern.\" The final decision between\n * web.browser.legacy and web.browser builds will be based on the maximum of all\n * requested minimum versions for each browser.\n * @locus server\n * @param versions {object} Name of the browser engine and minimum version for at which it is considered modern. For example: {\n *   chrome: 49,\n *   edge: 12,\n *   ie: 12,\n *   firefox: 45,\n *   mobileSafari: 10,\n *   opera: 38,\n *   safari: 10,\n *   electron: [1, 6],\n * }\n * @param source {function} Name of the capability that requires these minimums.\n */\nfunction setMinimumBrowserVersions(versions, source) {\n  const lowerCaseVersions = applyAliases(versions);\n\n  for (const lowerCaseName of Object.keys(lowerCaseVersions)) {\n    const version = lowerCaseVersions[lowerCaseName];\n\n    if (\n      hasOwn.call(minimumVersions, lowerCaseName) &&\n      !greaterThan(version, minimumVersions[lowerCaseName].version)\n    ) {\n      continue;\n    }\n\n    minimumVersions[lowerCaseName] = {\n      version: copy(version),\n      source: source || getCaller('setMinimumBrowserVersions'),\n    };\n  }\n}\n\nfunction getCaller(calleeName) {\n  const error = new Error();\n  Error.captureStackTrace(error);\n  const lines = error.stack.split('\\n');\n  let caller;\n  lines.some((line, i) => {\n    if (line.indexOf(calleeName) >= 0) {\n      caller = lines[i + 1].trim();\n      return true;\n    }\n  });\n  return caller;\n}\n\n/**\n * @name ModernBrowsers.getMinimumBrowserVersions\n * @summary Returns an object that lists supported browser engines and their minimum versions to be considered modern for Meteor.\n * @locus server\n * @return {object}\n */\nfunction getMinimumBrowserVersions() {\n  return minimumVersions;\n}\n\nObject.assign(exports, {\n  isModern,\n  setMinimumBrowserVersions,\n  getMinimumBrowserVersions,\n  /**\n   * @name ModernBrowsers.calculateHashOfMinimumVersions\n   * @summary Creates a hash of the object of minimum browser versions.\n   * @return {string}\n   */\n  calculateHashOfMinimumVersions() {\n    const { createHash } = require('crypto');\n    return createHash('sha1')\n      .update(JSON.stringify(minimumVersions))\n      .digest('hex');\n  },\n});\n\n// For making defensive copies of [major, minor, ...] version arrays, so\n// they don't change unexpectedly.\nfunction copy(version) {\n  if (typeof version === 'number') {\n    return version;\n  }\n\n  if (Array.isArray(version)) {\n    return version.map(copy);\n  }\n\n  return version;\n}\n\nfunction greaterThanOrEqualTo(a, b) {\n  return !greaterThan(b, a);\n}\n\nfunction greaterThan(a, b) {\n  const as = typeof a === 'number' ? [a] : a;\n  const bs = typeof b === 'number' ? [b] : b;\n  const maxLen = Math.max(as.length, bs.length);\n\n  for (let i = 0; i < maxLen; ++i) {\n    a = i < as.length ? as[i] : 0;\n    b = i < bs.length ? bs[i] : 0;\n\n    if (a > b) {\n      return true;\n    }\n\n    if (a < b) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction makeSource(feature) {\n  return module.id + ' (' + feature + ')';\n}\n\nsetMinimumBrowserVersions(\n  {\n    chrome: 49,\n    edge: 12,\n    firefox: 45,\n    firefoxIOS: 100,\n    mobileSafari: [9, 2],\n    opera: 36,\n    safari: 9,\n    // Electron 1.0.0+ matches Chromium 49, per\n    // https://github.com/Kilian/electron-to-chromium/blob/master/full-versions.js\n    electron: 1,\n  },\n  makeSource('classes'),\n);\n\nsetMinimumBrowserVersions(\n  {\n    chrome: 39,\n    edge: 13,\n    firefox: 26,\n    firefoxIOS: 100,\n    mobileSafari: 10,\n    opera: 26,\n    safari: 10,\n    // Disallow any version of PhantomJS.\n    phantomjs: Infinity,\n    electron: [0, 20],\n  },\n  makeSource('generator functions'),\n);\n\nsetMinimumBrowserVersions(\n  {\n    chrome: 41,\n    edge: 13,\n    firefox: 34,\n    firefoxIOS: 100,\n    mobileSafari: [9, 2],\n    opera: 29,\n    safari: [9, 1],\n    electron: [0, 24],\n  },\n  makeSource('template literals'),\n);\n\nsetMinimumBrowserVersions(\n  {\n    chrome: 38,\n    edge: 12,\n    firefox: 36,\n    firefoxIOS: 100,\n    mobileSafari: 9,\n    opera: 25,\n    safari: 9,\n    electron: [0, 20],\n  },\n  makeSource('symbols'),\n);\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\n\n/* Exports */\nreturn {\n  require: require,\n  eagerModulePaths: [\n    \"/node_modules/meteor/modern-browsers/modern.js\"\n  ],\n  mainModulePath: \"/node_modules/meteor/modern-browsers/modern.js\"\n}});\n","servePath":"/packages/modern-browsers.js"}]
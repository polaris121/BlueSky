[{"type":"js","data":"Package[\"core-runtime\"].queue(\"babel-compiler\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\n\n/* Package-scope variables */\nvar Babel, BabelCompiler, SwcCompiler;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                           //\n// packages/babel-compiler/babel.js                                                                          //\n//                                                                                                           //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                             //\nvar meteorBabel = null;\nfunction getMeteorBabel() {\n  return meteorBabel || (meteorBabel = Npm.require(\"@meteorjs/babel\"));\n}\n\n/**\n * Returns a new object containing default options appropriate for\n */\nfunction getDefaultOptions(extraFeatures) {\n  // See https://github.com/meteor/babel/blob/master/options.js for more\n  // information about what the default options are.\n  return getMeteorBabel().getDefaultOptions(extraFeatures);\n}\n\nBabel = {\n  getDefaultOptions: getDefaultOptions,\n\n  // Deprecated, now a no-op.\n  validateExtraFeatures: Function.prototype,\n\n  parse: function (source) {\n    return getMeteorBabel().parse(source);\n  },\n\n  compile: function (source, babelOptions, cacheOptions) {\n    return getMeteorBabel().compile(\n      source,\n      babelOptions || getDefaultOptions(),\n      cacheOptions\n    );\n  },\n\n  // This method is deprecated in favor of passing\n  // cacheDeps.cacheDirectory to Babel.compile (see above).\n  setCacheDir: function (cacheDir) {\n    getMeteorBabel().setCacheDir(cacheDir);\n  },\n\n  minify: function (source, options) {\n    var options = options || getMeteorBabel().getMinifierOptions();\n    return getMeteorBabel().minify(source, options);\n  },\n\n  getMinifierOptions: function (extraFeatures) {\n    return getMeteorBabel().getMinifierOptions(extraFeatures);\n  },\n\n  getMinimumModernBrowserVersions: function () {\n    return Npm.require(\"@meteorjs/babel/modern-versions.js\").get();\n  },\n\n  compileForShell(command, cacheOptions) {\n    const babelOptions = Babel.getDefaultOptions({\n      nodeMajorVersion: parseInt(process.versions.node, 10),\n      compileForShell: true\n    });\n    delete babelOptions.sourceMap;\n    delete babelOptions.sourceMaps;\n    babelOptions.ast = false;\n    return Babel.compile(command, babelOptions, cacheOptions).code;\n  }\n};\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                           //\n// packages/babel-compiler/babel-compiler.js                                                                 //\n//                                                                                                           //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                             //\nvar semver = Npm.require(\"semver\");\nvar JSON5 = Npm.require(\"json5\");\nvar SWC = Npm.require(\"@meteorjs/swc-core\");\nconst reifyCompile = Npm.require(\"@meteorjs/reify/lib/compiler\").compile;\nconst reifyAcornParse = Npm.require(\"@meteorjs/reify/lib/parsers/acorn\").parse;\nvar fs = Npm.require('fs');\nvar path = Npm.require('path');\nvar vm = Npm.require('vm');\nvar crypto = Npm.require('crypto');\n\n/**\n * A compiler that can be instantiated with features and used inside\n * Plugin.registerCompiler\n * @param {Object} extraFeatures The same object that getDefaultOptions takes\n */\nBabelCompiler = function BabelCompiler(extraFeatures, modifyConfig) {\n  this.extraFeatures = extraFeatures;\n  this.modifyConfig = modifyConfig;\n  this._babelrcCache = null;\n  this._babelrcWarnings = Object.create(null);\n  this.cacheDirectory = null;\n};\n\nvar BCp = BabelCompiler.prototype;\nvar excludedFileExtensionPattern = /\\.(es5|min)\\.js$/i;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// Check if verbose mode is enabled either in the provided config or in extraFeatures\nBCp.isVerbose = function(config) {\n  if (config?.modern?.transpiler?.verbose) {\n    return true;\n  }\n  if (config?.verbose) {\n    return true;\n  }\n  return !!this.extraFeatures?.verbose;\n};\n\n// There's no way to tell the current Meteor version, but we can infer\n// whether it's Meteor 1.4.4 or earlier by checking the Node version.\nvar isMeteorPre144 = semver.lt(process.version, \"4.8.1\");\n\nvar enableClientTLA = process.env.METEOR_ENABLE_CLIENT_TOP_LEVEL_AWAIT === 'true';\n\nfunction compileWithBabel(source, babelOptions, cacheOptions) {\n  return profile('Babel.compile', function () {\n    return Babel.compile(source, babelOptions, cacheOptions);\n  });\n}\n\nfunction compileWithSwc(source, swcOptions = {}, { features }) {\n  return profile('SWC.compile', function () {\n    // Perform SWC transformation.\n    const transformed = SWC.transformSync(source, swcOptions);\n\n    let content = transformed.code;\n\n    // Preserve Meteor-specific features: reify modules, nested imports, and top-level await support.\n    const result = reifyCompile(content, {\n      parse: reifyAcornParse,\n      generateLetDeclarations: false,\n      ast: false,\n      // Enforce reify options for proper compatibility.\n      avoidModernSyntax: true,\n      enforceStrictMode: false,\n      dynamicImport: true,\n      ...(features.topLevelAwait && { topLevelAwait: true }),\n      ...(features.compileForShell && { moduleAlias: 'module' }),\n      ...((features.modernBrowsers || features.nodeMajorVersion >= 8) && {\n        avoidModernSyntax: false,\n        generateLetDeclarations: true,\n      }),\n    });\n    content = result.code;\n\n    return {\n      code: content,\n      map: JSON.parse(transformed.map),\n      sourceType: 'module',\n    };\n  });\n}\nconst DEFAULT_MODERN = {\n  transpiler: true,\n};\n\nconst normalizeModern = (r = false) => Object.fromEntries(\n    Object.entries(DEFAULT_MODERN).map(([k, def]) => [\n      k,\n      r === true\n        ? def\n        : r === false || r?.[k] === false\n        ? false\n        : typeof r?.[k] === 'object'\n        ? { ...r[k] }\n        : def,\n    ]),\n);\n\nlet modernForced = JSON.parse(process.env.METEOR_MODERN || \"false\");\n\nlet lastModifiedMeteorConfig;\nlet lastModifiedMeteorConfigTime;\nBCp.initializeMeteorAppConfig = function () {\n  if (!lastModifiedMeteorConfig && !fs.existsSync(`${getMeteorAppDir()}/package.json`)) {\n    return;\n  }\n  const currentLastModifiedConfigTime = fs\n    .statSync(`${getMeteorAppDir()}/package.json`)\n    ?.mtime?.getTime();\n  if (currentLastModifiedConfigTime !== lastModifiedMeteorConfigTime) {\n    lastModifiedMeteorConfigTime = currentLastModifiedConfigTime;\n    lastModifiedMeteorConfig = getMeteorAppPackageJson()?.meteor;\n    lastModifiedMeteorConfig = lastModifiedMeteorConfig != null ? {\n      ...lastModifiedMeteorConfig,\n      modern: normalizeModern(modernForced || lastModifiedMeteorConfig?.modern),\n    } : {};\n\n    if (this.isVerbose(lastModifiedMeteorConfig)) {\n      logConfigBlock('Meteor Config', lastModifiedMeteorConfig);\n    }\n  }\n  return lastModifiedMeteorConfig;\n};\n\nlet lastModifiedSwcConfig;\nlet lastModifiedSwcConfigTime;\nBCp.initializeMeteorAppSwcrc = function () {\n  const hasSwcRc = fs.existsSync(`${getMeteorAppDir()}/.swcrc`);\n  const hasSwcJs = !hasSwcRc && fs.existsSync(`${getMeteorAppDir()}/swc.config.js`);\n  if (!lastModifiedSwcConfig && !hasSwcRc && !hasSwcJs) {\n    return;\n  }\n  const swcFile = hasSwcJs ? 'swc.config.js' : '.swcrc';\n  const filePath = `${getMeteorAppDir()}/${swcFile}`;\n  const fileStats = fs.statSync(filePath);\n  const fileModTime = fileStats?.mtime?.getTime();\n\n  let currentLastModifiedConfigTime;\n  if (hasSwcJs) {\n    // For dynamic JS files, first get the resolved configuration\n    const resolvedConfig = lastModifiedSwcConfig || getMeteorAppSwcrc(swcFile);\n    // Calculate a hash of the resolved configuration to detect changes\n    const contentHash = crypto\n      .createHash('sha256')\n      .update(JSON.stringify(resolvedConfig))\n      .digest('hex');\n    // Combine file modification time and content hash to create a unique identifier\n    currentLastModifiedConfigTime = `${fileModTime}-${contentHash}`;\n    // Store the resolved configuration\n    lastModifiedSwcConfig = resolvedConfig;\n  } else {\n    // For static JSON files, just use the file modification time\n    currentLastModifiedConfigTime = fileModTime;\n  }\n\n  if (currentLastModifiedConfigTime !== lastModifiedSwcConfigTime) {\n    lastModifiedSwcConfigTime = currentLastModifiedConfigTime;\n    lastModifiedSwcConfig = getMeteorAppSwcrc(swcFile);\n\n    if (this.isVerbose(lastModifiedMeteorConfig)) {\n      logConfigBlock('SWC Config', lastModifiedSwcConfig);\n    }\n  }\n  return lastModifiedSwcConfig;\n};\n\nlet lastModifiedSwcLegacyConfig;\nBCp.initializeMeteorAppLegacyConfig = function () {\n  const swcLegacyConfig = convertBabelTargetsForSwc(Babel.getMinimumModernBrowserVersions());\n  if (this.isVerbose(lastModifiedMeteorConfig) && !lastModifiedSwcLegacyConfig) {\n    logConfigBlock('SWC Legacy Config', swcLegacyConfig);\n  }\n  lastModifiedSwcLegacyConfig = swcLegacyConfig;\n  return lastModifiedSwcConfig;\n};\n\nBCp.processFilesForTarget = function (inputFiles) {\n  var compiler = this;\n\n  // Reset this cache for each batch processed.\n  this._babelrcCache = null;\n\n  this.initializeMeteorAppConfig();\n  this.initializeMeteorAppSwcrc();\n  this.initializeMeteorAppLegacyConfig();\n\n  inputFiles.forEach(function (inputFile) {\n    if (inputFile.supportsLazyCompilation) {\n      inputFile.addJavaScript({\n        path: inputFile.getPathInPackage(),\n        bare: !! inputFile.getFileOptions().bare\n      }, function () {\n        return compiler.processOneFileForTarget(inputFile);\n      });\n    } else {\n      var toBeAdded = compiler.processOneFileForTarget(inputFile);\n      if (toBeAdded) {\n        inputFile.addJavaScript(toBeAdded);\n      }\n    }\n  });\n};\n\n// Returns an object suitable for passing to inputFile.addJavaScript, or\n// null to indicate there was an error, and nothing should be added.\nBCp.processOneFileForTarget = function (inputFile, source) {\n  this._babelrcCache = this._babelrcCache || Object.create(null);\n  this._swcCache = this._swcCache || Object.create(null);\n  this._swcIncompatible = this._swcIncompatible || Object.create(null);\n\n  if (typeof source !== \"string\") {\n    // Other compiler plugins can call processOneFileForTarget with a\n    // source string that's different from inputFile.getContentsAsString()\n    // if they've already done some processing.\n    source = inputFile.getContentsAsString();\n  }\n\n  var packageName = inputFile.getPackageName();\n  var inputFilePath = inputFile.getPathInPackage();\n  var outputFilePath = inputFilePath;\n  var fileOptions = inputFile.getFileOptions();\n  var toBeAdded = {\n    sourcePath: inputFilePath,\n    path: outputFilePath,\n    data: source,\n    hash: inputFile.getSourceHash(),\n    sourceMap: null,\n    bare: !! fileOptions.bare\n  };\n\n  // If you need to exclude a specific file within a package from Babel\n  // compilation, pass the { transpile: false } options to api.addFiles\n  // when you add that file.\n  if (fileOptions.transpile !== false &&\n      // Bare files should not be transpiled by Babel, because they do not\n      // have access to CommonJS APIs like `require`, `module`, `exports`.\n      ! toBeAdded.bare &&\n      // If you need to exclude a specific file within an app from Babel\n      // compilation, give it the following file extension: .es5.js\n      ! excludedFileExtensionPattern.test(inputFilePath)) {\n\n    const features = Object.assign({}, this.extraFeatures);\n    const arch = inputFile.getArch();\n\n    if (arch.startsWith(\"os.\")) {\n      // Start with a much simpler set of Babel presets and plugins if\n      // we're compiling for Node 8.\n      features.nodeMajorVersion = parseInt(process.versions.node, 10);\n    } else if (arch === \"web.browser\") {\n      features.modernBrowsers = true;\n    }\n\n    features.topLevelAwait = inputFile.supportsTopLevelAwait &&\n       (arch.startsWith('os.') || enableClientTLA);\n\n    features.useNativeAsyncAwait = Meteor.isFibersDisabled;\n\n    if (! features.hasOwnProperty(\"jscript\")) {\n      // Perform some additional transformations to improve compatibility\n      // in older browsers (e.g. wrapping named function expressions, per\n      // http://kiro.me/blog/nfe_dilemma.html).\n      features.jscript = true;\n    }\n\n    if (shouldCompileModulesOnly(inputFilePath)) {\n      // Modules like @babel/runtime/helpers/esm/typeof.js need to be\n      // compiled to support ECMAScript modules syntax, but should *not*\n      // be compiled in any other way (for more explanation, see my longer\n      // comment in shouldCompileModulesOnly).\n      features.compileModulesOnly = true;\n    }\n\n    const cacheOptions = {\n      cacheDirectory: this.cacheDirectory,\n      cacheDeps: {\n        sourceHash: toBeAdded.hash,\n      },\n    };\n\n    const filename = packageName\n      ? `packages/${packageName}/${inputFilePath}`\n      : inputFilePath;\n\n    const setupBabelOptions = () => {\n      this.inferTypeScriptConfig(features, inputFile, cacheOptions.cacheDeps);\n\n      var babelOptions = Babel.getDefaultOptions(features);\n      babelOptions.caller = { name: \"meteor\", arch };\n\n      babelOptions.sourceMaps = true;\n      babelOptions.filename = babelOptions.sourceFileName = filename;\n\n      this.inferExtraBabelOptions(inputFile, babelOptions, cacheOptions.cacheDeps);\n\n      if (this.modifyConfig) {\n        this.modifyConfig(babelOptions, inputFile);\n      }\n\n      return babelOptions;\n    };\n\n    const setupSWCOptions = () => {\n      const isTypescriptSyntax = inputFilePath.endsWith('.ts') || inputFilePath.endsWith('.tsx');\n      const hasTSXSupport = inputFilePath.endsWith('.tsx');\n      const hasJSXSupport = inputFilePath.endsWith('.jsx');\n      const isLegacyWebArch = arch.includes('legacy');\n\n      var swcOptions = {\n        jsc: {\n          ...(!isLegacyWebArch && { target: 'es2015' }),\n          parser: {\n            syntax: isTypescriptSyntax ? 'typescript' : 'ecmascript',\n            jsx: hasJSXSupport,\n            tsx: hasTSXSupport,\n          },\n        },\n        module: { type: 'es6' },\n        minify: false,\n        sourceMaps: true,\n        filename,\n        sourceFileName: filename,\n        ...(isLegacyWebArch && {\n          env: { targets: lastModifiedSwcLegacyConfig || {} },\n        }),\n      };\n\n      // Merge with app-level SWC config\n      if (lastModifiedSwcConfig) {\n        swcOptions = deepMerge(swcOptions, lastModifiedSwcConfig, [\n          'env.targets',\n          'module.type',\n        ]);\n      }\n\n      this.inferExtraSWCOptions(inputFile, swcOptions, cacheOptions.cacheDeps);\n\n      if (!!this.extraFeatures?.swc && this.modifyConfig) {\n        this.modifyConfig(swcOptions, inputFile);\n      }\n\n      // Resolve custom baseUrl to an absolute path pointing to the project root\n      if (swcOptions.jsc && swcOptions.jsc.baseUrl) {\n        swcOptions.jsc.baseUrl = path.resolve(process.cwd(), swcOptions.jsc.baseUrl);\n      }\n\n      return swcOptions;\n    };\n\n    var babelOptions = { filename };\n    try {\n      var result = (() => {\n        const isNodeModulesCode = packageName == null && inputFilePath.includes(\"node_modules/\");\n        const isAppCode = packageName == null && !isNodeModulesCode;\n        const isPackageCode = packageName != null;\n        const isLegacyWebArch = arch.includes('legacy');\n\n        const config = lastModifiedMeteorConfig?.modern?.transpiler;\n        const hasModernTranspiler = config != null && config !== false;\n        const shouldSkipSwc =\n          !hasModernTranspiler ||\n          (isAppCode && config?.excludeApp === true) ||\n          (isNodeModulesCode && config?.excludeNodeModules === true) ||\n          (isPackageCode && config?.excludePackages === true) ||\n          (isLegacyWebArch && config?.excludeLegacy === true) ||\n          (isAppCode &&\n            Array.isArray(config?.excludeApp) &&\n            isExcludedConfig(inputFilePath, config?.excludeApp || [])) ||\n          (isNodeModulesCode &&\n            Array.isArray(config?.excludeNodeModules) &&\n            (isExcludedConfig(inputFilePath, config?.excludeNodeModules || []) ||\n              isExcludedConfig(\n                inputFilePath.replace('node_modules/', ''),\n                config?.excludeNodeModules || [],\n                true,\n              ))) ||\n          (isPackageCode &&\n            Array.isArray(config?.excludePackages) &&\n            (isExcludedConfig(packageName, config?.excludePackages || []) ||\n              isExcludedConfig(\n                `${packageName}/${inputFilePath}`,\n                config?.excludePackages || [],\n              )));\n\n        const cacheKey = [\n          toBeAdded.hash,\n          lastModifiedSwcConfigTime,\n          isLegacyWebArch ? 'legacy' : '',\n        ]\n          .filter(Boolean)\n          .join('-');\n        // Determine if SWC should be used based on package and file criteria.\n        const shouldUseSwc =\n          (!shouldSkipSwc || this.extraFeatures?.swc) &&\n          !this._swcIncompatible[cacheKey];\n        let compilation;\n        try {\n          let usedSwc = false;\n          if (shouldUseSwc) {\n            // Create a cache key based on the source hash and the compiler used\n            // Check cache\n            compilation = this.readFromSwcCache({ cacheKey });\n            // Return cached result if found.\n            if (compilation) {\n              if (this.isVerbose(config)) {\n                logTranspilation({\n                  usedSwc: true,\n                  inputFilePath,\n                  packageName,\n                  isNodeModulesCode,\n                  cacheHit: true,\n                  arch,\n                });\n              }\n              return compilation;\n            }\n\n            const swcOptions = setupSWCOptions();\n            compilation = compileWithSwc(\n              source,\n              swcOptions,\n              { features },\n            );\n            // Save result in cache\n            this.writeToSwcCache({ cacheKey, compilation });\n            usedSwc = true;\n          } else {\n            // Set up Babel options only when compiling with Babel\n            babelOptions = setupBabelOptions();\n\n            compilation = compileWithBabel(source, babelOptions, cacheOptions);\n            usedSwc = false;\n          }\n\n          if (this.isVerbose(config)) {\n            logTranspilation({\n              usedSwc,\n              inputFilePath,\n              packageName,\n              isNodeModulesCode,\n              cacheHit: false,\n              arch,\n            });\n          }\n        } catch (e) {\n          this._swcIncompatible[cacheKey] = true;\n          // If SWC fails, fall back to Babel\n\n          babelOptions = setupBabelOptions();\n          compilation = compileWithBabel(source, babelOptions, cacheOptions);\n          if (this.isVerbose(config)) {\n            logTranspilation({\n              usedSwc: false,\n              inputFilePath,\n              packageName,\n              isNodeModulesCode,\n              cacheHit: false,\n              arch,\n              errorMessage: e?.message,\n              ...(e?.message?.includes(\n                'cannot be used outside of module code',\n              ) && {\n                tip: 'Remove nested imports or replace them with require to support SWC and improve speed.',\n              }),\n            });\n          }\n        }\n\n        return compilation;\n      })();\n    } catch (e) {\n      if (e.loc) {\n        // Error is from @babel/parser.\n        inputFile.error({\n          message: e.message,\n          line: e.loc.line,\n          column: e.loc.column,\n        });\n      } else {\n        // Error is from a Babel transform, with line/column information\n        // embedded in e.message.\n        inputFile.error(e);\n      }\n\n      return null;\n    }\n\n    if (isMeteorPre144) {\n      // Versions of meteor-tool earlier than 1.4.4 do not understand that\n      // module.importSync is synonymous with the deprecated module.import\n      // and thus fail to register dependencies for importSync calls.\n      // This string replacement may seem a bit hacky, but it will tide us\n      // over until everyone has updated to Meteor 1.4.4.\n      // https://github.com/meteor/meteor/issues/8572\n      result.code = result.code.replace(\n        /\\bmodule\\.importSync\\b/g,\n        \"module.import\"\n      );\n    }\n\n    toBeAdded.data = result.code;\n    toBeAdded.hash = result.hash;\n\n    // The babelOptions.sourceMapTarget option was deprecated in Babel\n    // 7.0.0-beta.41: https://github.com/babel/babel/pull/7500\n    result.map.file = babelOptions.filename + \".map\";\n\n    toBeAdded.sourceMap = result.map;\n  }\n\n  return toBeAdded;\n};\n\nfunction shouldCompileModulesOnly(path) {\n  const parts = path.split(\"/\");\n  const nmi = parts.lastIndexOf(\"node_modules\");\n  if (nmi >= 0) {\n    const part1 = parts[nmi + 1];\n    // We trust that any code related to @babel/runtime has already been\n    // compiled adequately. The @babel/runtime/helpers/typeof module is a\n    // good example of why double-compilation is risky for these packages,\n    // since it uses native typeof syntax to implement its polyfill for\n    // Symbol-aware typeof, so compiling it again would cause the\n    // generated code to try to require itself. In general, compiling code\n    // more than once with Babel should be safe (just unnecessary), except\n    // for code that Babel itself relies upon at runtime. Finally, if this\n    // hard-coded list of package names proves to be incomplete, we can\n    // always add to it (or even replace it completely) by releasing a new\n    // version of the babel-compiler package.\n    if (part1 === \"@babel\" ||\n        part1 === \"core-js\" ||\n        part1 === \"regenerator-runtime\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nBCp.setDiskCacheDirectory = function (cacheDir) {\n  this.cacheDirectory = cacheDir;\n};\n\nfunction profile(name, func) {\n  if (typeof Profile !== 'undefined') {\n    return Profile.time(name, func);\n  } else {\n    return func();\n  }\n};\n\nBCp.inferTypeScriptConfig = function (features, inputFile, cacheDeps) {\n  if (features.typescript && inputFile.findControlFile) {\n    const tsconfigPath = inputFile.findControlFile(\"tsconfig.json\");\n    if (tsconfigPath) {\n      if (typeof features.typescript !== \"object\") {\n        features.typescript = Object.create(null);\n      }\n      Object.assign(features.typescript, { tsconfigPath });\n      return true;\n    }\n  }\n  return false;\n};\n\nBCp.inferExtraBabelOptions = function (inputFile, babelOptions, cacheDeps) {\n  if (! inputFile.require ||\n      ! inputFile.findControlFile ||\n      ! inputFile.readAndWatchFile) {\n    return false;\n  }\n\n  return (\n    // If a .babelrc exists, it takes precedence over package.json.\n    this._inferFromBabelRc(inputFile, babelOptions, cacheDeps) ||\n    this._inferFromPackageJson(inputFile, babelOptions, cacheDeps)\n  );\n};\n\nBCp.inferExtraSWCOptions = function (inputFile, swcOptions, cacheDeps) {\n  if (! inputFile.require ||\n      ! inputFile.findControlFile ||\n      ! inputFile.readAndWatchFile) {\n    return false;\n  }\n  return this._inferFromSwcRc(inputFile, swcOptions, cacheDeps);\n};\n\nBCp._inferFromBabelRc = function (inputFile, babelOptions, cacheDeps) {\n  var babelrcPath = inputFile.findControlFile(\".babelrc\");\n  if (babelrcPath) {\n    if (! hasOwn.call(this._babelrcCache, babelrcPath)) {\n      try {\n        this._babelrcCache[babelrcPath] = {\n          controlFilePath: babelrcPath,\n          controlFileData: JSON5.parse(\n            inputFile.readAndWatchFile(babelrcPath)),\n          deps: Object.create(null),\n        };\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          e.message = \".babelrc is not a valid JSON5 file: \" + e.message;\n        }\n        throw e;\n      }\n    }\n\n    const cacheEntry = this._babelrcCache[babelrcPath];\n\n    if (this._inferHelper(inputFile, cacheEntry)) {\n      merge(babelOptions, cacheEntry, \"presets\");\n      merge(babelOptions, cacheEntry, \"plugins\");\n      Object.assign(cacheDeps, cacheEntry.deps);\n      return true;\n    }\n  }\n};\n\nBCp._inferFromPackageJson = function (inputFile, babelOptions, cacheDeps) {\n  var pkgJsonPath = inputFile.findControlFile(\"package.json\");\n  if (pkgJsonPath) {\n    const cacheEntry = hasOwn.call(this._babelrcCache, pkgJsonPath)\n      ? this._babelrcCache[pkgJsonPath]\n      : this._babelrcCache[pkgJsonPath] = {\n          controlFilePath: pkgJsonPath,\n          controlFileData: JSON.parse(\n            inputFile.readAndWatchFile(pkgJsonPath)\n          ).babel || null,\n          deps: Object.create(null),\n        };\n\n    if (this._inferHelper(inputFile, cacheEntry)) {\n      merge(babelOptions, cacheEntry, \"presets\");\n      merge(babelOptions, cacheEntry, \"plugins\");\n      Object.assign(cacheDeps, cacheEntry.deps);\n      return true;\n    }\n  }\n};\n\nBCp._inferFromSwcRc = function (inputFile, swcOptions, cacheDeps) {\n  var swcrcPath = inputFile.findControlFile(\".swcrc\");\n  if (swcrcPath) {\n    if (! hasOwn.call(this._babelrcCache, swcrcPath)) {\n      try {\n        this._babelrcCache[swcrcPath] = {\n          controlFilePath: swcrcPath,\n          controlFileData: JSON.parse(\n            inputFile.readAndWatchFile(swcrcPath)),\n          deps: Object.create(null),\n        };\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          e.message = \".swcrc is not a valid JSON file: \" + e.message;\n        }\n        throw e;\n      }\n    }\n\n    const cacheEntry = this._babelrcCache[swcrcPath];\n\n    if (this._inferHelperForSwc(inputFile, cacheEntry)) {\n      deepMerge(swcOptions, cacheEntry.controlFileData);\n      Object.assign(cacheDeps, cacheEntry.deps);\n      return true;\n    }\n  }\n};\n\nBCp._inferHelperForSwc = function (inputFile, cacheEntry) {\n  if (! cacheEntry.controlFileData) {\n    return false;\n  }\n\n  if (hasOwn.call(cacheEntry, \"finalInferHelperForSwcResult\")) {\n    // We've already run _inferHelperForSwc and populated\n    // cacheEntry.controlFileData, so we can return early here.\n    return cacheEntry.finalInferHelperForSwcResult;\n  }\n\n  // First, ensure that the current file path is not excluded.\n  if (cacheEntry.controlFileData.exclude) {\n    const exclude = cacheEntry.controlFileData.exclude;\n    const path = inputFile.getPathInPackage();\n\n    if (exclude instanceof Array) {\n      for (let i = 0; i < exclude.length; ++i) {\n        if (path.match(exclude[i])) {\n          return cacheEntry.finalInferHelperForSwcResult = false;\n        }\n      }\n    } else if (path.match(exclude)) {\n      return cacheEntry.finalInferHelperForSwcResult = false;\n    }\n  }\n\n  return cacheEntry.finalInferHelperForSwcResult = true;\n};\n\nBCp._inferHelper = function (inputFile, cacheEntry) {\n  if (! cacheEntry.controlFileData) {\n    return false;\n  }\n\n  if (hasOwn.call(cacheEntry, \"finalInferHelperResult\")) {\n    // We've already run _inferHelper and populated\n    // cacheEntry.{presets,plugins}, so we can return early here.\n    return cacheEntry.finalInferHelperResult;\n  }\n\n  var compiler = this;\n\n  function walkBabelRC(obj, path) {\n    if (obj && typeof obj === \"object\") {\n      const copy = Object.create(null);\n\n      path = path || [];\n      const index = path.length;\n\n      if (obj.presets) {\n        path[index] = \"presets\";\n        copy.presets = walkHelper(obj.presets, path);\n      }\n\n      if (obj.plugins) {\n        path[index] = \"plugins\";\n        copy.plugins = walkHelper(obj.plugins, path);\n      }\n\n      path.pop();\n\n      return copy;\n    }\n\n    return obj;\n  }\n\n  function walkHelper(list, path) {\n    const copy = [];\n\n    list.forEach(function (pluginOrPreset) {\n      const res = resolveHelper(pluginOrPreset, path);\n      if (res) {\n        copy.push(res);\n      }\n    });\n\n    return copy;\n  }\n\n  function resolveHelper(value, path) {\n    if (value) {\n      if (typeof value === \"function\") {\n        // The value has already been resolved to a plugin function.\n        return value;\n      }\n\n      if (Array.isArray(value)) {\n        // The value is a [plugin, options] pair.\n        const res = resolveHelper(value[0], path);\n        if (res) {\n          const copy = value.slice(0);\n          copy[0] = res;\n          return copy;\n        }\n\n      } else if (typeof value === \"string\") {\n        // The value is a string that we need to require.\n        const result = requireWithPath(value, path);\n        if (result && result.module) {\n          cacheEntry.deps[result.name] = result.version;\n          return walkBabelRC(result.module, path);\n        }\n\n      } else if (typeof value === \"object\") {\n        // The value is a { presets?, plugins? } preset object.\n        return walkBabelRC(value, path);\n      }\n    }\n\n    return null;\n  }\n\n  function requireWithPath(id, path) {\n    const prefixes = [];\n    const lastInPath = path[path.length - 1];\n    if (lastInPath === \"presets\") {\n      prefixes.push(\"@babel/preset-\", \"babel-preset-\");\n    } else if (lastInPath === \"plugins\") {\n      prefixes.push(\"@babel/plugin-\", \"babel-plugin-\");\n    }\n\n    // Try without a prefix if the prefixes fail.\n    prefixes.push(\"\");\n\n    try {\n      return requireWithPrefixes(\n        inputFile, id, prefixes,\n        cacheEntry.controlFilePath\n      );\n    } catch (e) {\n      if (e.code !== \"MODULE_NOT_FOUND\") {\n        throw e;\n      }\n\n      if (! hasOwn.call(compiler._babelrcWarnings, id)) {\n        compiler._babelrcWarnings[id] = cacheEntry.controlFilePath;\n\n        console.error(\n          \"Warning: unable to resolve \" +\n            JSON.stringify(id) +\n            \" in \" + path.join(\".\") +\n            \" of \" + cacheEntry.controlFilePath + \", due to:\"\n        );\n\n        console.error(e.stack || e);\n      }\n\n      return null;\n    }\n  }\n\n  const { controlFileData } = cacheEntry;\n  const clean = walkBabelRC(controlFileData);\n  merge(cacheEntry, clean, \"presets\");\n  merge(cacheEntry, clean, \"plugins\");\n\n  if (controlFileData &&\n      controlFileData.env) {\n    const envKey =\n      process.env.BABEL_ENV ||\n      process.env.NODE_ENV ||\n      \"development\";\n\n    const clean = walkBabelRC(controlFileData.env[envKey]);\n\n    if (clean) {\n      merge(cacheEntry, clean, \"presets\");\n      merge(cacheEntry, clean, \"plugins\");\n    }\n  }\n\n  return cacheEntry.finalInferHelperResult =\n    !! (cacheEntry.presets ||\n        cacheEntry.plugins);\n};\n\nfunction merge(babelOptions, babelrc, name) {\n  if (babelrc[name]) {\n    var list = babelOptions[name] || [];\n    babelOptions[name] = list;\n    list.push.apply(list, babelrc[name]);\n  }\n}\n\nconst forbiddenPresetNames = new Set([\n  // Since Meteor always includes babel-preset-meteor automatically, it's\n  // likely a mistake for that preset to appear in a custom .babelrc\n  // file. Previously we recommended that developers simply remove the\n  // preset (e.g. #9631), but we can easily just ignore it by returning\n  // null here, which seems like a better solution since it allows the\n  // same .babelrc file to be used for other purposes, such as running\n  // tests with a testing tool that needs to compile application code the\n  // same way Meteor does.\n  \"babel-preset-meteor\",\n  // Similar reasoning applies to these commonly misused Babel presets:\n  \"@babel/preset-env\",\n  \"@babel/preset-react\",\n]);\n\nfunction requireWithPrefixes(inputFile, id, prefixes, controlFilePath) {\n  var isTopLevel = \"./\".indexOf(id.charAt(0)) < 0;\n  var presetOrPlugin;\n  var presetOrPluginMeta;\n\n  if (isTopLevel) {\n    var presetOrPluginId;\n\n    var found = prefixes.some(function (prefix) {\n      try {\n        // Call inputFile.resolve here rather than inputFile.require so\n        // that the import doesn't fail due to missing transitive\n        // dependencies imported by the preset or plugin.\n        if (inputFile.resolve(prefix + id, controlFilePath)) {\n          presetOrPluginId = prefix + id;\n        }\n\n        presetOrPluginMeta = inputFile.require(\n          packageNameFromTopLevelModuleId(prefix + id) + \"/package.json\",\n          controlFilePath\n        );\n\n        return true;\n\n      } catch (e) {\n        if (e.code !== \"MODULE_NOT_FOUND\") {\n          throw e;\n        }\n\n        return false;\n      }\n    });\n\n    if (found) {\n      if (forbiddenPresetNames.has(presetOrPluginMeta.name)) {\n        return null;\n      }\n\n      presetOrPlugin = inputFile.require(\n        presetOrPluginId,\n        controlFilePath\n      );\n    }\n\n  } else {\n    // If the identifier is not top-level, but relative or absolute,\n    // then it will be required as-is, so that you can implement your\n    // own Babel plugins locally, rather than always using plugins\n    // installed from npm.\n    presetOrPlugin = inputFile.require(id, controlFilePath);\n\n    // Note that inputFile.readAndWatchFileWithHash converts module\n    // identifers to OS-specific paths if necessary.\n    var absId = inputFile.resolve(id, controlFilePath);\n    var info = inputFile.readAndWatchFileWithHash(absId);\n\n    presetOrPluginMeta = {\n      name: absId,\n      version: info.hash\n    };\n  }\n\n  if (presetOrPlugin &&\n      presetOrPluginMeta) {\n    return {\n      name: presetOrPluginMeta.name,\n      version: presetOrPluginMeta.version,\n      module: presetOrPlugin.__esModule\n        ? presetOrPlugin.default\n        : presetOrPlugin\n    };\n  }\n\n  return null;\n}\n\n// react-hot-loader/babel => react-hot-loader\n// @babel/preset-env/lib/index.js => @babel/preset-env\nfunction packageNameFromTopLevelModuleId(id) {\n  const parts = id.split(\"/\", 2);\n  if (parts[0].charAt(0) === \"@\") {\n    return parts.join(\"/\");\n  }\n  return parts[0];\n}\n\nconst SwcCacheContext = '.swc-cache';\n\nBCp.readFromSwcCache = function({ cacheKey }) {\n  // Check in-memory cache.\n  let compilation = this._swcCache[cacheKey];\n  // If not found, try file system cache if enabled.\n  if (!compilation && this.cacheDirectory) {\n    const cacheFilePath = path.join(this.cacheDirectory, SwcCacheContext, `${cacheKey}.json`);\n    if (fs.existsSync(cacheFilePath)) {\n      try {\n        compilation = JSON.parse(fs.readFileSync(cacheFilePath, 'utf8'));\n        // Save back to in-memory cache.\n        this._swcCache[cacheKey] = compilation;\n      } catch (err) {\n        // Ignore any errors reading/parsing the cache.\n      }\n    }\n  }\n  return compilation;\n};\n\nBCp.writeToSwcCache = function({ cacheKey, compilation }) {\n  // Save to in-memory cache.\n  this._swcCache[cacheKey] = compilation;\n  // If file system caching is enabled, write asynchronously.\n  if (this.cacheDirectory) {\n    const cacheFilePath = path.join(this.cacheDirectory, SwcCacheContext, `${cacheKey}.json`);\n    try {\n      const writeFileCache = async () => {\n        await fs.promises.mkdir(path.dirname(cacheFilePath), { recursive: true });\n        await fs.promises.writeFile(cacheFilePath, JSON.stringify(compilation), 'utf8');\n      };\n      // Invoke without blocking the main flow.\n      writeFileCache();\n    } catch (err) {\n      // If writing fails, ignore the error.\n    }\n  }\n};\n\nfunction getMeteorAppDir() {\n  return process.cwd();\n}\n\nfunction getMeteorAppPackageJson() {\n  return JSON.parse(\n    fs.readFileSync(`${getMeteorAppDir()}/package.json`, 'utf-8'),\n  );\n}\n\nfunction getMeteorAppSwcrc(file = '.swcrc') {\n  try {\n    const filePath = `${getMeteorAppDir()}/${file}`;\n    if (file.endsWith('.js')) {\n      let content = fs.readFileSync(filePath, 'utf-8');\n      // Check if the content uses ES module syntax (export default)\n      if (content.includes('export default')) {\n        // Transform ES module syntax to CommonJS\n        content = content.replace(/export\\s+default\\s+/, 'module.exports = ');\n      }\n      const script = new vm.Script(`\n        (function() {\n          const module = {};\n          module.exports = {};\n          (function(exports, module) {\n            ${content}\n          })(module.exports, module);\n          return module.exports;\n        })()\n      `);\n      const context = vm.createContext({ process });\n      return script.runInContext(context);\n    } else {\n      // For .swcrc and other JSON files, parse as JSON\n      return JSON.parse(fs.readFileSync(filePath, 'utf-8'));\n    }\n  } catch (e) {\n    console.error(`Error parsing ${file} file`, e);\n  }\n}\n\nconst _regexCache = new Map();\n\nfunction isRegexLike(str) {\n  return /[.*+?^${}()|[\\]\\\\]/.test(str);\n}\n\nfunction isExcludedConfig(name, excludeList = [], startsWith) {\n  if (!name || !excludeList?.length) return false;\n  return excludeList.some(rule => {\n    if (name === rule) return true;\n    if (startsWith && name.startsWith(rule)) return true;\n    if (isRegexLike(rule)) {\n      let regex = _regexCache.get(rule);\n      if (!regex) {\n        try {\n          regex = new RegExp(rule);\n          _regexCache.set(rule, regex);\n        } catch (err) {\n          console.warn(`Invalid regex in exclude list: \"${rule}\"`);\n          return false;\n        }\n      }\n      return regex.test(name);\n    }\n\n    return false;\n  });\n}\n\nconst disableTextColors = Boolean(JSON.parse(process.env.METEOR_DISABLE_COLORS || \"false\"));\n\nfunction color(text, code) {\n  return disableTextColors ? text : `\\x1b[${code}m${text}\\x1b[0m`;\n}\n\nfunction logTranspilation({\n  packageName,\n  inputFilePath,\n  usedSwc,\n  cacheHit,\n  isNodeModulesCode,\n  arch,\n  errorMessage = '',\n  tip = '',\n}) {\n  const transpiler = usedSwc ? 'SWC' : 'Babel';\n  const transpilerColor = usedSwc ? 32 : 33;\n  const label = color('[Transpiler]', 36);\n  const transpilerPart = `${label} Used ${color(\n    transpiler,\n    transpilerColor,\n  )} for`;\n  const filePathPadded = `${\n    packageName ? `${packageName}/` : ''\n  }${inputFilePath}`.padEnd(50);\n  let rawOrigin = '';\n  if (packageName) {\n    rawOrigin = `(package)`;\n  } else {\n    rawOrigin = isNodeModulesCode ? '(node_modules)' : '(app)';\n  }\n  const originPaddedRaw = rawOrigin.padEnd(35);\n  const originPaddedColored = packageName\n    ? originPaddedRaw\n    : isNodeModulesCode\n    ? color(originPaddedRaw, 90)\n    : color(originPaddedRaw, 35);\n  const cacheStatus = errorMessage\n    ? color('⚠️  Fallback', 33)\n    : usedSwc\n    ? cacheHit\n      ? color('🟢 Cache hit', 32)\n      : color('🔴 Cache miss', 31)\n    : '';\n  const archPart = arch ? color(` (${arch})`, 90) : '';\n  console.log(\n    `${transpilerPart} ${filePathPadded}${originPaddedColored}${cacheStatus}${archPart}`,\n  );\n  if (errorMessage) {\n    console.log();\n    console.log(`  ↳ ${color('Error:', 31)} ${errorMessage}`);\n    if (tip) {\n      console.log();\n      console.log(`  ${color('💡 Tip:', 33)} ${tip}`);\n    }\n    console.log();\n  }\n}\n\nfunction logConfigBlock(description, configObject) {\n  const label = color('[Config]', 36);\n  const descriptionColor = color(description, 90);\n\n  console.log(`${label} ${descriptionColor}`);\n\n  const configLines = JSON.stringify(configObject, null, 2)\n    .replace(/\"([^\"]+)\":/g, '$1:')\n    .split('\\n')\n    .map(line => '  ' + line);\n\n  configLines.forEach(line => console.log(line));\n  console.log();\n}\n\nfunction deepMerge(target, source, preservePaths = [], inPath = '') {\n  for (const key in source) {\n    const fullPath = inPath ? `${inPath}.${key}` : key;\n\n    // Skip preserved paths\n    if (preservePaths.includes(fullPath)) continue;\n\n    if (\n      typeof source[key] === 'object' &&\n      source[key] !== null &&\n      !Array.isArray(source[key])\n    ) {\n      target[key] = deepMerge(\n        target[key] || {},\n        source[key],\n        preservePaths,\n        fullPath,\n      );\n    } else {\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction convertBabelTargetsForSwc(babelTargets) {\n  const allowedEnvs = new Set([\n    'chrome', 'opera', 'edge', 'firefox', 'safari',\n    'ie', 'ios', 'android', 'node', 'electron'\n  ]);\n\n  const filteredTargets = {};\n  for (const [env, version] of Object.entries(babelTargets)) {\n    if (allowedEnvs.has(env)) {\n      // Convert an array version (e.g., [10, 3]) into \"10.3\", otherwise convert to string.\n      filteredTargets[env] = Array.isArray(version) ? version.join('.') : version.toString();\n    }\n  }\n\n  return filteredTargets;\n}\n\n/**\n * A compiler that extends BabelCompiler but always uses SWC\n * @param {Object} extraFeatures Additional features to pass to BabelCompiler\n * @param {Function} modifyConfig Function to modify the configuration\n */\nSwcCompiler = function SwcCompiler(extraFeatures, modifyConfig) {\n  extraFeatures = extraFeatures || {};\n  extraFeatures.swc = true;\n  BabelCompiler.call(this, extraFeatures, modifyConfig);\n};\n\n// Inherit from BabelCompiler\nSwcCompiler.prototype = Object.create(BabelCompiler.prototype);\nSwcCompiler.prototype.constructor = SwcCompiler;\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                           //\n// packages/babel-compiler/versions.js                                                                       //\n//                                                                                                           //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                             //\n// Make sure code compiled with features.modernBrowsers is delivered only\n// to browsers that satisfy the assumptions of meteor-babel's modern Babel\n// configuration.\nPackage[\"modern-browsers\"].setMinimumBrowserVersions(\n  Babel.getMinimumModernBrowserVersions(),\n  // Although module.id is the recommended source string to pass as the\n  // second argument to setMinimumBrowserVersions, we can't use module.id\n  // here because babel-compiler cannot depend on the modules package. We\n  // can still make this string look like any other module.id, though.\n  \"/node_modules/meteor/babel-compiler/versions.js\"\n);\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      Babel: Babel,\n      BabelCompiler: BabelCompiler,\n      SwcCompiler: SwcCompiler\n    };}\n}});\n","servePath":"/packages/babel-compiler.js"}]